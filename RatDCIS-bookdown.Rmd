--- 
title: "Rat DCIS study"
author: "Anne Trinh"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: polyak-lab/RatDCISbookdown
url: 'https://polyak-lab.github.io/RatDCISbookdown/'
description: "This is a summary of the code required in the study: 'insert study name' "
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, cache.lazy=F, fig.height =5, fig.width = 7, cache = T, 
                      warning=F, message=F)
```

This is a summary of the code required in the study: 'insert study name' 

# Prerequisites

## Packages and Software

The following packages are required to conduct the analyses described below.

In house scripts are deposited in the rscript folder.

```{r, warning=F, message=F, echo=T, results='hide'}
library(AnnotationHub)
library(biomaRt)
library(Biostrings)
library(colorspace)
library(DESeq2)
library(dplyr)
library(DT)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(GenVisR)
library(GenomicFeatures)
library(ggplot2)
library(gplots)
library(GSEABase)
library(GSVA)
library(heatmap.plus)
library(HTSanalyzeR2)
library(kableExtra)
library(limma)
library(matrixStats)
library(pamr)
library(reshape2)
library(RColorBrewer)
library(scales)
library(spatstat)
library(tcR)
library(vcfR)
library(xlsx)
library(writexl)

DiffCols=hue_pal()(8)
palette(brewer.pal(9, "Set1"))
RdBu=brewer.pal(11, "RdBu")
SetCols=brewer.pal(12, "Set3")

source("../rscript/cnFreq_fn.R") #modified version of GenVisR
source("../rscript/merge_contig.R")
source("../rscript/gseaCode.R")
source("../rscript/ContingencyTable.R")
source("../rscript/PvalueHeatMap.R")
source("../rscript/BootstrapShannonIdx.R")
#source("../rscript/CreateRnor87db.R")
source("../rscript/FindRatAAHomolog.R")
source("../rscript/OutputplotFun.R")

firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}

ColMerge=matrix(c("#FFC82F", "#FFEDBC", "#73FDFE","#D2FFFF", "#FF41FF", "#FECAFF", "#5D5D5D", "#BEBEBE"), ncol=2, byrow = T)
rownames(ColMerge)=c("LY","PDL1", "PDL1+LY","Vehicle")

Hsedb<-EnsDb.Hsapiens.v86
```

## External software

The following external software was utilised:  

|Software| Function |
|--------|-----------------------------------------------------------------------|
|[bwa](http://bio-bwa.sourceforge.net/)| Alignment of WGS data to reference|
|[GATK4](https://software.broadinstitute.org/gatk/)| Mutation calling, done by NYGC. Mutation calling from RNA (Haplotype caller) |
|[strelka](https://github.com/Illumina/strelka)| Mutation calling, done by NYGC |
|[BICseq](http://compbio.med.harvard.edu/BIC-seq/) | CNV calling |
|[GEM3](https://sourceforge.net/projects/gemlibrary/files/gem-library/)| create mappability files for CNV calling|
|[STAR](https://github.com/alexdobin/STAR) | Alignment of RNAseq data|
|[RSEM](https://github.com/deweylab/RSEM)|Calculate RSEM, TPM, FPKM from RNAseq data|
|[TRUST4](https://github.com/liulab-dfci/TRUST4) | assignment of T and B cell clonotypes from RNA-seq data |
|[Oncotator](https://gatkforums.broadinstitute.org/gatk/discussion/4154/howto-install-and-run-oncotator-for-the-first-time) | Annotation of genetic variants|
|[QuPath](https://qupath.github.io/)| Tool for cell segmentation and extraction of features from IF images |
|[samtools, bcftools](http://www.htslib.org/)| querying and dispalying information from bam files, extracting allelic depth at specific genomic locations |
|[CIBERSORT](https://cibersort.stanford.edu/) | inferring immune composition from RNA|
|[lumpy](https://github.com/arq5x/lumpy-sv) | structural variants|
|[PAM50](https://genome.unc.edu/pubsup/breastGEO/PAM50.zip) | code from parker et al 2009 to infer PAM50 subtypes|


## Annotations

### Genomic properties

Information on chromosome sizes, cytobands and centromere locations were obtained from the [UCSC genome browser](http://hgdownload.soe.ucsc.edu/goldenPath/rn6/database/).

The following annotation data for the hg19/b37/GRCh37 genome is required:

|Data Type| Download link|
|--------|-----------------|
|ref. genome| http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/rn6.fa.gz|
|refSeq annot|http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/genes/rn6.refGene.gtf.gz|
|refSeq annot|http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/genes/rn6.ncbiRefSeq.gtf.gz|
|gff3 file| for TRUST4 (ftp://ftp.ensembl.org/pub/release-100/gff3/rattus_norvegicus/Rattus_norvegicus.Rnor_6.0.100.gff3.gz)|
|gene lengths| Extracted from GRCh37.75.gtf file from [ensembl](ftp://ftp.ensembl.org/pub/grch37/current/gtf/homo_sapiens/)|
|hg19cytoBand | [ucsc server](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/cytoBand.txt.gz) of all cytoband locations  |
|chromosome sizes | [uscs genome browser](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/database/chromInfo.txt.gz) |
|[biomart](https://bioconductor.org/packages/release/bioc/html/biomaRt.html)| conversion between gene symbol, ensbl and entrez was faciliated using biomart package |

Below is the summary of chromosome sizes and centromere locations:

```{r}
cytoInfo=read.delim("../anntotations/cytoBand_Rat2.txt", header=F, stringsAsFactors = F)
colnames(cytoInfo)=c("chrom", "chromStart", "chromEnd", "name", "gieStain")
GRcytoInfo=GRanges(seqnames=cytoInfo$V1, ranges=IRanges(start = cytoInfo$V2, end=cytoInfo$V3), cytoband=cytoInfo$V4)

head(cytoInfo)
```

Create a TxDb object from a gtf file and save information: <span style="color:red">Not sure which version to use??</span>

Below is an example of the gene annotation files

```{r, cache=T, message=F, eval=F}
Rn6TxDb=makeTxDbFromGFF("../dontUpload/rn6_refGene.gtf",
                        organism="Rattus norvegicus")
Rn6TxDb2<-genes(Rn6TxDb)
```

```{r, eval=F}
txRn6=makeTxDbFromGFF("../anntotations/rn6_refGene.gtf", format="gtf")
txRn6=genes(txRn6)
txRn6=sort(txRn6)
txRn6$gene_width=width(txRn6)
save(txRn6, file="../anntotations/txRn6_refGene.RData")
```

```{r}
load("../anntotations/txRn6_refGene.RData")
head(txRn6)
```

### Gene name homologs between organisms

Biomart was used to convert between rat, mouse and human gene symbols and ensembl ids. Below is an example of the human gene names mapped to the rat homolog

<span style="color:red">
Figure out what is required here for later analysis
</span>
```{r, eval=F}
## save here:
## human to rat mapping of genes
## rat ENSEMBL vs symbol conversion

library(biomaRt)
#library(refGenome)
TS=read.delim("anntotations//hg38_allsymbols.txt")
TS=as.character(TS[ ,1])
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
rat = useMart("ensembl", dataset = "rnorvegicus_gene_ensembl")

SymHum2Rat = getLDS(attributes = c("hgnc_symbol"), filters = "hgnc_symbol", values = TS , mart = human, attributesL = c("rgd_symbol", "ensembl_gene_id"), martL = rat, uniqueRows=T)

## need to run this after evaluating the gene names 
#Rat2Hum = getLDS(attributes = c("rgd_symbol"), filters = "rgd_symbol", values = rownames(allrsemFinal) , mart = rat, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)

# Rat2Mouse= getLDS(attributes = c("mmusculus_homolog_associated_gene_name"), filters = "rgd_symbol", values = rownames(allrsemFinal) , mart = rat, attributesL = c("mgi_symbol"), martL = mouse, uniqueRows=T)

Rat2Mouse= getLDS(attributes = c("rgd_symbol"), filters = "rgd_symbol", values = rownames(allrsemFinal) , mart = rat, attributesL = c("mgi_symbol"), martL = mouse, uniqueRows=T)

Mouse2Hum = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = rownames(allrsemFinal) , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)

save(SymHum2Rat, Rat2Hum,Mouse2Hum,Rat2Mouse,  file="../anntotations/Rat_biomart_gene_annotations2.RData")
```

```{r}
load("../anntotations/Rat_biomart_gene_annotations.RData")
head(SymHum2Rat)
```

### Gene signatures and data-bases

Gene sets/signatures were obtained from the following sources:

|Source | Description      |
|-------|------------------------|
|[IEDB](https://www.iedb.org/)| database of immune epitopes |
|[MsigDB](http://software.broadinstitute.org/gsea/msigdb/index.jsp) | c2, c5, hallmark set of curated pathway gene sets |
|[Metacore]()| Process Networks and Pathway Maps data bases |
|[COSMIC](https://cancer.sanger.ac.uk/census) |database of concensus oncogenes|
|[ImmPort](https://www.immport.org/home)| List of immune related genes |
|[InnateDB](https://www.innatedb.com/) | List of genes associated with innate immune system|
|[Rosenthal 2019](https://dx.doi.org/10.1038/s41586-019-1032-7) | genes associated with MHC-I presentation |
|[Thorsson 2018](http://dx.doi.org/10.1016/j.immuni.2018.03.023) | Immune gene signatures curated from studies by Wolf, Calabro, Teschendorff, Beck, Chang |
|[Pardoll](https://www.ncbi.nlm.nih.gov/pubmed/22437870), [Wykes](https://www.ncbi.nlm.nih.gov/pubmed/28990586) | Immune checkpoint genes| 
|[gil del alcazar 2017](https://cancerdiscovery.aacrjournals.org/content/early/2017/09/19/2159-8290.CD-17-0222) | Supplementary table 5: list of activation, dysfunction gene signatures |
|[Bailey 2018](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6029450/)| List of 10 most comon tumor pathways |
|[Chang 2018](https://pubmed.ncbi.nlm.nih.gov/29247016/)| Common mutation locations in cancer |

The PAM50 signature was implemented using the scripts provided in supplementary from [Parker et al 2010](https://genome.unc.edu/pubsup/breastGEO/PAM50.zip). These gene lists can be found in the annotations folder


```{r}
# These gene signatures are saved in the annotations folder and loaded below:
#########################
## cell specific markers
#######################
GeneList=read.csv("../anntotations/cell_type_markers.csv")
cn=colnames(GeneList)
GeneList=lapply(1:ncol(GeneList), function(x) setdiff(unique(GeneList[ ,x]), ""))
names(GeneList)=cn
## map all the names to rat names
GeneListRat=lapply(GeneList, function(x) SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%x])

######################
## cancer genes
######################

## cosmic cancer genes
AllCosmic=read.csv("../anntotations/Census_COSMIC_Feb2020.csv")
RatCosmic=SymHum2Rat$RGD.symbol[match(AllCosmic$Gene.Symbol, SymHum2Rat$HGNC.symbol)]
tx=AllCosmic$Gene.Symbol[which(is.na(RatCosmic)|RatCosmic=="")]
tx=tolower(tx)
tx=firstup(tx)
RatCosmic[which(is.na(RatCosmic)|RatCosmic=="")]=tx
RatBreastCosmic=RatCosmic[grep("breast", AllCosmic$Tumour.Types.Somatic.)]

## Bailey List of 10 most common tumor pathways
PathwayList=read.csv("../anntotations/cancer_pathways_annot_Bailey_cell2018_modified.csv")
cn=colnames(PathwayList)
PathwayListA=lapply(seq(1, length(cn), by=2), function(x) setdiff(unique(PathwayList[ ,x]), ""))
names(PathwayListA)=cn[seq(1, length(cn), by=2)]
PathwaySign=lapply(seq(2, length(cn), by=2), function(x) PathwayList[ which(PathwayList[ ,x]!=""),x])
names(PathwaySign)=cn[seq(1, length(cn), by=2)]

PathwayListRata=lapply(PathwayListA, function(x) SymHum2Rat$RGD.symbol[match(x, SymHum2Rat$HGNC.symbol)])
PathwayListRatb=lapply(PathwayListA, function(x) Rat2Hum$RGD.symbol[match(x, Rat2Hum$HGNC.symbol)])
PathwayListRat=lapply(1:length(PathwayListRata), function(x) ifelse(is.na(PathwayListRata[[x]]),
                        PathwayListRatb[[x]], PathwayListRata[[x]]))
names(PathwayListRat)=names(PathwayListA)

AllCancerPathwayGenes=na.omit(unlist(PathwayListRat))

############################
## List of immunesignatures
############################
## read in all the files
Exp2=read.csv("../anntotations/Supplementary Table 5.csv")
Exp2List=lapply(1:ncol(Exp2), function(x) setdiff(unique(Exp2[ ,x]), ""))
names(Exp2List)=colnames(Exp2)

List2=read.csv("../anntotations/Thorsson_signatures.csv")
List2b=lapply(1:ncol(List2), function(x) setdiff(unique(List2[ ,x]), ""))
names(List2b)=colnames(List2)
Exp2List=c(Exp2List, List2b)

ImmSuppAPC=read.delim("../anntotations/immune_Suppression.csv", header=T, stringsAsFactors = F, sep=",")
ImmSuppAPC=lapply(1:ncol(ImmSuppAPC), function(x) setdiff(unique(ImmSuppAPC[ ,x]), ""))
names(ImmSuppAPC)=c("Inh", "Act", "Both")
Exp2List=c(Exp2List, ImmSuppAPC)

MHCPres=read.delim("../anntotations/MHCloss.csv", header=F, stringsAsFactors = F, sep=",")
MHCPres=as.character(MHCPres[ ,1])
MHCPres2Rat=unique(SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%MHCPres])

## change the names to Rat-specific 
Exp2RatImm=lapply(Exp2List, function(x) unique(SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%x]))

## All immune genes
AllImmGenes1=read.csv("../anntotations/ImmPort_Set.csv")
AllImmGenes2=read.csv("../anntotations/innatedb_curated_genes.csv")
AllImmGenes=unique(c(as.character(AllImmGenes1$Symbol), as.character(AllImmGenes2$Gene.Symbol[which(AllImmGenes2$Species==9606)])))
RatAllImm=na.omit(unique(c(SymHum2Rat$RGD.symbol[match(AllImmGenes, SymHum2Rat$HGNC.symbol)], as.character(AllImmGenes2$Gene.Symbol[which(AllImmGenes2$Species!=9606)]))))

## CIBERSORT specific rat genes
lm22rat=read.delim("../anntotations/LM22_to_rnorvegicus_1.txt", sep="\t")
```

#### Human gene homologs

Below, lists of common mutations in cancer are loaded and the "homolog" in rat is determined using an in-house script. The steps involved are:

* determine the amino acid context in human (find 5 a.a. prior and after)
* find the region with most amino acid homology in rat (2 or less differences)
* check whether the amino acid of interest is present in rat

An example of the output is shown

```{r mut-hum2rat}
######################
## Annotation for Mutation Locations
######################
BaileyList=read.csv("../anntotations/list_mutations_bailey.csv", stringsAsFactors = F)
BList=FindRatAAHomolog(BaileyList$Gene, substr(BaileyList$Mutation, 3, 3),  substr(BaileyList$Mutation, 4, nchar(as.character(BaileyList$Mutation))-1), substr(BaileyList$Mutation, nchar(as.character(BaileyList$Mutation)), nchar(as.character(BaileyList$Mutation))))

ChangList=read.delim("../anntotations/hotspots_chang_et_al_2017_cancer_discovery.txt", sep="\t", stringsAsFactors = F)
ChangList=ChangList[which(ChangList$Type=="single residue"), ]
ChangList$AA1=substr(ChangList$Residue, 1, 1)
ChangList$Loc=substr(ChangList$Residue,2, nchar(ChangList$Residue))
AA2list=sapply(ChangList$Variants, function(x) strsplit(x, ":[0-9]+[\\|]*"))
AAun=unlist(AA2list)
C2List=tibble(ChangList[ ,c("Gene", "AA1", "Loc")])
C2List=C2List %>% slice(rep(1:n(), times=sapply(AA2list, length)))
C2List$AA2=AAun
C2List=C2List[-which(C2List$AA2=="sp"| C2List$AA1=="*"), ]
#C2ListB=C2List[-which(is.na(C2List$Loc)), ]

ChangList2=FindRatAAHomolog(C2List$Gene, C2List$AA1,  C2List$Loc, C2List$AA2)

head(ChangList2)
```

#### GSEA compendiums

For pathway analysis, the c2 (pathway), Hallmark and c5 (Gene Ontology). In addition, metacore pathways (pathway maps and process networks) were obtained and loaded below. This gives a list of 7 different data-sets to interrogate
<span style="color:red">
CHECK: When GSVA is run, which input is required??
</span>

```{r gsea-load}
PathInc2=getGmt(con="../anntotations/c2.cp.v7.0.symbols.gmt", geneIdType=SymbolIdentifier(),
                collectionType=BroadCollection(category="c2"))

c2entrez=mapIdentifiers(PathInc2, EntrezIdentifier('org.Hs.eg.db'))
c2ListHs=geneIds(c2entrez)

PathInH=getGmt(con="../anntotations/h.all.v7.1.symbols.gmt", geneIdType=SymbolIdentifier(),
                collectionType=BroadCollection(category="h"))

cHentrez=mapIdentifiers(PathInH, EntrezIdentifier('org.Hs.eg.db'))
cHListHs=geneIds(cHentrez)

#####################################################
# also load in the process networks and pathway maps 
#################

# load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData.RData")
# 
# ProcessNetworksAllComp2=list()
# for (i in 1:(length(ProcessNetworksAllComp)-1)){
# ProcessNetworksAllComp2[[i]]=GeneSet(ProcessNetworksAllComp[[i]], setName=names(ProcessNetworksAllComp)[i], geneIdType=SymbolIdentifier())
# }
# 
# ProcessPathway=GeneSetCollection(ProcessNetworksAllComp2)
# ProcessPathway=mapIdentifiers(ProcessPathway, EntrezIdentifier('org.Hs.eg.db'))
# ProcessPathwayList=geneIds(ProcessPathway)

load("../anntotations/ListofGeneSets2.RData")
```

<!--chapter:end:index.Rmd-->

# Cohort summary

Below we assess summary statistics on clinico-pathological features of this data set. This includes information on:

* treatment
* tumor size
* growth rates (mm/week)
* number of tumors per rat 

```{r}
Cdata=xlsx::read.xlsx("../metadata/Carlos_samples_list_master_updated_2020-10-05.xlsx", sheetIndex=1)

## temp only
## add in info on size for the CXX samples
#ax1=which(is.na(infoTableFinal$TumSize))
#infoTableFinal$TumSize[ax1]=Cdata$Tumor.dia..sac..mm.[match(infoTableFinal$TumorID[ax1], Cdata$TumorID)]

scroll_box(kable(Cdata, format="html"),
         height="300px", width="100%")
```

We have two cohorts, the characterisation and progression cohorts. Below is a plot of the size distribution in these two cohorts:

```{r}
par(mfrow=c(1,2))
hist(Cdata$Tumor.dia..sac..mm.[which(Cdata$Cohort!="Progression")], breaks=15,
     main="characterisation sizes")
X1a=median(Cdata$Tumor.dia..sac..mm.[which(Cdata$Cohort!="Progression")], na.rm = T)

hist(Cdata$Tumor.dia..sac..mm.[which(Cdata$Cohort=="Progression")], breaks=15,
     main="progression sizes")
X2a=median(Cdata$Tumor.dia..sac..mm.[which(Cdata$Cohort=="Progression")], na.rm=T)
```

## Calculating growth rates

In this section, we estimate the growth rates of the samples: Below is a plot of the tumor size per week for each recorded tumor, color-coded according to treatment. Time is measured at the first time point at which a tumor is palpated. Spontaneous large tumors are assumed to have a tumor size of 0 or 1 one week prior to palpating.

```{r}
GrowthRaw=read.csv("../metadata/growth_rates_0915.csv")
colnames(GrowthRaw)[-1]=substr(colnames(GrowthRaw)[-1], 2, 10)
colnames(GrowthRaw)=gsub("\\.", "-", colnames(GrowthRaw))

CTreat=Cdata$Treatment[match(colnames(GrowthRaw), gsub("_", "", Cdata$TumorID))]
CTreat=ColMerge[match(CTreat, rownames(ColMerge)) ,1]
Cgrowth=Cdata$Tumor.growth.status[match(colnames(GrowthRaw), gsub("_", "", Cdata$TumorID))]

#pdf(sprintf("rslt/Clinicopath/summary_growth_plots_%s.pdf", Sys.Date()), width=8, height=8)

par(xpd=T)
plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main="Tumor size over time")

for (i in 2:ncol(GrowthRaw)){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=CTreat[i])
}
legend("bottom", inset = c(-0.2, -0.2), rownames(ColMerge), col=ColMerge[ ,1], lwd=2, horiz = T)

ax1=colnames(GrowthRaw)[-1][which(CTreat[-1]=="Unknown")]
bx1=Cdata$TumorID[!gsub("_", "", Cdata$TumorID)%in%colnames(GrowthRaw)]
bx1=bx1[which(bx1%in%Cdata$TumorID[Cdata$Tumor.growth.status%in%c("stable", "growing")])]

#Plot the above into quadrants based on different treatments:
par(mfrow=c(2,2))
xn=levels(factor(names(CTreat)))
x2=CTreat[xn]
for (j in 1:4){
  indx=which(CTreat==x2[j])
  indx=setdiff(indx, 1)
  plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main=xn[j])
for (i in indx){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=CTreat[i])
  text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], i], colnames(GrowthRaw)[i], cex=0.6)
}
}

#dev.off()
```

These tumors doesn't have growth rate data: `r bx1`.

We can then compute the growth rate for the above samples by considering the change in size over a given period of time using a linear regression model. Below is the histogram of growth rates:

```{r, fig.height=5}
GR=sapply(2:ncol(GrowthRaw), function(x) lm(GrowthRaw[, x]~GrowthRaw[, 1])$coefficients[2])
names(GR)=colnames(GrowthRaw)[-1]

d1=data.frame(growthrate=GR, treatment=names(CTreat[-1]), growth=Cgrowth[-1], color=CTreat[-1])

Nweeks=sapply(2:ncol(GrowthRaw), function(x) max(which(!is.na(GrowthRaw[ , x]))))
names(Nweeks)=names(GR)

d1$Nweeks=Nweeks[match(rownames(d1), names(Nweeks))]
d1$Time.Tum2Sac=Cdata$Time.Tumor2Sac[match(rownames(d1), gsub("_", "", Cdata$TumorID))]
d1$Time.NMU2Sac=Cdata$Time.NMU2Sac[match(rownames(d1), gsub("_", "", Cdata$TumorID))]
d1$tum.size=Cdata$Tumor.dia..sac..mm.[match(rownames(d1), gsub("_", "", Cdata$TumorID))]
d1$growthrate_cutoff2=ifelse(d1$growthrate>=2, "growing", "stable")

#pdf(sprintf("rslt/Clinicopath/summary_growth_rates_%s.pdf", Sys.Date()), width=8, height=6)
#hist(GR, breaks=30, main="distribution of growth rates (mm/week)")
# redo this plot showing the treatment groups:
ggplot(d1, aes(x=growthrate, fill=treatment))+geom_histogram(colour="black")+theme_bw()+geom_vline(aes(xintercept=2), colour="grey45", linetype="dashed")+scale_fill_manual(values=ColMerge[ ,1])

```

Based on the above distribution, a cut-off of 2mm/week may be an optimal cut-off to separate growing and stable tumors. Below are growth rates of tumors under different treatments:

```{r}
ggplot(d1, aes(x=treatment, y=growthrate, col=treatment))+geom_boxplot()+geom_jitter()+
  scale_color_manual(values=ColMerge[ ,1])
```

We can calculate the p.values below, using a  t.test. The growth rates comparing the treatment to the controls are:

```{r}
print('LY samples')
wilcox.test(d1$growthrate[d1$treatment=="LY"], d1$growthrate[d1$treatment=="Vehicle"])
print('PDL1 samples')
wilcox.test(d1$growthrate[d1$treatment=="PDL1"], d1$growthrate[d1$treatment=="Vehicle"])
print('PDL1+LY samples')
wilcox.test(d1$growthrate[d1$treatment=="PDL1+LY"], d1$growthrate[d1$treatment=="Vehicle"])
```

This shows a smaller growth-rate in PDL1 single and double treated cases compared to the vehicles.

Overall the distribution of growing vs stable tumors is shown below:

```{r}
table(ifelse(d1$growthrate>=2, "grow", "stable"))
```

We can replot the previous graphs according to growth, and color code according to whether it is a fast or slow growing tumor

```{r}
#pdf(sprintf("rslt/Clinicopath/summary_growth_plots_with shadings%s.pdf", Sys.Date()), width=8, height=8)

par(xpd=T)

#Plot the above into quadrants based on different treatments:
par(mfrow=c(2,2))
for (j in 1:length(xn)){
  indx=which(names(CTreat)==xn[j])
  indx=setdiff(indx, 1)
#   plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main=paste("Original", xn[j]))
# for (i in indx){
#   x1=which(!is.na(GrowthRaw[, i]))
#   lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=ifelse(d1$growth[i-1]=="growing", ColMerge[j, 1], ifelse(d1$growth[i-1]=="stable", ColMerge[j, 2], "black")), type="o", pch=19)
#   text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], i], colnames(GrowthRaw)[i], cex=0.6)
# }
  plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main=paste("Redone", xn[j]))
for (i in indx){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=ifelse(d1$growthrate_cutoff2[i-1]=="growing", ColMerge[j, 1], ifelse(d1$growthrate_cutoff2[i-1]=="stable", ColMerge[j, 2], "black")), type="o", pch=19)
  text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], i], colnames(GrowthRaw)[i], cex=0.6)
}
  
}

#dev.off()

```

As a sanity check, compare these growth rates with differences in tumour size at different time points:

* comparing the growth rate according to classifications (growing, stable)
* tumor size at time of sacrifice
* rate of tumor development from the time of NMU injection

```{r, fig.height=4,warning='hide'}
par(mfrow=c(1,3))
# boxplot(d1$growthrate~d1$growth, main="growth rate, original growth", las=2, ylab="rate (mm/week)")
boxplot(d1$growthrate~d1$growthrate_cutoff2, main="growth rate, new growth", las=2,  ylab="tumor growth rate (mm/week)", xlab="")
x1=wilcox.test(d1$growthrate~d1$growthrate_cutoff2)$p.value
text(1.5, 20, paste("wilcox p =", round(x1, 3)))

# boxplot(d1$tum.size~d1$growth, main="tum size at sac, original growth", las=2, ylab="size @ sac (mm)")
boxplot(d1$tum.size~d1$growthrate_cutoff2, main="tum size at sac, new growth", las=2, ylab="Tumor diameter (mm)", xlab="")
x1=wilcox.test(d1$tum.size~d1$growthrate_cutoff2)$p.value
text(1.5, 40, paste("wilcox p =", round(x1, 3)))
# boxplot(d1$tum.size/d1$Time.NMU2Sac~d1$growth, main="rate NMU2SAC, original growth", las=2, ylab="rate (mm/week)")
boxplot(d1$tum.size/d1$Time.NMU2Sac~d1$growthrate_cutoff2, main="rate NMU2SAC", las=2, ylab="growth rate from NMU injection (mm/wk)", xlab="")
x1=wilcox.test(d1$tum.size/d1$Time.NMU2Sac~d1$growthrate_cutoff2)$p.value
text(1.5, 0.6, paste("wilcox p =", round(x1, 3)))

# boxplot(d1$growthrate~d1$treatment, main="growth rate, original growth", las=2, ylab="rate (mm/week)")
#boxplot(d1$growthrate~d1$growthrate_cutoff2, main="growth rate, new growth", las=2)

```

Is there an association with treatment? Calculate below using chi-squared test:

```{r, fig.height=3, fig.width=5}
## Old data

# print('new data outcome')
 a3=chisq.test(table(factor(d1$treatment), d1$growthrate_cutoff2))
 a3

#chisq.test(table(factor(d1$treatment[d1$growth%in%c("growing", "stable")]), factor(d1$growth[d1$growth%in%c("growing", "stable")])))
#a4

#pdf(sprintf("rslt/summary_growth_plots_contigency%s.pdf", Sys.Date()), width=6, height=4)

 ContTable(table(factor(d1$treatment), d1$growthrate_cutoff2), "new rates", T, "growth", "treatment")

#ContTable(table(factor(d1$treatment[d1$growth%in%c("growing", "stable")]), factor(d1$growth[d1$growth%in%c("growing", "stable")])), "old rates", T, "growth", "treatment")

#dev.off()

```

Overall, it appears that there is an association between growth rate and treatment

```{r}
# Replace the Cdata information with new growth information
Cdata$Growth2=d1$growthrate_cutoff2[match(gsub("_", "", Cdata$TumorID), rownames(d1))]
Cdata$GrowthRate=d1$growthrate[match(gsub("_", "", Cdata$TumorID), rownames(d1))]

#write.xlsx(Cdata, file=sprintf("metadata/Carlos_samples_list_master_updated_%s.xlsx", Sys.Date()))
```

## FACS data

The immune (CD45) fractions from a number of samples were collected, and assessed using FACs. The major cell types detected are:

Leukocytes:

* Tregs 
* CD8 T cells
* Thelper cells
* B cells
* NK T cells
* gamma delta T cells 

Myeloid cells:

* Macrophages M1
* Macrophages M2
* Dendritic cells
* Monocytes
* Neutrophils

We can look at the:

* types of cells
* distributions

Note that in a number of samples the leukocyte population could not be inferred with confidence, and proportions are normalised to the myeloid population

```{r}
Fdata=read.csv("../data/carlos_facs_tumors.csv", stringsAsFactors = F)
Fdata[ ,2:ncol(Fdata)]=Fdata[ ,2:ncol(Fdata)]/100
m1=substr(colnames(Fdata), 2, 5)
colnames(Fdata)=m1
colnames(Fdata)[1]="type"

scroll_box(kable(Fdata, format="html"),
         height="300px", width="100%")

t2=Fdata[-which(Fdata[ ,1]==""),]
#rownames(t2)=Fdata[-which(Fdata[ ,1]=="") ,1]
t2=t2[-c(1:2, 14), ]
t2melt=melt(t2)

ggplot(t2melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('all samples')+theme(axis.text.x = element_text(angle = 90))

```

We can look solely at the myeloid population (and normalise to this total), and color according to growth

```{r}
t3=t2[7:11, ]
t3[, 2:ncol(t3)]=t(t(t3[, 2:ncol(t3)])/colSums(t3[, 2:ncol(t3)]))
t3melt=melt(t3)

t3melt$growth=d1$growthrate_cutoff2[match(t3melt$variable, rownames(d1))]

ggplot(t3melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('myeloid specific')+theme(axis.text.x = element_text(angle = 90))
```
Similarly, we can look at the leukocyte population. Note that the Treg population in some of these samples is very high.

```{r}
t3=t2[1:6, ]
t3[, 2:ncol(t3)]=t(t(t3[, 2:ncol(t3)])/colSums(t3[, 2:ncol(t3)]))
t3melt=melt(t3)

t3melt$growth=d1$growthrate_cutoff2[match(t3melt$variable, rownames(d1))]

ggplot(t3melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('leukocyte specific')+theme(axis.text.x = element_text(angle = 90))
```

<!--chapter:end:01a-cohort-summary.Rmd-->

## Summary Table

Firstly, look at the total number of samples:

```{r}
#recur variables here
avtum=table(Cdata$Rat_ID)
Cchar=Cdata[Cdata$Cohort!="Progression", ]
Cprog=Cdata[Cdata$Cohort=="Progression", ]
```


Feature | Levels | N
--------|---------|-----
Total No Tumors |All | `r nrow(Cdata)`
- | Characterisation| `r length(which(Cdata$Cohort=="Characterisation"))`
- | Prevention | `r length(which(Cdata$Cohort=="Prevention"))`
- | Progression | `r length(which(Cdata$Cohort=="Progression"))`
Total No Rats | All| `r length(unique(Cdata$Rat_ID))`
- | Characterisation| `r length(unique(Cdata$Rat_ID[which(Cdata$Cohort=="Characterisation")]))`
- | Prevention | `r length(unique(Cdata$Rat_ID[which(Cdata$Cohort=="Prevention")]))`
- | Progression | `r length(unique(Cdata$Rat_ID[which(Cdata$Cohort=="Progression")]))`
No tumours per rat | | `r round(mean(avtum),2) ` ( `r quantile(avtum, c(0.1, 0.9))`)

### Compare the characterisation vs progression cohort

Feature | Levels | Characterisation | Progression
--------|---------|-------- |------
Total No tumours | | `r nrow(Cchar)` | `r nrow(Cprog)`
Treatments| Vehicle | `r length(which(Cdata$Treatment=="Vehicle"))`| `r length(which(Cprog$Treatment=="Vehicle"))`
- | Untreated  | `r length(which(Cchar$Treatment=="Untreated"))`|
-| LY | | `r length(which(Cprog$Treatment=="LY"))`
-| PDL1| | `r length(which(Cprog$Treatment=="PDL1"))`
-| PDL1+LY| | `r length(which(Cprog$Treatment=="PDL1+LY"))`
- | NA | `r length(which(is.na(Cchar$Treatment)))` |`r length(which(is.na(Cprog$Treatment)))`
Histology |  diff. adenocarcinomas | `r length(which(Cchar$Tumor.Histology=="well differentiated mammary solid adenocarcinoma"))`|`r length(which(Cprog$Tumor.Histology=="well differentiated mammary solid adenocarcinoma"))`
- | mucinous carcinoma | `r length(which(Cchar$Tumor.Histology=="mucinous carcinoma"))`|`r length(which(Cprog$Tumor.Histology=="mucinous carcinoma"))`
- | Fibroadenoma | `r length(which(Cchar$Tumor.Histology=="fibroadenoma"))`|`r length(which(Cprog$Tumor.Histology=="fibroadenoma"))`
- | NA |`r length(which(is.na(Cchar$Tumor.Histology)))` | `r length(which(is.na(Cprog$Tumor.Histology)))`
Age Injection | 32-36 | `r length(which(Cchar$Age.at.injection=="32-36")) `|`r length(which(Cprog$Age.at.injection=="32-36")) `
 - | 35 | `r length(which(Cchar$Age.at.injection=="35")) ` | `r length(which(Cprog$Age.at.injection=="35")) `
  - | 49 | `r length(which(Cchar$Age.at.injection=="49")) `|`r length(which(Cprog$Age.at.injection=="49")) `
 - | NA | `r length(which(is.na(Cchar$Age.at.injection))) `|`r length(which(is.na(Cprog$Age.at.injection))) `
Time (days) | NMU 2 Sac| `r round(mean(Cchar$Time.NMU2Sac, na.rm=T),2) ` (`r quantile(Cchar$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`) | `r round(mean(Cprog$Time.NMU2Sac, na.rm=T), 2) ` (`r quantile(Cprog$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.NMU2Sac)))` | `r length(which(is.na(Cprog$Time.NMU2Sac)))` 
 - | NMU 2 Tumor | | `r round(mean(Cprog$Time.NMU2Tumor, na.rm=T), 2)` (`r  quantile(Cprog$Time.NMU2Tumor, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.NMU2Tumor)))` | `r length(which(is.na(Cprog$Time.NMU2Tumor)))` 
 - | Tum Spec Surv|  | `r round(mean(Cprog$Time.Tumor2Sac, na.rm=T),2)` (`r quantile(Cprog$Time.Tumor2Sac, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.Tumor2Sac)))` | `r length(which(is.na(Cprog$Time.Tumor2Sac)))`
Growth Rate/Size (mm) | overall size @ sac | `r round(mean(Cchar$Tumor.dia..sac..mm.,na.rm=T), 2)`  (`r quantile(Cchar$Tumor.dia..sac..mm., c(0.1,  0.9), na.rm=T)`) | `r round(mean(Cprog$Tumor.dia..sac..mm.,na.rm=T), 2)` (`r quantile(Cprog$Tumor.dia..sac..mm., c(0.1, 0.9), na.rm=T)`)
- | Growing No. | | `r length(grep("growing", Cprog$Growth2))`
- | Growing size @ sac |  |  `r round(mean(Cprog$Tumor.dia..sac..mm.[grep("growing", Cprog$Growth2)]),2)` `r quantile(Cprog$Tumor.dia..sac..mm.[grep("growing", Cprog$Growth2)], c(0.1, 0.5, 0.9), na.rm=T)`
- | Stable ||`r length(grep("stable", Cprog$Growth2))`
- | Stable size @ sac | | `r round(mean(Cprog$Tumor.dia..sac..mm.[grep("stable", Cprog$Growth2)]),2)` (`r quantile(Cprog$Tumor.dia..sac..mm.[grep("stable", Cprog$Growth2)], c(0.1, 0.5, 0.9), na.rm=T)`)
- | NA |`r length(which(is.na(Cchar$Growth2)))` | `r length(which(is.na(Cprog$Growth2)))`
Spatial Pattern| | |
- | Infiltrating| `r length(which(Cchar$InfiltratingVsRestricted=="Infiltrating"))` |  `r length(which(Cprog$InfiltratingVsRestricted=="Infiltrating"))`
- | Restricted |  `r length(which(Cchar$InfiltratingVsRestricted=="restricted"))` |  `r length(which(Cprog$InfiltratingVsRestricted=="restricted"))`
- | NA| `r length(which(is.na(Cchar$InfiltratingVsRestricted)))` |  `r length(which(is.na(Cprog$InfiltratingVsRestricted)))`
RNA samples | any fraction | `r length(which(!is.na(Cchar$RNA.seqSampleID)))`| `r length(which(!is.na(Cprog$RNA.seqSampleID)))`
- | Ep|`r length(which(!is.na(Cchar$FqFile.Ep)))`|`r length(which(!is.na(Cprog$FqFile.Ep)))`
- | DN|`r length(which(!is.na(Cchar$FqFile.DN)))`|`r length(which(!is.na(Cprog$FqFile.DN)))`
- | CD45| `r length(which(!is.na(Cchar$FqFile.CD45)))`| `r length(which(!is.na(Cprog$FqFile.CD45)))`
Imaging Data | No tumors | | `r length(which(!is.na(Cprog$Image.Name)))`
- | No tumors with RNA | |`r length(which(!is.na(Cprog$Image.Name)& !is.na(Cprog$RNA.seqSampleID)))`
FACS data| Comprehensive|  | `r length(which(colnames(Fdata)%in%gsub("_", "", Cprog$TumorID)))`
- | EpCAM/CD45 | `r length(which(!is.na(Cchar$X..CD45..by.FACS.)))` |  `r length(which(!is.na(Cprog$X..CD45..by.FACS.)))` 

<span style="color:red">
TO INCLUDE: 
- trichrome data?
</span>

### Summary of the RNA data

Below is a table of the samples with RNA information

```{r}
CRchar=Cchar[which(Cchar$AnyRNAdata=="yes"), ]
CRprog=Cprog[which(Cprog$AnyRNAdata=="yes"), ]
```

Feature | Levels | Characterisation | Progression
--------|---------|-------- |------
RNA samples | any fraction | `r length(which(!is.na(CRchar$RNA.seqSampleID)))`| `r length(which(!is.na(CRprog$RNA.seqSampleID)))`
- | Ep|`r length(which(!is.na(CRchar$FqFile.Ep)))`|`r length(which(!is.na(CRprog$FqFile.Ep)))`
- | DN|`r length(which(!is.na(CRchar$FqFile.DN)))`|`r length(which(!is.na(CRprog$FqFile.DN)))`
- | CD45| `r length(which(!is.na(CRchar$FqFile.CD45)))`| `r length(which(!is.na(CRprog$FqFile.CD45)))`
Treatments Char/Prev  | Vehicle | `r length(which(CRchar$Treatment=="Vehicle"))`| `r length(which(CRprog$Treatment=="Vehicle"))`
- | Untreat (char) | `r length(which(CRchar$Treatment=="Untreated"))` |
-| LY | | `r length(which(CRprog$Treatment=="LY"))`
-| PDL1| | `r length(which(CRprog$Treatment=="PDL1"))`
-| PDL1+LY| | `r length(which(CRprog$Treatment=="PDL1+LY"))`
- | NA | `r length(which(is.na(CRchar$Treatment) ))` |`r length(which(is.na(CRprog$Treatment)))`
Time | NMU 2 Sac| `r round(mean(CRchar$Time.NMU2Sac, na.rm=T),2) ` (`r quantile(CRchar$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`) | `r round(mean(CRprog$Time.NMU2Sac, na.rm=T), 2) ` (`r quantile(CRprog$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`)
Growth Rate/Size (mm) | overall size @ sac | `r round(mean(CRchar$Tumor.dia..sac..mm.,na.rm=T), 2)`  (`r quantile(CRchar$Tumor.dia..sac..mm., c(0.1,  0.9), na.rm=T)`) | `r round(mean(CRprog$Tumor.dia..sac..mm.,na.rm=T), 2)` (`r quantile(CRprog$Tumor.dia..sac..mm., c(0.1, 0.9), na.rm=T)`)
- | Growing No. | | `r length(grep("growing", CRprog$Growth2))`
- | Growing size @ sac |  |  `r round(mean(CRprog$Tumor.dia..sac..mm.[grep("growing", CRprog$Growth2)]),2)` `r quantile(CRprog$Tumor.dia..sac..mm.[grep("growing", CRprog$Growth2)], c(0.1, 0.5, 0.9), na.rm=T)`
- | Stable ||`r length(grep("stable", CRprog$Growth2))`
- | Stable size @ sac | | `r round(mean(CRprog$Tumor.dia..sac..mm.[grep("stable", CRprog$Growth2)]),2)` (`r quantile(CRprog$Tumor.dia..sac..mm.[grep("stable", CRprog$Growth2)], c(0.1, 0.5, 0.9), na.rm=T)`)
- | NA |`r length(which(is.na(CRchar$Growth2)))` | `r length(which(is.na(CRprog$Growth2)))`
Growth and Treatment: comparing small/stable vs large/growing | | 
Vehicle | N s/l |  | `r length(which(CRprog$Treatment=="Vehicle" & CRprog$Growth2=="stable"))`, `r length(which(CRprog$Treatment=="Vehicle" & CRprog$Growth2=="growing"))`
LY | N s/l |  | `r length(which(CRprog$Treatment=="LY" & CRprog$Growth2=="stable"))`, `r length(which(CRprog$Treatment=="LY" & CRprog$Growth2=="growing"))`
PDL1 and Treatment | N s/l |  | `r length(which(CRprog$Treatment=="PDL1" & CRprog$Growth2=="stable"))`, `r length(which(CRprog$Treatment=="PDL1" & CRprog$Growth2=="growing"))`
PDL1+LY | N s/l |  | `r length(which(CRprog$Treatment=="PDL1+LY" & CRprog$Growth2=="stable"))`, `r length(which(CRprog$Treatment=="PDL1+LY" & CRprog$Growth2=="growing"))`



<!--chapter:end:01b-cohortSummary.Rmd-->


# Whole-slide imaging


```{r, eval=F}
# Delete this part when finished

library(ggplot2)
library(reshape2)
library(gplots)
library(RColorBrewer)
library(spatstat)
source("rscript/PvalueHeatMap.R")
```


In this section, we will be looking at the composition and spatial distribution of cells in whole slide images. These sections have previously been assessed using an  <span style="color:red">external script. Save this somewhere </span>

The following markers have been used:

* EpCAM (tumor cells)
* SMA (fibroblasts or myeopithelial cells)
* CD8 (T cells)

Note that in some images a double positive EpCAM+/SMA+ population exists. Some CD8 cells have Epcam+ or SMA+ staining, however, we consider all of these to be simply CD8+


```{r load-wsi}
WSIpath="../data/WSI-data/locationData/"
WSIfiles=dir(WSIpath, "*.csv")
WSIsummary=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIsummary)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

## knn data
WSIpath="../data/WSI-data/knn-values/"
WSIfiles=dir(WSIpath, "*.csv")
WSIknn=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIknn)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

## knn data
WSIpath="../data/WSI-data/interactingFraction/"
WSIfiles=dir(WSIpath, "*.csv")
WSIIF=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
WSIIF=lapply(WSIIF, function(x) {colnames(x)<-c("RN","Grid", "NearestNeighbor", "IF", "Reference"); x})
names(WSIIF)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

# MH data
WSIpath="../data/WSI-data/mh-values/"
WSIfiles=dir(WSIpath, "*.csv")
WSIMH=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIMH)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

# MH set-up summary
WSIpath="../data/WSI-data/MHset-upSummary/"
WSIfiles=dir(WSIpath, "*.csv")
WSIMHsetup=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIMHsetup)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

save(WSIsummary, WSIknn, WSIIF, WSIMH, WSIMHsetup, file=sprintf("outputs/WSI_raw_data%s.RData", Sys.Date()))
```

## Associate the frequencies with other data types

Note there are 47 samples with imaging data. 33 of these samples have FACS data, manual counts and TIMER scores

Correlate the following information:

 * "CD8.WSI": CD8 total counts 
 * "CD8Frac.WSI": CD8 fraction (normalised by cell count)
 * "CD8_EPorSMARatio.WSI": CD8/EP+SMA ratio (any EpCAM or SMA + cell)
 * "CD8_AnySMARatio.WSI": CD8/Any EPcam+ cell
 * "CD8_EPRatio.WSI": CD8 to EpCAM+SMA- ratio
 * "CD8normTumSize": normalised CD8 counts per mm of tumor size at sac
 * "CD8.EpBoundingBox": approx area per CD8 cell (density)

<span style="color:red">
UPDATE THE CIBERSORT INFORMATION. </span>

Below are heatmaps which show the correlation between two variables (red is correlated and blue is anti-correlated), and the p.value is indicated in the middle of the square.

It appears that CD8 whole-slide imaging associates well with:

* FACS data (both CD8 and CD45)
* Manual scoring (Fig 4) of CD8 cells
* Some CD8 gene signature scores (mainly in EPC, TIMER)

```{r}
SummaryData=read.csv("../metadata/new_SummaryData.csv", row.names = 1)

## CD summary
NAidx=sapply(1:ncol(SummaryData), function(x) length(which(!is.na(SummaryData[, x]))))
names(NAidx)=colnames(SummaryData)

colTestCD8=c("CD8.EpBoundingBox", "CD8.TumSize", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", "T.cell.CD8._TIMER", "T.cell.CD8._CIBERSORT","T.cell.CD8._CIBERSORT.ABS", "T.cell.CD8._EPIC")

# colTestCD8=c("CD8.EpDomTiles","CD8.EpBoundingBox", "CD8.TumSize", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", )
indx1=c("CD8.WSI", "CD8Frac.WSI", "CD8_EPorSMARatio.WSI","CD8_AnySMARatio.WSI", "CD8_EPRatio.WSI","CD8normTumSize", "CD8.EpBoundingBox", "log2CD8_EPorSMARatio.WSI", "log2CD8_EPRatio.WSI")

CDsummary=matrix(NA, nrow=length(indx1), ncol=length(colTestCD8))
rownames(CDsummary)=paste(indx1, " N=", NAidx[match(indx1, names(NAidx))], sep="")
colnames(CDsummary)=paste(colTestCD8, " N=", NAidx[match(colTestCD8, names(NAidx))], sep="")
CDsummaryP=CDsummary
for (i in 1:length(indx1)){
  CDsummary[i, ]=sapply(colTestCD8, function(x) cor(SummaryData[, indx1[i]], SummaryData[,x], use="complete"))
  CDsummaryP[i, ]=sapply(colTestCD8, function(x) cor.test(SummaryData[, indx1[i]], SummaryData[,x], use="complete")$p.value)
}

## Do the same with EPCAM/FACS data

colTestFACS=grep("FACS", colnames(SummaryData), value = T)
colTestWSI=grep("WSI", colnames(SummaryData), value = T)
FACSsummary=matrix(NA, nrow=length(colTestFACS), ncol=length(colTestWSI))
rownames(FACSsummary)=paste(colTestFACS, " N=", NAidx[match(colTestFACS, names(NAidx))], sep="")
colnames(FACSsummary)=paste(colTestWSI, " N=", NAidx[match(colTestWSI, names(NAidx))], sep="")
FACSsummaryP=FACSsummary


for (i in 1:length(colTestFACS)){
  FACSsummary[i, ]=sapply(colTestWSI, function(x) cor(SummaryData[, colTestFACS[i]], SummaryData[,x], use="complete"))
  FACSsummaryP[i, ]=sapply(colTestWSI, function(x) cor.test(SummaryData[, colTestFACS[i]], SummaryData[,x], use="complete")$p.value)
}

#pdf(sprintf("rslt/WSI-analysis/WSI_vs_FACS_correlationCoeff_w_pvalues_%s.pdf", Sys.Date()), height=8, width=7)
PvalHM(CDsummary, round(CDsummaryP,2), "CD8 WSI correlation with Pvalues")
PvalHM(FACSsummary, round(FACSsummaryP, 2), "WSI vs FACS w Pvalues")
#devoff()

#write.csv(SummaryData, file="metadata/new_SummaryData.csv")
```

## Cellular composition

```{r, cache=T}
WSIvals=sapply(WSIsummary, function(x) table(factor(x$Class2, levels=c("CD8", "EpCAM", "EpCAM: SMA", "SMA", "Unclass"))))
WSIvalFracs=t(t(WSIvals)/colSums(WSIvals))

lxmatch=match(colnames(WSIvalFracs), gsub("_", "", Cdata$TumorID))

Cdata$CD8Fraction=NA
Cdata$CD8Fraction[na.omit(lxmatch)]=WSIvalFracs[1, ]

Cdata$EpCAMFraction=NA
Cdata$EpCAMFraction[na.omit(lxmatch)]=WSIvalFracs[2, ]

Cdata$DPFraction=NA
Cdata$DPFraction[na.omit(lxmatch)]=WSIvalFracs[3, ]

Cdata$SMAFraction=NA
Cdata$SMAFraction[na.omit(lxmatch)]=WSIvalFracs[4, ]

Cdata$UnclassFraction=NA
Cdata$UnclassFraction[na.omit(lxmatch)]=WSIvalFracs[5, ]

```

Here, we look at the raw distributions of the different cell types and see if there are associations with:

* tumor size
* growth rate
* growth rate (categorical)
* treatment
* stromal restricted or infiltrating 

Below are the total cell counts:

```{r, fig.height=4}
WSIvals=WSIvals[ , order(WSIvals[1, ])]
ordV=colnames(WSIvals)

WSIvalFracs=WSIvalFracs[ , order(WSIvalFracs[1, ])]
ordV2=colnames(WSIvalFracs)


## match with meta data
# get the sample Names
CdataTID=gsub("_", "", Cdata$TumorID)
l1=match(colnames(WSIvals), CdataTID)

Treat=Cdata$Treatment[l1]
Growth=Cdata$Growth2[l1]
WSImelt=melt(WSIvals)
WSImelt$Var2=factor(WSImelt$Var2, levels=ordV)
WSImelt$treatment=Treat[match(WSImelt$Var2, colnames(WSIvals))]
WSImelt$growth=Growth[match(WSImelt$Var2, colnames(WSIvals))]

l2=match(colnames(WSIvalFracs), CdataTID)
Treat=factor(Cdata$Treatment[l2])
Growth=Cdata$Growth2[l2]
WSIfracMelt=melt(WSIvalFracs)
WSIfracMelt$Var2=factor(WSIfracMelt$Var2, levels=ordV2)
WSIfracMelt$treatment=Treat[match(WSIfracMelt$Var2, colnames(WSIvalFracs))]
WSIfracMelt$growth=Growth[match(WSIfracMelt$Var2, colnames(WSIvalFracs))]


#pdf(sprintf("rslt/WSI-analysis/summary_distributions_norm_cell_count_%s.pdf", Sys.Date()), width=9, height=5)
ggplot(WSImelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")
ggplot(WSImelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by treatment")
ggplot(WSImelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by growth")
```

Here, the same data is shown and normalised according to total cell count:

```{r, fig.hright=5}
ggplot(WSIfracMelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")
ggplot(WSIfracMelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by treatment")
ggplot(WSIfracMelt, aes(x=Var2, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by growth")
#devoff()
```

## Associate composition with other covariates

We can collapse the above data into boxplots to see if there is an association with treatments, performed using non-parametric wilcoxon test. 

Compared to the vehicle, LY treated samples have a lower "stromal" fraction (unclassed DAPI+ cells) and PDL1 treated samples are more likely to have a EpCAM+SMA+ double positive fraction

```{r, warning=F, message=F}
## boxplots here for each cell type stratified by treatment or growth
tsamples=colnames(Cdata)[grep("Fraction", colnames(Cdata))]
#pdf(sprintf("rslt/WSI-analysis/cell-distribution-by-treatment-or-growth_norm_cell_count_%s.pdf", Sys.Date()), width=12, height=8)

par(mfrow=c(2,3))
for (i in tsamples){
  t1=sapply(levels(Treat)[1:3], function(x) wilcox.test(Cdata[Cdata$Treatment==x, i], Cdata[Cdata$Treatment=="Vehicle", i])$p.value)
  boxplot(Cdata[, i]~Cdata$Treatment, main=sprintf("Treatment: %s", i), xlab="", ylab=i)
  legend("topleft", paste(levels(Treat)[1:3], round(t1, 2)))
}
```

When comparing these fractions to growth, there is no association:

```{r, warning='hide'}
par(mfrow=c(2,3))
for (i in tsamples){
  t1=wilcox.test(Cdata[Cdata$Growth2=="growing", i], Cdata[Cdata$Growth2=="stable", i])$p.value
  boxplot(Cdata[, i]~Cdata$Growth2, main=sprintf("Growth: %s p=%s",i, round(t1,2)), xlab="", ylab=i)
# legend("topleft", paste(levels(Cdata$Growth2), round(t1, 2)))
}
```

Nor is there any association with whether a sample is "immune infiltrated" or not (by manual inspection)

```{r, warning='hide'}
par(mfrow=c(2,3))
for (i in tsamples){
  t1=wilcox.test(Cdata[Cdata$InfiltratingVsRestricted=="Infiltrating", i], Cdata[Cdata$InfiltratingVsRestricted=="restricted", i])$p.value
  boxplot(Cdata[, i]~Cdata$InfiltratingVsRestricted, main=sprintf("inf/rest: %s p=%s",i, round(t1,2)), xlab="", ylab=i)
# legend("topleft", paste(levels(Cdata$Growth2), round(t1, 2)))
}
```

We can also use linear regression models to assess:

* correlation between growth rate and cell fractions (no associations)
* correlation between final tumor size and cell fractions (no association)

```{r}

par(mfrow=c(2,3))
for (i in tsamples){
  a1=cor.test(Cdata[ ,i],Cdata$Tumor.dia..sac..mm./Cdata$Time.NMU2Sac, use="complete")
  #a1=cor.test(WSIvals[i, ],TumSizeNorm)
  plot( Cdata$Tumor.dia..sac..mm./Cdata$Time.NMU2Sac, Cdata[ ,i],xlab="growth rate", ylab=i, main=sprintf("rho=%s, p=%s, %s",round(a1$estimate,2), round(a1$p.value,2), i))
}


par(mfrow=c(2,3))
for (i in tsamples){
  a1=cor.test(Cdata[ ,i],Cdata$Tumor.dia..sac..mm., use="complete")
  #a1=cor.test(WSIvals[i, ],TumSizeNorm)
  plot( Cdata$Tumor.dia..sac..mm.,Cdata[ ,i], xlab="tumor size @ sac", ylab=i, main=sprintf("rho=%s, p=%s, %s",round(a1$estimate,2), round(a1$p.value,2), i))
}

#devoff()

```

## Estimate tumor size

Using WSI data, we can estimate a tumor size for each tissue sample and compare to the final tumor sizes. This will be based on the distribution of EpCAM+ cells.
This estimate is also used to normalise CD8 counts earlier on.

```{r}
#estimate the tumor areas
Tarea=lapply(WSIsummary, function(x) ripras(x$Centroid.X.µm[x$Class2=="EpCAM"], x$Centroid.Y.µm[x$Class2=="EpCAM"], "convex"))
TareaSum=sapply(Tarea, area)

# Tumor diameter
Tdiameter=Cdata$Tumor.dia..sac..mm.[match(colnames(WSIvals), gsub("_", "", Cdata$TumorID))]

#par(mfrow=c(1,2))
#plot(TareaSum, WSIvals[2, ], ylab="EpCAM cell count", xlab="Epcam cells bounding area")
plot(TareaSum, Tdiameter, ylab="Tumor Diameter", xlab="Epcam cells bounding area")

cor.test(TareaSum, Tdiameter, use="complete")

## append to Cdata
Cdata$TumorAreaWSI=NA
lxmatch=match(colnames(WSIvalFracs), gsub("_", "", Cdata$TumorID)) # probably don't need this
Cdata$TumorAreaWSI[(lxmatch)]=TareaSum #[-which(is.na(lxmatch))]
## Normalisation strategies:
```


## Correlations between different subpopulations

Look for correlates between different subpopulations: Naturally, we would expect a negative correlation since this should sum to 1. Below are heatmaps showing correlations between different cell types, and significant associations are linearly shown.

Note the following negative correlations:

* epcam and SMA
* SMA+ and Unclass 

```{r}
Ax1=cor(t(WSIvalFracs))

#pdf(sprintf("rslt/WSI-analysis/summary-associations-between-subgroups_%s.pdf", Sys.Date()), height=8, width=8)
par(oma=c(4, 0,0, 4))
heatmap.2(Ax1, col=brewer.pal(9, "RdBu"), trace="none",scale="none")

par(mfrow=c(2,2))

a1=cor.test(WSIvalFracs[2, ], WSIvalFracs[4, ])
plot(WSIvalFracs[2, ], WSIvalFracs[4, ], xlab="Epcam+", ylab="SMA+", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[4, ], WSIvalFracs[5, ])
plot(WSIvalFracs[4, ], WSIvalFracs[5, ], xlab="SMA+", ylab="Unclass", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[3, ], WSIvalFracs[4, ])
plot(WSIvalFracs[3, ], WSIvalFracs[4, ], xlab="Epcam+SMA+", ylab="SMA", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[2, ], WSIvalFracs[5, ])
plot(WSIvalFracs[2, ], WSIvalFracs[5, ], xlab="Epcam+", ylab="nclass", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

#devoff()
# correlations
Ax1

ctest=matrix(NA, nrow=5, ncol=5)
for (i in 1:5){
  ctest[i, ]=sapply(1:5, function(x) cor.test(WSIvalFracs[i, ], WSIvalFracs[x, ])$p.value)
}

ctest
```

## Associations between CD8 counts with other clinical variables

Below we assess whether any of the CD8-variables described in section 3.1 is associated with 

* treatment
* growth
* spatial pattern

```{r}
indx1=c(indx1, "log2CD8_EPorSMARatio.WSI", "log2CD8_EPRatio.WSI")

a1=matrix(NA, ncol=length(indx1), nrow=5)

for (i in 1:length(indx1)){
a1[1, i]=wilcox.test(SummaryData[SummaryData$Growth%in%c("stable", "growing") ,indx1[i] ]~ SummaryData$Growth[SummaryData$Growth%in%c("stable", "growing")])$p.value 
a1[2, i]=wilcox.test(SummaryData[SummaryData$SpatialManual%in%c("Infiltrating", "restricted") ,indx1[i] ]~ SummaryData$SpatialManual[SummaryData$SpatialManual%in%c("Infiltrating", "restricted")])$p.value
a1[3, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("PDL1", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("PDL1", "Vehicle")])$p.value
a1[4, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("PDL1+LY", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("PDL1+LY", "Vehicle")])$p.value
a1[5, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("LY", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("LY", "Vehicle")])$p.value
}

colnames(a1)=indx1
rownames(a1)=c("growth", "spatial", "pdl1", "pdl1+ly", "ly")

par(oma=c(5, 0,0,4))
heatmap.2(-log10(a1), col=brewer.pal(9, "Blues"), trace="none", scale="none")
```

Note that CD8 normalised by tumor size is associated with growth (but this could a reflection of the size of the tumor), and there is a borderline difference once normalised by epithelial content. In addition the CD8 total count is associated with pdl1+ly treatment.

Note that p=0.05 is designated by a value of 1.3


```{r, eval=F}
## save this data to file to generate the summary data file
## Check if the other metrics used correlate with growth status or treatment

#####
# COMMENT OUT IF NOT NEEDED
#####


## add FACS data
# lx=match(rownames(SummaryData), colnames(Fdata))
# SummaryData$CD8.FACS=NA
# SummaryData$CD8.FACS[which(!is.na(lx))]=unlist(t(Fdata[ 6, na.omit(lx)]))
# lx=match(rownames(SummaryData), gsub("_", "", Cdata$TumorID))
# SummaryData$CD45.FACS=Cdata$X..CD45..by.FACS.[lx]
# SummaryData$TumSize=Cdata$Tumor.dia..sac..mm.[lx]
# SummaryData$CD8normTumSize=SummaryData$CD8.WSI/SummaryData$TumSize
# SummaryData$CD8.EpBoundingBox=TareaSum[match(rownames(SummaryData), names(TareaSum))]/SummaryData$CD8.WSI
# SummaryData$Treatment=factor(Cdata$Treatment[lx])
# SummaryData$Growth=Cdata$Growth2[lx]
# SummaryData$SpatialManual=Cdata$InfiltratingVsRestricted[lx]
# SummaryData$log2CD8_EPorSMARatio.WSI=log2(SummaryData$CD8_EPorSMARatio.WSI+0.001)
# SummaryData$log2CD8_EPRatio.WSI=log2(SummaryData$CD8_EPRatio.WSI+0.001)

#####
# END COMMENT section
#####

indx1=c(indx1, "log2CD8_EPorSMARatio.WSI", "log2CD8_EPRatio.WSI")

#pdf(sprintf("rslt/WSI-analysis/WSI_CD8_metrics_vs_growth_%s.pdf", Sys.Date()), height=8, width=8)
for (i in 1:length(indx1)){
  a1=wilcox.test(SummaryData[SummaryData$Growth%in%c("stable", "growing") ,indx1[i] ]~ SummaryData$Growth[SummaryData$Growth%in%c("stable", "growing")])
p<-ggplot(SummaryData, aes_string(y=(indx1[i]), x="Growth"))+geom_boxplot(outlier.shape=NA)+geom_jitter(position=position_jitter(width=.1, height=0))+ggtitle(paste(indx1[i], " stab vs grow p=", round(a1$p.value,2),sep=""))
print(p)
}
#devoff()

#pdf(sprintf("rslt/WSI-analysis/WSI_CD8_metrics_vs_treatment_%s.pdf", Sys.Date()), height=8, width=8)
for (i in 1:length(indx1)){
a1=wilcox.test(SummaryData[SummaryData$Treatment%in%c("Vehicle", "PDL1"),indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("Vehicle", "PDL1")])
a2=wilcox.test(SummaryData[SummaryData$Treatment%in%c("Vehicle", "LY"),indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("Vehicle", "LY")])
a3=wilcox.test(SummaryData[SummaryData$Treatment%in%c("Vehicle", "PDL1+LY"),indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("Vehicle", "PDL1+LY")])
p<-ggplot(SummaryData, aes_string(y=(indx1[i]), x="Treatment"))+geom_boxplot(outlier.shape=NA)+geom_jitter(position=position_jitter(width=.1, height=0))+ggtitle(paste(indx1[i], " PDL1p=", round(a1$p.value,2), " LYp=", round(a2$p.value,2), " P+Lp=", round(a3$p.value,2), sep=""))
print(p)
}
#devoff()
```



<!--chapter:end:02-wsi.Rmd-->

# Spatial statistics

Below, we use three different metrics to compare spatial distributions:

* k-nearest neighbour distances
* the interacting fraction
* morisita-horn distances

These are compared to manual inspection of the result

## knn-Distances:

```{r}
#load("outputs/WSI_raw_data2020-11-05.RData")
```
The k-nearest neighbour distances looks at the average distance from a given cell type of class A to a cell type of class B. In this section, the reference class A is the CD8 T cell, and we will look at the mean distance to SMA, Epcam, double positive and unclassified cells in each image.

To account for potential fluctuations due to misclassified cells, or isolated single cells, k values of 1, 3, 5 will be used. I.e. for each cell, we will compute the mean distance from each Cd8Tcell to its 1, 3, and 5 nearest neighbours.

### Comparison to manual classification, treatment, growth

Overall, we see that the differences in infiltrating vs restricted are similar. We see statistical differences (using anova followed by Tukey's test) between: 

* epcam and SMA-epcam in both cases (higher distances to EpCAM on average)
* SMA-Epcam to SMA (CD8s are closer to SMA+)
* Unclass to Epcam-SMA (CD8s closer to unclass)

In the infiltrating case: 

* Unclass to Epcam (CD8s closer to unclass, borderline significant)

In the restricted cases, we see:

* Unclass to SMA (higher distance to unclass in the restricted case)
* SMA to epcam (CD8s are closer to the SMA)

This last result is consistent with what we expect for a CD8+ cell which is stroma-restricted.

```{r, fig.height=5}
knnMelt=melt(WSIknn, measure.vars=c("KS.pval"))

knnTemp1=knnMelt[knnMelt$CellType=="CD8" & knnMelt$NearestCellType%in%c("EpCAM", "SMA", "EpCAM: SMA", "Unclass"), ]
knnTemp1$SpatialManual=Cdata$InfiltratingVsRestricted[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

# compute p values?
ptest=sapply(levels(knnTemp1$knn), function(x) wilcox.test(knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="EpCAM" & knnTemp1$SpatialManual=="Infiltrating")], knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="SMA" & knnTemp1$SpatialManual=="Infiltrating")])$p.value)

fit1=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
#summary(fit1)
fit2=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])
#summary(fit2)

fit1b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
#summary(fit1b)
fit2b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])
#summary(fit2b)

#pdf(sprintf("rslt/WSI-analysis/knn_distances_vs_manualspatial_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=SpatialManual))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=SpatialManual))+facet_grid(~knn+SpatialManual)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#377eb8"),na.value="black")+ggtitle("CD8-CelltypeX spatial distributions: mean values")

print(p)
par(mfrow=c(1,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1, "NearestCellType"), las=2)
title("Infiltrating Mean Distance from CD8", line=3.3)
plot(TukeyHSD(fit2, "NearestCellType"), las=2)
title("Restricted Mean Distance from CD8", line=3.3)

# p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MedianDistance, fill=SpatialManual))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=SpatialManual))+facet_grid(~knn+SpatialManual)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#377eb8"),na.value="black")+ggtitle("CD8-CelltypeX spatial distributions: median values")
# print(p)
# 
# par(mfrow=c(1,2), oma=c(0, 0, 2, 0))
# plot(TukeyHSD(fit1b, "NearestCellType"), las=2)
# title("Infiltrating Median Distance from CD8", line=3.3)
# plot(TukeyHSD(fit2b, "NearestCellType"), las=2)
# title("Restricted Median Distance from CD8", line=3.3)

#devoff()

```

### Associations with outcome

We can also see if there is an association between these distances with growth and treatment

Treatment:

* CD8 cells in PDL1 sample are further away to SMA+ cells and EpCAM+   (compared to vehicle or double agent)
* CD8 cells in LY treated samples are further away from unclassified cells  (compared to any of the other treatments)

```{r}

knnTemp1$Treatment=Cdata$Treatment[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM", ])
fit2=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="SMA", ])
fit3=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA", ])
fit4=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="Unclass", ])

knnTemp1$Growth=Cdata$Growth2[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM", ])
fit2b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="SMA", ])
fit3b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA", ])
fit4b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="Unclass", ])

#pdf(sprintf("rslt/WSI-analysis/knn_distances_vs_treatment_growth_%s.pdf", Sys.Date()), height=7, width=12)

# p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=Treatment))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Treatment))+facet_grid(~knn+Treatment)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#4daf4a","#377eb8",  "#984ea3"),na.value="black")
# print(p)
p<-ggplot(knnTemp1, aes(fill=Treatment, y=MeanDistance, x=Treatment))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Treatment))+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#4daf4a","#377eb8",  "#984ea3"),na.value="black")
print(p)
par(mfrow=c(2,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1, "Treatment"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2, "Treatment"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3, "Treatment"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit4, "Treatment"), las=2)
title("Unclass Distance", line=3.3)
```

### Growth

All 95% confidence lines cross 0, but it appears that stable cases have a closer unclass-CD8 interaction distance compared to growing.

```{r}
# p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=Growth))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Growth))+facet_grid(~knn+Growth)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c","#ff7f00", "#4daf4a","#377eb8",  "#984ea3", "purple"),na.value="black")
# print(p)
p<-ggplot(knnTemp1, aes(fill=Growth, y=MeanDistance, x=Growth))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Growth))+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c","#ff7f00", "#4daf4a","#377eb8",  "#984ea3", "purple"),na.value="black")
print(p)
par(mfrow=c(2,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1b, "Growth"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2b, "Growth"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3b, "Growth"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit4b, "Growth"), las=2)
title("Unclass Distance", line=3.3)

#devoff()

```


Based on the above distributions, knn1, knn3, and knn5 analyses give similar results. In the following section, we will make comparisons using knn3 results.

### Association between distance and content

The spatial differences could be influenced by CD8 content. Here, we test if the distances from CD8Tcells to celltype B could be influenced by this. 

We see that there is a correlation between CD8 fraction and the SMA proportion (both SMA and double positive).
But we don't see an association with epcam+ cells or unclassified stromal cells


```{r, fig.height=6}
A1=knnTemp1[knnTemp1$knn=="knn3" & knnTemp1$CellType=="CD8",  ]
A1$CD8frac=WSIvalFracs[1, match(A1$L1, colnames(WSIvals))]

#pdf(sprintf("rslt/WSI-analysis/check_knn3-averageDistance_association_withCD8fraction_%s.pdf", Sys.Date()), height=8, width=8)
par(mfrow=c(2,2))
for (i in unique(A1$NearestCellType)){
a1=cor.test(A1$MeanDistance[A1$NearestCellType==i], A1$CD8frac[A1$NearestCellType==i], use="complete")
plot(A1$MeanDistance[A1$NearestCellType==i], A1$CD8frac[A1$NearestCellType==i], xlab="3nn mean distance", ylab="CD8 fraction", main=sprintf("%s, cor=%s p=%s", i, round(a1$estimate,2), round(a1$p.value,2)), log="x")
}

```

CD8-Epcam distances are looked at in greater detail below. Here, we look at whether there is an association with CD8 fraction in a growing and stable tumors.

In growing or spatially restricted tumors, there is an association between the CD8-epcam distances with the CD8 fraction, but not in infiltrating or stable tumours.

```{r, fig.height=4}
knnTempSumm=knnTemp1[which(knnTemp1$knn=="knn3"), ]
knnreshape=acast(knnTempSumm[ ,c("NearestCellType", "MeanDistance", "L1")], L1~NearestCellType, value.var="MeanDistance" )
knnreshape=data.frame(knnreshape)

knnreshape$EpMIN=ifelse(knnreshape$EpCAM..SMA<knnreshape$EpCAM, knnreshape$EpCAM..SMA, knnreshape$EpCAM)
knnreshape$EpMIN[which(is.na(knnreshape$EpMIN))]=knnreshape$EpCAM[which(is.na(knnreshape$EpMIN))]
knnreshape$EpStrRatio1=knnreshape$EpCAM/rowSums(knnreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
knnreshape$EpStrRatio2=knnreshape$EpCAM/(knnreshape$SMA)
knnreshape$EpStrRatio3=rowSums(knnreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(knnreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
knnreshape$EpStrRatio4=rowSums(knnreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(knnreshape$SMA)
knnreshape$Treatment=factor(knnTempSumm$Treatment[match(rownames(knnreshape), knnTempSumm$L1)])
knnreshape$Growth=factor(knnTempSumm$Growth[match(rownames(knnreshape), knnTempSumm$L1)])
knnreshape$Infil=factor(knnTempSumm$SpatialManual[match(rownames(knnreshape), knnTempSumm$L1)])
knnreshape$CD8frac=SummaryData$CD8Frac.WSI[match(rownames(knnreshape), rownames(SummaryData))]


par(mfrow=c(1,2))
a1x=cor.test(knnreshape$CD8frac[knnreshape$Infil=="Infiltrating"], knnreshape$EpCAM[knnreshape$Infil=="Infiltrating"])
a1y=cor.test(knnreshape$CD8frac[knnreshape$Infil=="restricted"], knnreshape$EpCAM[knnreshape$Infil=="restricted"])
plot(knnreshape$CD8frac, knnreshape$EpCAM, col=knnreshape$Infil, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM knn3", main="spatial scoring")
legend("topright", c(paste("infil p=", round(a1x$p.value,2)), paste("restrict p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))

a1x=cor.test(knnreshape$CD8frac[knnreshape$Growth=="growing"], knnreshape$EpCAM[knnreshape$Growth=="growing"])
a1y=cor.test(knnreshape$CD8frac[knnreshape$Growth=="stable"], knnreshape$EpCAM[knnreshape$Growth=="stable"])

plot(knnreshape$CD8frac, knnreshape$EpCAM, col=knnreshape$Growth, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM knn3", main="tumor growth")
legend("topright", c(paste("growing p=", round(a1x$p.value,2)), paste("stable p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))
```

Do any of the below metrics correlate with manual scoring:

* We can assess the distances from CD8 cells which come automatically: 
    * Ep-distance
    * SMA distance 
    * Ep:SMA distance
    * SMA distance.
* EpMIN: distance to any Epcam expressing cell (includes EP+SMA+)
* Ratios between Epcam and SMA: There are different values depending on whether the double positive fraction is used or not
    * (Ratio 1): Ep/any SMA
    * (Ratio 2): EP/SMA
    * (Ratio 3): Any Ep / Any SMA
    * (Ratio 4): Any Ep/ SMA
    
Whilst the manual scorings associate strongly with CD8-EPcam distances, there is no association with any other cell type.

```{r, fig.height=7}

#pdf(sprintf("rslt/WSI-analysis/knn_metrics_to_manualScoring_%s.pdf", Sys.Date()), height=12, width=12)
par(mfrow=c(3,3))
for (i in 1:9){
  a1=wilcox.test(knnreshape[ ,i]~knnreshape$Infil)
  boxplot(knnreshape[ ,i]~knnreshape$Infil, main=paste(colnames(knnreshape)[i]," p=", round(a1$p.value,2), sep=""), ylab="knn distance" )
}
# dev.off()
```

## The interacting fraction

The interacting fraction uses the knn-distances and determines the proportion of CD8 cells which are within a proximity of r um from celltype B.

### Comparison to manual & select optimal r

Below are plots of the proportion of CD8 cells within an "interacting distance" as we increase r. This looks at both the interacting fraction of CD8 cells with Epcam+ and SMA+ cells. Lines are color coded according to the manual spatial-infiltration annotation. 

We notice from the line plots for each single sample that the restricted samples generally have low interacting fractins with EpCAM and SMA compared to the infiltrating samples. In addition, there is a statistical difference in EpCAM measurements compared to SMA.

```{r, fig.height=4}
IFmelt=melt(WSIIF, measure.vars=c("IF"))

IFmelt$SpatialManual=Cdata$InfiltratingVsRestricted[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
IFmelt$Treatment=Cdata$Treatment[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
IFmelt$Growth=Cdata$Growth2[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
IFmelt$Growth2=IFmelt$Growth
IFmelt$Growth2[grep("no data", IFmelt$Growth2)]="no data"

IFmelt$Dist=(substr(IFmelt$Grid, 6, 7))
IFmelt$knn=substr(IFmelt$Grid, 1, 4)

IFTempSumm=IFmelt[IFmelt$Grid=="knn3-15" & IFmelt$Reference=="CD8", ]
IFreshape=acast(IFTempSumm[ ,c("NearestNeighbor", "value", "L1")], L1~NearestNeighbor, value.var="value" )
IFreshape=data.frame(IFreshape)

IFreshape$EpMIN=ifelse(IFreshape$EpCAM..SMA<IFreshape$EpCAM, IFreshape$EpCAM..SMA, IFreshape$EpCAM)
IFreshape$EpMIN[which(is.na(IFreshape$EpMIN))]=IFreshape$EpCAM[which(is.na(IFreshape$EpMIN))]
IFreshape$EpStrRatio1=IFreshape$EpCAM/rowSums(IFreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
IFreshape$EpStrRatio2=IFreshape$EpCAM/(IFreshape$SMA)
IFreshape$EpStrRatio3=rowSums(IFreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(IFreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
IFreshape$EpStrRatio4=rowSums(IFreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(IFreshape$SMA)


IFreshape$Treatment=factor(IFTempSumm$Treatment[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$Growth=factor(IFTempSumm$Growth[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$Infil=factor(IFTempSumm$SpatialManual[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$CD8frac=SummaryData$CD8Frac.WSI[match(rownames(IFreshape), rownames(SummaryData))]
IFreshape$TumSize=SummaryData$TumSize[match(rownames(IFreshape), rownames(SummaryData))]

####
# line plots to see the best separation between infiltrating and restricted
###

#pdf(sprintf("rslt/WSI-analysis/interacting_fraction_compared_manual_%s.pdf", Sys.Date()), height=8, width=14)

IFmelt2=IFmelt[IFmelt$NearestNeighbor=="EpCAM" & IFmelt$Reference=="CD8" , ]
IFmelt2$label=IFmelt2$L1
IFmelt2$label[which(IFmelt2$Dist!=30)]=NA
p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, group=L1, label=label))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM interacting fraction: spatial manual")+geom_label()
print(p)

#IFmelt2$Dist=as.numeric(IFmelt2$Dist)

p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-EpCAM knn3")+stat_smooth()
print(p)

IFmelt2=IFmelt[IFmelt$NearestNeighbor=="SMA" & IFmelt$Reference=="CD8" , ]
IFmelt2$label=IFmelt2$L1
IFmelt2$label[which(IFmelt2$Dist!=30)]=NA

p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, group=L1, label=label))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-SMA interacting fraction: spatial manual")+geom_label()
print(p)


p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-SMA knn3 ")
print(p)

# ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, linetype=SpatialManual))+geom_point()+stat_smooth()+ggtitle("CD8-EpCAM interacting fraction: spatial manual")+ylab("Interacting Fraction")

# ## Do a dot plot
 # p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-SMA knn3 ")
 # print(p)
```


Using the boxplots as a guide, we can determine optimal "interacting distances" at which to perform downstream analysis. The best separation between restricted and infiltrating for EpCAM appears at:

* 1-nn: 10-15 um
* 3-nn: 15 um
* 5-nn: 20 um

The interacting fraction does not distinguish SMA fractions (all restricted boxplots overlap with the infiltrating boxplots)


The following plots use 3NN analysis with an interacting distance of 15um. We can firstly check if there is an association between different "interacting fraction" types and manual scoring, similar to what was performed for knn-analysis. Only CD8-EpCAM interacting distances is associated with manual scoring. All other metrics are not significant.

```{r, fig.height=6}
## reshape and do a correlation plot like for the knn analysis
par(mfrow=c(3,3))
for (i in 1:9){
  a1=wilcox.test(IFreshape[ ,i]~IFreshape$Infil)
  boxplot(IFreshape[ ,i]~IFreshape$Infil, main=paste(colnames(IFreshape)[i]," p=", round(a1$p.value,2), sep="" ), xlab="IF: knn3, 15um")
}
```

Again, association between CD8 content and interacting fraction was observed ONLY in the growing samples or restricted cases. 

```{r, fig.height=4}
par(mfrow=c(1,2))
a1x=cor.test(IFreshape$CD8frac[IFreshape$Infil=="Infiltrating"], IFreshape$EpCAM[IFreshape$Infil=="Infiltrating"])
a1y=cor.test(IFreshape$CD8frac[IFreshape$Infil=="restricted"], IFreshape$EpCAM[IFreshape$Infil=="restricted"])
plot(IFreshape$CD8frac, IFreshape$EpCAM, col=IFreshape$Infil, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM IF (knn3-15um)", main="spatial scoring")
legend("topright", c(paste("infil p=", round(a1x$p.value,2)), paste("restrict p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))

a1x=cor.test(IFreshape$CD8frac[IFreshape$Growth=="growing"], IFreshape$EpCAM[IFreshape$Growth=="growing"])
a1y=cor.test(IFreshape$CD8frac[IFreshape$Growth=="stable"], IFreshape$EpCAM[IFreshape$Growth=="stable"])

plot(IFreshape$CD8frac, IFreshape$EpCAM, col=IFreshape$Growth, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM IF (knn3-15um)", main="tumor growth")
legend("topright", c(paste("growing p=", round(a1x$p.value,2)), paste("stable p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))
```

### Growth

Here, we check if there is an association between the spatial pattern and tumor growth.

```{r if-growth}

######
# compare these metrics with growth
####

#pdf(sprintf("rslt/WSI-analysis/interacting_fraction_vs_treatment_growth_%s.pdf", Sys.Date()), height=7, width=12)
ctypes=unique(IFmelt$NearestNeighbor)
t2=IFmelt[which(IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15) , ]

pval2=sapply(ctypes, function(x) wilcox.test(t2$value[t2$NearestNeighbor==x & t2$Growth2=="growing" ], t2$value[t2$NearestNeighbor==x & t2$Growth2=="stable" ])$p.value)

ann_text=data.frame(Glabel=round(pval2,2), NearestNeighbor=(ctypes ), Growth2="stable", value=0.7)

p<-ggplot(IFmelt[IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15 , ], aes(x=Growth2, y=value, col=Growth2))+facet_grid(~NearestNeighbor)+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("Interacting fraction, knn3, dist=15")
p+geom_text(data=ann_text, mapping=aes(x=2, y=0.75, label=Glabel))


# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="EpCAM" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Growth2, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM interacting fraction: growth")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="SMA" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Growth2, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-SMA interacting fraction: growth")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="EpCAM: SMA" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Growth2, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM:SMA interacting fraction: growth")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="Unclass" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Growth2, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-Unclass interacting fraction; spatial manual")
# print(p)
```

None of the above metrics associate with growth. (P value by wilcox test shown)

### Treatment

Similarly, compare the distances with treatment: 

```{r}

ctypes=unique(IFmelt$NearestNeighbor)
t2=IFmelt[which(IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15) , ]
TreatV=sort(unique(IFmelt$Treatment))

pval2=matrix(NA, nrow=3, ncol=5)
colnames(pval2)=ctypes
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(ctypes, function(x) wilcox.test(t2$value[t2$NearestNeighbor==x & t2$Treatment==TreatV[i]], t2$value[t2$NearestNeighbor==x & t2$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "NearestNeighbor", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(IFmelt[IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15 , ], aes(x=Treatment, y=value, col=Treatment))+facet_grid(~NearestNeighbor)+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("Interacting fraction, knn3, dist=15")
p+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.75, label=label, col=Treatment))
print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="EpCAM" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Treatment, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM interacting fraction: Treatment")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="SMA" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Treatment, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-SMA interacting fraction: Treatment")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="EpCAM: SMA" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Treatment, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM:SMA interacting fraction: Treatment")
# print(p)
# p<-ggplot(IFmelt[IFmelt$NearestNeighbor=="Unclass" & IFmelt$Reference=="CD8" , ], aes(x=Dist, y=value, col=Treatment, group=L1))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-Unclass interacting fraction; spatial manual")
# print(p)
#devoff()
```

There appears to be a difference in CD8-unclass interactions in LY treated samples (LY, PDL1+LY), but not in the other cases

## M-H distances

The M-H distance (or Morisita Horn index) can be considered as a correlation coefficient in spatial distribution between cell type A and cell type B. To calculate this metric, the whole slide image is divided into grids of size 50 to 500um. Within each grid, the total number of cells A and B are determined. 

The M-H index is thus determined as:

$$ \frac{2\sum_{i=1}^n a_ib_i}{(D_a+D_b)AB} $$
where $a_i$ and $b_i$ are the number of cells in grid $i$, $$A$$ and $$B$$ the total number of cells, and $$D_x$$ is the Simpson's index.

### Comparison to Manual Scoring

Similar to the interacting fraction, we plot the MH index for increasing values of gridsize to determine an optimal metric to compare spatial patterns. Ideally, we would pick a metric has the following properties:

* good separation of the different values
* a reasonable number of cells within each grid (avoid too small grids which give counts of 0)
* avoid plateauing of MH values because the grid size is too large

```{r, fig.height=4}

MHmeltsumm=melt(WSIMHsetup, id.vars=c("gridsize", "Ntiles"))

MHmelt=melt(WSIMH, measure.vars="MH.mean")
MHmelt$SpatialManual=Cdata$InfiltratingVsRestricted[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
MHmeltsumm$SpatialManual=Cdata$InfiltratingVsRestricted[match(MHmeltsumm$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Treatment=factor(Cdata$Treatment[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))])
MHmelt$Growth=factor(Cdata$Growth2[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))])
MHmelt$Growth2=MHmelt$Growth
#MHmelt$Growth2[grep("no data", MHmelt$Growth2)]="no data"

A1=MHmelt[MHmelt$Var2=="CD8", ]
A1$label=A1$L1
A1$label[which(A1$gridsize!=500)]=NA

A2=MHmelt[MHmelt$Var2=="CD8" & MHmelt$gridsize==250 & MHmelt$Var1%in%c("EpCAM", "SMA"), ]
A3=MHmelt[MHmelt$Var2=="CD8" & MHmelt$gridsize==250, ]
A3$CD8frac=WSIvalFracs[ 1, match(A3$L1, colnames(WSIvals))]

MHTempSumm=A3 #MHmelt[which(MHmelt$gridsize==300 & MHmelt$Var2=="CD8"), ]
MHreshape=acast(A3[ ,c("Var1", "value", "L1")], L1~Var1, value.var="value" )
MHreshape=data.frame(MHreshape)
MHreshape$EpMIN=ifelse(MHreshape$EpCAM..SMA<MHreshape$EpCAM, MHreshape$EpCAM..SMA, MHreshape$EpCAM)
MHreshape$EpMIN[which(is.na(MHreshape$EpMIN))]=MHreshape$EpCAM[which(is.na(MHreshape$EpMIN))]
MHreshape$EpStrRatio1=MHreshape$EpCAM/rowSums(MHreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)

MHreshape$EpStrRatio2=MHreshape$EpCAM/(MHreshape$SMA)
MHreshape$EpStrRatio3=rowSums(MHreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(MHreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
MHreshape$EpStrRatio4=rowSums(MHreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(MHreshape$SMA)
MHreshape$Treatment=factor(A3$Treatment[match(rownames(MHreshape), A3$L1)])
MHreshape$Growth=factor(A3$Growth[match(rownames(MHreshape), A3$L1)])
MHreshape$Infil=factor(A3$SpatialManual[match(rownames(MHreshape), A3$L1)])

#pdf(sprintf("rslt/WSI-analysis/MHplots_compare_spatial_manual_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(A1, aes(x=gridsize, y=value, col=SpatialManual, label=label))+facet_grid(~Var1)+geom_line(aes(group=L1))+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: spatial manual")+geom_label()
print(p)

ggplot(A1, aes(x=factor(gridsize), y=value, col=SpatialManual, label=label))+facet_grid(~Var1)+geom_boxplot()+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: spatial manual")

ggplot(MHmeltsumm, aes(x=factor(gridsize), y=value, col=SpatialManual))+facet_wrap(~variable, scale="free_y")+geom_boxplot()+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("expected number of cells in each grid size")+scale_y_log10()
```


With increasing grid size, optimal differences between infiltrating and restricted appear at the following sizes:

* epCAML 100um+
* epcam:SMA most significant at 350+
* SMA: 150+
* Unclass:200+

We probably want to use a metric/gridsize of 250 um as the expected/mean number of cells in each grid is 10 here.
Other notes:

* double positive cells (EpCAM+SMA+) appear in predominantly the restricted cases?
* higher SMA- stromal cells in restricted


Below, we check whether these metrics can differentiate between infiltrating and restricted tumors:

```{r, fig.height=6}
# a1=t.test(A2$value[A2$SpatialManual=="Infiltrating" & A2$Var1=="EpCAM"], A2$value[A2$SpatialManual=="Infiltrating" & A2$Var1=="SMA"], paired = T)
# a2=t.test(A2$value[which(A2$SpatialManual=="restricted" & A2$Var1=="EpCAM" & !A2$L1%in%c("15RD", "5LB"))], A2$value[which(A2$SpatialManual=="restricted" & A2$Var1=="SMA")], paired = T)
# p<-ggplot(A2, aes(x=Var1, y=value, col=SpatialManual))+facet_grid(~SpatialManual)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index @ 300um")+ggtitle(sprintf("MH index with CD8: Infiltrating p=%s, restricted p=%s", round(a1$p.value, 2), round(a2$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
# print(p)
# par(mfrow=c(2,2))
# for (i in unique(A3$Var1)){
# a1=cor(A3$value[A3$Var1==i], A3$CD8frac[A3$Var1==i], use="complete")
# plot(A3$value[A3$Var1==i], A3$CD8frac[A3$Var1==i], xlab="MH-index", ylab="CD8 fraction", main=sprintf("%s, cor=%s", i, round(a1,2)), col=A3$Growth2, pch=19)
# }
# mtext("association bw CD8frac and MH scores", 3, -2, outer = T)


par(mfrow=c(3,3))
for (i in 1:9){
  a1=wilcox.test(MHreshape[ ,i]~MHreshape$Infil)
  boxplot(MHreshape[ ,i]~MHreshape$Infil, main=paste(colnames(MHreshape)[i]," p=", round(a1$p.value,2), sep="" ), xlab="MH: knn3, 15um", ylab=colnames(MHreshape)[i])
}


#devoff()


#pdf(sprintf("rslt/WSI-analysis/MHplots_spatial_growth_treatment_zoom_300um_%s.pdf", Sys.Date()), height=7, width=12)
```

The above analysis shows that the MH-index shows differences in mixing between CD8 cells and mixing with most cell types. However MH-CD8-to-Epcam to MH-CD8-to-stroma ratios do not support this difference.

### Growth

Below are the MH indices with increasing grid-size for individual samples. In general, there is a subset of stable samples which have very high intermixing

```{r}

p<-ggplot(A1, aes(x=gridsize, y=value, col=Growth2))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: growth")
print(p)

pvals=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Growth2=="growing"], 
                                                      A3$value[A3$Var1==x & A3$Growth2=="stable"])$p.value)

ann_text=data.frame(label=round(pvals,2), Var1=unique(A3$Var1), Growth2="growing")

ggplot(A3, aes(x=Growth2, y=value, col=Growth2))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: growth")+geom_text(data=ann_text, mapping = aes(x=2, y=0.75, label=label))
```

Although the MH values for growing vs stable are not different, we can compare the mixing in epcam vs stroma in matched samples:

```{r}
A2t=A2[-which(A2$L1%in%c("15RD", "5LB")), ]

 a1=t.test(A2t$value[A2t$Growth=="stable" & A2t$Var1=="EpCAM"], A2t$value[A2t$Growth=="stable" & A2t$Var1=="SMA"], paired=T)
 a2=t.test(A2t$value[A2t$Growth=="growing" & A2t$Var1=="EpCAM"], A2t$value[A2t$Growth=="growing" & A2t$Var1=="SMA"], paired=T)
# 
ggplot(A2, aes(x=Var1, y=value, col=Growth2))+facet_grid(~Growth2)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index @ 250um")+ggtitle(sprintf("MH index with CD8: stable p=%s, growing p=%s", round(a1$p.value, 2), round(a2$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
# print(p)
```

### Treatment

```{r}

pval2=matrix(NA, nrow=3, ncol=4)
colnames(pval2)=unique(A3$Var1)
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Treatment==TreatV[i]], A3$value[A3$Var1==x & A3$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "Var1", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(A1, aes(x=gridsize, y=value, col=Treatment))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")
print(p)

ggplot(A3, aes(x=Treatment, y=value, col=Treatment))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.8, label=label))
```

There is no difference between the different spatial metrics compared to the vehicle, however, we can compare for a given treatment if there is a difference between the epcam and the stromal interaction scores. It appears that there is a difference only in the control, where SMA mixing is higher than EPcam mixing:

```{r}
## pairwise comparison: Epcam vs stroma

## calculate the pairwise p values here
A2t=A2[-which(A2$L1%in%c("15RD", "5LB")), ]

a1=t.test(A2t$value[A2t$Treatment=="Vehicle" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="Vehicle"& A2t$Var1=="SMA"], paired=T)
a2=t.test(A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="SMA"], paired=T)
a3=t.test(A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="SMA"], paired=T)
a4=t.test(A2t$value[A2t$Treatment=="LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="LY" & A2t$Var1=="SMA"], paired=T)

p<-ggplot(A2, aes(x=Var1, y=value, col=Treatment))+facet_grid(~Treatment)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index @ 250um")+ggtitle(sprintf("MH index with CD8: Cntl p=%s, PDL1 p=%s LY p=%s P+L p=%s", round(a1$p.value, 2), round(a2$p.value, 2), round(a3$p.value,2), round(a4$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
print(p)

#devoff()

```



```{r,eval=F}


#pdf(sprintf("rslt/WSI-analysis/MH_gridsize300_epstromal_ratios_%s.pdf", Sys.Date()), height=7, width=12)
par(mfrow=c(1,2))
hist(log2(MHreshape$EpStrRatio1), main="ratio Epcam:any SMA")
hist(log2(MHreshape$EpStrRatio2), main="ratio Epcam:SMA", breaks=30)
a1=wilcox.test(MHreshape$EpStrRatio1~MHreshape$Infil)
ggplot(MHreshape, aes(x=Infil,y=log2(EpStrRatio1), col=Growth))+geom_boxplot()+ggtitle(sprintf("ratio Epcam:any SMA p = %s", round(a1$p.value, 2)))
ggplot(MHreshape, aes(x=Infil,y=log2(EpStrRatio1), col=Growth))+geom_point()+ggtitle(sprintf("ratio Epcam:any SMA p = %s", round(a1$p.value, 2)))
a1=wilcox.test(MHreshape$EpStrRatio2~MHreshape$Infil)
ggplot(MHreshape, aes(x=Infil,y=log2(EpStrRatio2), col=Growth))+geom_boxplot()+ggtitle(sprintf("ratio Epcam:any SMA p = %s", round(a1$p.value, 2)))
ggplot(MHreshape, aes(x=Infil,y=log2(EpStrRatio2), col=Growth))+geom_point()+ggtitle(sprintf("ratio Epcam:any SMA p = %s", round(a1$p.value, 2)))
plot(log2(MHreshape$EpStrRatio2), log2(MHreshape$EpStrRatio1), col=MHreshape$Infil, xlab="any SMA", ylab="ep:sma ratio")
#devoff()

lx1=match(rownames(knnreshape), gsub("_", "", Cdata$TumorID))
Cdata$MHEpstrRatio=NA
Cdata$MHEpstrRatio[lx1]=knnreshape$EpStrRatio1
Cdata$MHEpAntstrRatio=NA
Cdata$MHEpAntstrRatio[lx1]=knnreshape$EpStrRatio2
Cdata$MHEpcam=NA
Cdata$MHEpcam[lx1]=knnreshape$EpCAM
Cdata$MHSMA=NA
Cdata$MHSMA[lx1]=knnreshape$SMA
```

## Comparison between metrics

After assessing optimal parameters for each metric, in this section we assess which metric could be the best for spatial analysis.

Below is a table of the different metrics and their values for each sample

```{r}
write.xlsx(Cdata, file=sprintf("../metadata/Carlos_samples_list_master_updated_%s.xlsx", Sys.Date()))
#write.table(SummaryData, file="../metadata/WSI_compared_other_metrics.csv")

##
# Combine the data from above into one file
#
df.Spatial=cbind(knnreshape[ , 1:9], IFreshape[ ,1:10], MHreshape[ , 1:9] )
colnames(df.Spatial)=paste(rep(c("knn", "IF", "MH"), times=c(9, 10, 9)), colnames(df.Spatial),sep=".")

df.Spatial=cbind(df.Spatial, knnreshape[ ,10:13])
df.Spatial$GrowthRate=Cdata$GrowthRate[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$TumSize=Cdata$Tumor.dia..sac..mm.[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$knn.EpCAMcut=cut(df.Spatial$knn.EpCAM, c(-1, median(df.Spatial$knn.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$MH.EpCAMcut=cut(df.Spatial$MH.EpCAM, c(-1, median(df.Spatial$MH.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$IF.EpCAMcut=cut(df.Spatial$IF.EpCAM, c(-1, median(df.Spatial$IF.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$CD8Fraccut=cut(df.Spatial$CD8frac, c(-1, median(df.Spatial$CD8frac, na.rm = T), 1.2), c("low", "high"))

t2=WSIvalFracs[, match(rownames(df.Spatial), colnames(WSIvalFracs))]

df.Spatial=cbind(df.Spatial, t(t2))

write.csv(df.Spatial, file="outputs/summary_scores_spatial.csv")

df.Spatial[which(df.Spatial=="Inf", arr.ind = T)]=NA

testSig1=sapply(c(1:28, 32), function(x) wilcox.test(df.Spatial[ ,x] ~ df.Spatial$Growth)$p.value)
knnreshapeB=knnreshape
knnreshapeB[which(knnreshapeB=="Inf", arr.ind=T)]=NA
testSig1=sapply(c(1:28, 32), function(x) wilcox.test(df.Spatial[ ,x] ~ knnreshapeB$Infil)$p.value)
testSig2=sapply(c(1:28, 32), function(x) cor.test(df.Spatial[ ,x] , df.Spatial$GrowthRate, use="complete", method="spearman")$p.value)
testSig3=sapply(c(1:28, 32), function(x) cor.test(df.Spatial[ ,x] , df.Spatial$TumSize, use="complete", method="spearman")$p.value)

#datatable(df.Spatial[ , c("knn.EpCAM", "IF.EpCAM", "MH.EpCAM", "Treatment", "Growth", #"Infil", "CD8frac", "TumSize")], options = list(
#  searching = T,
#  pageLength = 5,
#  lengthMenu = c(5, 10, 15, 20)
#))


scroll_box(kable(df.Spatial[ , c("knn.EpCAM", "IF.EpCAM", "MH.EpCAM", "Treatment", "Growth", "Infil", "CD8frac", "TumSize")], format="html"),
         height="300px", width="100%")


scroll_box(kable(df.Spatial, format="html"),
         height="300px", width="100%")
```

```{r}
#df.Spatial=read.csv("../data/WSI-data/summary_scores_spatial.csv", row.names = 1)
```

Firstly, we can compare the different metrics to determine how similar or different they are:

```{r, fig.height=6}
#pdf(sprintf("rslt/WSI-analysis/similarity_between_spatial_methods_%s.pdf", Sys.Date()), height=7, width=12)

par(mfrow=c(2,2))
a1=cor.test(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM)
plot(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM, xlab="knn", ylab="MH",
     main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))
a1=cor.test(df.Spatial$IF.EpCAM, df.Spatial$MH.EpCAM)
plot(df.Spatial$MH.EpCAM, df.Spatial$IF.EpCAM,  xlab="MH", ylab="IF",
      main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))
a1=cor.test(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM)
plot( df.Spatial$IF.EpCAM,df.Spatial$knn.EpCAM,  xlab="IF", ylab="knn",
       main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))

#devoff()
```

Do any of these metrics associate with growth or treatments?

```{r, fig.height=6}
par(mfrow=c(3,3))

cNames=c("knn.EpCAM", "IF.EpCAM", "MH.EpCAM")

for (i in cNames){
t1=wilcox.test(df.Spatial[, i]~df.Spatial$Growth)$p.value
boxplot(df.Spatial[, i]~df.Spatial$Growth, ylab=i, xlab="Growth", main=sprintf("p:%s", round(t1,2)))

t2=wilcox.test(df.Spatial[df.Spatial$Treatment%in%c("PDL1+LY", "Vehicle"), i]~df.Spatial$Treatment[df.Spatial$Treatment%in%c("PDL1+LY", "Vehicle")])$p.value
t1=wilcox.test(df.Spatial[df.Spatial$Treatment%in%c("PDL1", "Vehicle"), i]~df.Spatial$Treatment[df.Spatial$Treatment%in%c("PDL1", "Vehicle")])$p.value
t3=wilcox.test(df.Spatial[df.Spatial$Treatment%in%c("LY", "Vehicle"), i]~df.Spatial$Treatment[df.Spatial$Treatment%in%c("LY", "Vehicle")])$p.value

boxplot(df.Spatial[, i]~df.Spatial$Treatment, ylab=i, xlab="Treatment",
         main=sprintf("LY:%s PDL1:%s, P+L:%s", round(t3, 2), round(t1, 2), round(t2, 2)))

t1=wilcox.test(df.Spatial[df.Spatial$Infil%in%c("Infiltrating", "restricted"), i]~df.Spatial$Infil[df.Spatial$Infil%in%c("Infiltrating", "restricted")])$p.value
boxplot(df.Spatial[, i]~df.Spatial$Infil, ylab=i, xlab="Infil", main=sprintf("p:%s", round(t1, 2)))
}

boxplot(df.Spatial$MH.EpCAM~df.Spatial$Growth+df.Spatial$CD8Fraccut)
boxplot(df.Spatial$CD8frac~df.Spatial$Growth)
wilcox.test(df.Spatial$CD8frac~df.Spatial$Growth)

plot(df.Spatial$CD8frac, df.Spatial$MH.EpCAM, col=factor(df.Spatial$Growth))
plot(df.Spatial$MH.SMA, df.Spatial$MH.EpCAM, col=factor(df.Spatial$Growth))

plot(df.Spatial$IF.SMA, df.Spatial$IF.EpCAM, col=factor(df.Spatial$Growth))
text(df.Spatial$IF.SMA+0.025, df.Spatial$IF.EpCAM+0.025,rownames(df.Spatial))

plot(df.Spatial$MH.SMA, df.Spatial$MH.EpCAM, col=factor(df.Spatial$Growth))

plot(log10(df.Spatial$knn.SMA), log10(df.Spatial$knn.EpCAM), col=factor(df.Spatial$Growth), pch=19,
     ylab="knn.EpCAM", xlab="knn.SMA")
text(log10(df.Spatial$knn.SMA+0.025), log10(df.Spatial$knn.EpCAM+0.025),rownames(df.Spatial))

```
We can also compare this to raw tumor size or growth rate data as well:

```{r}
par(mfrow=c(2,3))

cNames=c("knn.EpCAM", "IF.EpCAM", "MH.EpCAM")

for (i in cNames){
t1=cor.test(df.Spatial[, i],df.Spatial$GrowthRate, use="complete")
plot(df.Spatial[, i]~df.Spatial$GrowthRate, ylab=i, xlab="Growth Rate", main=sprintf("cor:%s p:%s", round(t1$estimate, 2), round(t1$p.value,2)))

t1=cor.test(df.Spatial[ ,i],df.Spatial$TumSize, use="complete")
plot(df.Spatial[, i]~as.numeric(as.character(df.Spatial$TumSize)), ylab=i, xlab="Tumor size", main=sprintf("cor:%s p:%s", round(t1$estimate, 2), round(t1$p.value, 2)))
}

```


```{r, eval=F}
cNames=c("IFEpAntstrRatio", "MHEpAntstrRatio", "MHEpstrRatio", "IFEpstrRatio", "MHEpcam", "IFEpcam", "MHSMA", "IFSMA",
         "knnSMADist", "knnEpDist", "knnEpAntstrRatio", "knnEpstrRatio")

ttestTable=rep(NA, length(cNames))

#pdf(sprintf("rslt/WSI-analysis/compare_Spatial_Manual_vs_Metric_%s.pdf", Sys.Date()), height=7, width=8)

par(mfrow=c(3,4))
for (i in 1:length(cNames)){
  xa=which(is.na(Cdata[ ,cNames[i]]) | is.infinite(Cdata[ ,cNames[i]]) | is.nan(Cdata[ ,cNames[i]]))
  if (length(xa)>0){
  ttestTable[i]=t.test( Cdata[ -xa,cNames[i]]~Cdata$InfiltratingVsRestricted[-xa])$p.value
  } else {
    ttestTable[i]=t.test( Cdata[ ,cNames[i]]~Cdata$InfiltratingVsRestricted)$p.value
  }
  boxplot(Cdata[ ,cNames[i]]~Cdata$InfiltratingVsRestricted, main=sprintf("%s p:%s", cNames[i], round(ttestTable[i],2)))
}

#devoff()

```


```{r,eval=F}
Cdata$IFEpstrRatio[which(Cdata$IFEpstrRatio=="Inf")]=NA
Cdata$MHEpstrRatio[which(Cdata$MHEpstrRatio=="Inf")]=NA
Cdata$MHEpstrRatio[which(Cdata$MHEpstrRatio=="Inf")]=NA

Cdata$IFEpAntstrRatio[which(Cdata$IFEpAntstrRatio=="Inf")]=NA
Cdata$MHEpAntstrRatio[which(Cdata$MHEpAntstrRatio=="Inf")]=NA
Cdata$MHEpAntstrRatio[which(Cdata$MHEpAntstrRatio=="Inf")]=NA

par(mfrow=c(2,3))

#pdf(sprintf("rslt/WSI-analysis/Compare_knn_IF_MH_index_%s.pdf", Sys.Date()), height=7, width=12)
a1=cor.test(log2(Cdata$IFEpstrRatio+0.01), log2(Cdata$MHEpstrRatio+0.01), use="complete", na.rm=T)
plot(log2(Cdata$IFEpstrRatio), log2(Cdata$MHEpstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="IF", ylab="MH",ylim=c(-3, 3),
      main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))
a1=cor.test(log2(Cdata$IFEpstrRatio+0.01), log2(Cdata$knnEpstrRatio), use="complete", na.rm=T)
plot(log2(Cdata$IFEpstrRatio), log2(Cdata$knnEpstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="IF", ylab="knn", 
      main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))
a1=cor.test(log2(Cdata$IFEpstrRatio+0.01), log2(Cdata$knnEpstrRatio), use="complete", na.rm=T)
plot(log2(Cdata$MHEpstrRatio), log2(Cdata$knnEpstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="MH", ylab="knn", xlim=c(-4, 4),
      main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(log2(Cdata$IFEpAntstrRatio+0.01), log2(Cdata$MHEpAntstrRatio+0.01), use="complete", na.rm=T)
plot(log2(Cdata$IFEpAntstrRatio), log2(Cdata$MHEpAntstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="IF", ylab="MH",ylim=c(-3, 3),      main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))
a1=cor.test(log2(Cdata$IFEpAntstrRatio+0.01), log2(Cdata$knnEpAntstrRatio), use="complete", na.rm=T)
plot(log2(Cdata$IFEpAntstrRatio), log2(Cdata$knnEpAntstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="IF", ylab="knn", 
      main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))
a1=cor.test(log2(Cdata$IFEpAntstrRatio+0.01), log2(Cdata$knnEpAntstrRatio), use="complete", na.rm=T)
plot(log2(Cdata$MHEpAntstrRatio), log2(Cdata$knnEpAntstrRatio), col=Cdata$InfiltratingVsRestricted, xlab="MH", ylab="knn", xlim=c(-4, 4),     main=sprintf("ep to SMA fraction cor=%s p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

#devoff()
```


## Other cell types

We noted that the proportion of Unclassified cells seemed to be different between the treatments. Assess here whether the MH index for this cell type is associated with growth or treatment here:

```{r}
varsearch="Unclass"

#MHmeltsumm=melt(WSIMHsetup, id.vars=c("gridsize", "Ntiles"))

MHmelt=melt(WSIMH, measure.vars="MH.mean")
MHmelt$SpatialManual=Cdata$InfiltratingVsRestricted[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmeltsumm$SpatialManual=Cdata$InfiltratingVsRestricted[match(MHmeltsumm$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Treatment=Cdata$Treatment[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Growth2=Cdata$Growth2[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmelt$Growth2=Cdata$Tumor.growth.status[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmelt$Growth2[grep("no data", MHmelt$Growth2)]="no data"

A1=MHmelt[MHmelt$Var2==varsearch| MHmelt$Var1==varsearch, ]
A1$label=A1$L1
A1$label[which(A1$gridsize!=500)]=NA
A1$Var1=ifelse(A1$Var1==varsearch, as.character(A1$Var2), as.character(A1$Var1))

A2=MHmelt[(MHmelt$Var2==varsearch|MHmelt$Var1==varsearch) & MHmelt$gridsize==250 & MHmelt$Var1%in%c("EpCAM", "SMA"), ]
A3=MHmelt[(MHmelt$Var2==varsearch|MHmelt$Var1==varsearch) & MHmelt$gridsize==250, ]
A3$CD8frac=WSIvalFracs[ 1, match(A3$L1, colnames(WSIvals))]

A3$Var1=ifelse(A3$Var1==varsearch, as.character(A3$Var2), as.character(A3$Var1))

MHTempSumm=A3 #MHmelt[which(MHmelt$gridsize==300 & MHmelt$Var2==varsearch), ]
MHreshape=acast(A3[ ,c("Var1", "value", "L1")], L1~Var1, value.var="value" )
MHreshape=data.frame(MHreshape)

MHreshape$Treatment=A3$Treatment[match(rownames(MHreshape), A3$L1)]
MHreshape$Growth=A3$Growth2[match(rownames(MHreshape), A3$L1)]
MHreshape$Infil=A3$SpatialManual[match(rownames(MHreshape), A3$L1)]

colnames(MHreshape)=paste(varsearch, colnames(MHreshape), sep=".")
write.csv(MHreshape, file=sprintf("outputs/%s_MH_comparisons_gridsize250.csv", varsearch))

# pdf(sprintf("rslt/WSI-analysis/MHplots_spatial_growth_treatment_%s_celltype_%s.pdf", varsearch, Sys.Date()), height=7, width=12)
# 
 p<-ggplot(A1, aes(x=gridsize, y=value, col=Growth2))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))
 print(p)
 
pvals=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Growth2=="growing"],A3$value[A3$Var1==x & A3$Growth2=="stable"])$p.value)

ann_text=data.frame(Growth2="stable", y=0.8, label=round(pvals,2), Var1=unique(A3$Var1))
 
ggplot(A3, aes(x=Growth2, y=value, col=Growth2))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))+
  geom_text(data=ann_text, mapping = aes(x=Growth2 , y=0.75, label=label))
 

pval2=matrix(NA, nrow=3, ncol=4)
colnames(pval2)=unique(A3$Var1)
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Treatment==TreatV[i]], A3$value[A3$Var1==x & A3$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "Var1", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(A1, aes(x=gridsize, y=value, col=Treatment))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))
print(p)

ggplot(A3, aes(x=Treatment, y=value, col=Treatment))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.8, label=label))


#  p<-ggplot(A2, aes(x=Var1, y=value, col=Growth2))+facet_grid(~Growth2)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index @ 250um")+ggtitle(sprintf("MH index with CD8: stable p=%s, growing p=%s", round(a1$p.value, 2), round(a2$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
# # print(p)
# 
#  p<-ggplot(A1, aes(x=gridsize, y=value, col=Treatment))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")
#  print(p)
# 
# ggplot(A3, aes(x=Treatment, y=value, col=Growth2))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")
# 
# ## pairwise comparison: Epcam vs stroma
# 
# ## calculate the pairwise p values here
# 
# a1=t.test(A2t$value[A2t$Treatment=="Vehicle" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="Vehicle"& A2t$Var1=="SMA"], paired=T)
# a2=t.test(A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="SMA"], paired=T)
# a3=t.test(A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="SMA"], paired=T)
# a4=t.test(A2t$value[A2t$Treatment=="LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="LY" & A2t$Var1=="SMA"], paired=T)
# 
# p<-ggplot(A2, aes(x=Var1, y=value, col=Treatment))+facet_grid(~Treatment)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index @ 250um")+ggtitle(sprintf("MH index with CD8: Cntl p=%s, PDL1 p=%s LY p=%s P+L p=%s", round(a1$p.value, 2), round(a2$p.value, 2), round(a3$p.value,2), round(a4$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
# print(p)

#dev.off()
```



```{r, eval=F}
#This is epcam- sma- stroma and based on images is restricted:

CelltypeStudy="EpCAM"

knnTemp1=knnMelt[knnMelt$CellType==CelltypeStudy & knnMelt$NearestCellType%in%c("CD8","EpCAM", "SMA", "EpCAM: SMA", "Unclass"), ]
knnTemp1$SpatialManual=Cdata$InfiltratingVsRestricted[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

# compute p values?
ptest=sapply(levels(knnTemp1$knn), function(x) wilcox.test(knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="EpCAM" & knnTemp1$SpatialManual=="Infiltrating")], knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="SMA" & knnTemp1$SpatialManual=="Infiltrating")])$p.value)

fit1=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
summary(fit1)
fit2=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])
summary(fit2)

fit1b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
summary(fit1b)
fit2b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])
summary(fit2b)

#pdf(sprintf("rslt/WSI-analysis/Unclass_cells_knn_distances_vs_manualspatial_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=SpatialManual))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=SpatialManual))+facet_grid(~knn+SpatialManual)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#377eb8"),na.value="black")

print(p)
par(mfrow=c(1,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1, "NearestCellType"))
title("Infiltrating Mean Distance", line=3.3)
plot(TukeyHSD(fit2, "NearestCellType"))
title("Restricted Mean Distance", line=3.3)

p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MedianDistance, fill=SpatialManual))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=SpatialManual))+facet_grid(~knn+SpatialManual)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#377eb8"),na.value="black")
print(p)

par(mfrow=c(1,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1b, "NearestCellType"))
title("Infiltrating Median Distance", line=3.3)
plot(TukeyHSD(fit2b, "NearestCellType"))
title("Restricted Median Distance", line=3.3)

knnTemp1$Treatment=Cdata$Treatment[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM", ])
fit2=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="SMA", ])
fit3=aov(MeanDistance~Treatment+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA", ])

knnTemp1$Growth=Cdata$Growth2[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM", ])
fit2b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="SMA", ])
fit3b=aov(MeanDistance~Growth+knn, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA", ])


p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=Treatment))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Treatment))+facet_grid(~knn+Treatment)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#4daf4a","#377eb8",  "#984ea3"),na.value="black")
print(p)

p<-ggplot(knnTemp1, aes(fill=Treatment, y=MeanDistance, x=Treatment))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Treatment))+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#4daf4a","#377eb8",  "#984ea3"),na.value="black")
print(p)

par(mfrow=c(1,3), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1, "Treatment"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2, "Treatment"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3, "Treatment"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)

p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=Growth))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Growth))+facet_grid(~knn+Growth)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c","#ff7f00", "#4daf4a","#377eb8",  "#984ea3", "purple"),na.value="black")
print(p)

p<-ggplot(knnTemp1, aes(fill=Growth, y=MeanDistance, x=Growth))+geom_boxplot(outlier.shape=NA)+geom_jitter(aes(col=Growth))+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c","#ff7f00", "#4daf4a","#377eb8",  "#984ea3", "purple"),na.value="black")
print(p)

par(mfrow=c(1,3), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1b, "Growth"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2b, "Growth"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3b, "Growth"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)

#dev.off()

```

<!--chapter:end:02b-wsi.Rmd-->

# Expression data

This file looks at loading and pre-processing data for:

* differential gene expression analysis
* PAM50 subtyping
* uploading into CIBERSORT/TIMER

## Running alignment

Samples were mapped in star using the following parameters. Note that the first two batches of samples run had shorter read lengths (~75 bp) whereas batch 3 had lengths of ~150bp

```{r, eval=F, echo=T}
## Not run here
STAR \
     --readFilesCommand zcat \
     --genomeDir /n/scratch2/at268/rn6_v2 \
     --sjdbGTFfile /n/scratch2/at268/rn6_v2/rn6.refGene.gtf \
     --runThreadN 10 \
     --runMode alignReads \
     --genomeLoad NoSharedMemory\
     --outSAMattributes	NH HI AS nM NM\
     --outSAMstrandField intronMotif\
     --outFilterMultimapNmax 20\
     --alignSJoverhangMin 8\
     --readFilesIn $1 $2 \
     --alignSJDBoverhangMin 1\
     --outFilterMismatchNmax 999\
     --outFilterMismatchNoverLmax 0.1\
     --alignIntronMin 20\
     --alignIntronMax 1000000\
     --alignMatesGapMax	1000000\
     --outFilterType BySJout\
     --outFilterScoreMinOverLread 0.33 \
     --outFilterMatchNminOverLread 0.33 \
     --limitSjdbInsertNsj 1200000 \
     --outFilterIntronMotifs None \
     --alignSoftClipAtReferenceEnds Yes\
     --outSAMattrRGline	ID:$4 SM:$4 \
     --chimSegmentMin 15 \
     --chimJunctionOverhangMin 15\
     --limitBAMsortRAM 0\
     --outSAMtype BAM SortedByCoordinate\
     --outSAMunmapped Within \
     --quantMode GeneCounts transcriptomeSAM \
     --quantTranscriptomeBan IndelSoftclipSingleend \
     --outFileNamePrefix $3 \
     --twopassMode Basic
```

In addition, RSEM was run to obtain TPM, rsem and FPKM counts.
Note: [rn6.refGene.gtf.gz](http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/genes/rn6.ncbiRefSeq.gtf.gz) was used to generate the RSEM library!(This is the may version)

```{r}
# Upload infoTable

infoTable=read.csv("../metadata/AllRNA_samples_sept.csv")

####
# uncomment to update these parameters
####
infoTable$TumorID=paste(infoTable$Rat_ID, infoTable$Location, sep="_")
a1=match(infoTable$TumorID, Cdata$TumorID)
```

## RNA Initial QC


```{r rna-preprocess, cache=T}
BatchNo="april"

rsemFiles=dir("../data/RNA_expression/rsem/", ".results")
allrsem=matrix(NA, nrow=17455, ncol=length(rsemFiles)) #31038
allTPM=matrix(NA, nrow=17455, ncol=length(rsemFiles))
allFPKM=matrix(NA, nrow=17455, ncol=length(rsemFiles))
for (i in 1:length(rsemFiles)){
  a1=read.delim(file.path("../data/RNA_expression/rsem/", rsemFiles[i]))
  allrsem[ ,i]=a1$expected_count
  allTPM[ ,i]=a1$TPM
  allFPKM[ ,i]=a1$FPKM
}

cNames=unlist(strsplit(rsemFiles, ".genes.results"))
cNames=unlist(strsplit(cNames, "_0.33_v2"))
sAnnot=match(cNames, infoTable$starSampleName)
colnames(allrsem)=paste(infoTable$Rat_ID[sAnnot],infoTable$Location[sAnnot], infoTable$Fraction[sAnnot],  sep="_")
rownames(allrsem)=a1$gene_id

colnames(allTPM)=colnames(allrsem)
rownames(allTPM)=rownames(allrsem)

colnames(allFPKM)=colnames(allrsem)
rownames(allFPKM)=rownames(allrsem)

starFiles=dir("../data/RNA_expression/star_april/", ".tab")
allstar=matrix(NA, nrow=17455, ncol=length(starFiles))
allmapp=matrix(NA, nrow=4, ncol=length(starFiles))


for (i in 1:length(starFiles)){
  a1=read.delim(file.path("../data/RNA_expression/star_april/", starFiles[i]), header=F)
  allstar[ ,i]=a1[ -c(1:4),2]
  allmapp[ ,i]=a1[ c(1:4),2]
}

cNames=unlist(strsplit(starFiles, "ReadsPerGene.out.tab"))
cNames=unlist(strsplit(cNames, "_0.33_v2"))
sAnnot=match(cNames, infoTable$starSampleName)
colnames(allstar)=paste(infoTable$Rat_ID[sAnnot], infoTable$Location[sAnnot],infoTable$Fraction[sAnnot], sep="_")
rownames(allstar)=a1[-c(1:4) ,1]

colnames(allmapp)=colnames(allstar)
allmapp=rbind(allmapp, colSums(allstar))

rownames(allmapp)=c(as.character(a1[c(1:4), 1]), "UniqueReads")


## in all cases, remove the files 
id=match(cNames, infoTable$starSampleName)
infoTable=infoTable[ na.omit(id), ]
id2=which(is.na(id))

if (length(id2)>0){

allmapp=allmapp[ , -grep("NA_NA", colnames(allmapp))]

allTPM=allTPM[ , -id2]
allFPKM=allFPKM[ , -id2]
allrsem=allrsem[ , -id2]
allstar=allstar[, -id2]
}
```


Default output from R showing the number of unique reads compared to multimapped, unmapped etc. This is shown for each batch.
Note that batch 3 has differences (high percentage of unmapped) compared to the other batches, possibly due to DNA contamination.

Below we check for three measures:

- mapped million reads (ideally, 10M+ reads)
- Gene Sparsity: This is a measurement of the number of genes which have non-zero values. Ideally, would be greater than 10K, but values which are too high may also suggest contamination from DNA (unexpressed genes are also counted)
- Varability: standard deviation of the transcriptomic counts. If this value is too low, would suggest that high DNA contamination, non-representative transcriptome.


```{r}
# number of mapped reads
UnMappedNorm=t(allmapp)/colSums(allmapp)

mUnMap=melt(UnMappedNorm)
mUnMap$Batch=infoTable$Batch[match(mUnMap$Var1, infoTable$SampleID)]

# how many genes represented
Sparsity=colSums(sign(allstar))
# check how skewed the data is

cSDs=colSds(allstar)

TVals=data.frame(MappedReadsM=allmapp[5, ]/1E6, GeneSparsityK=Sparsity/1E3,Batch=infoTable$Batch, GeneVariabilityCounts=cSDs, Type=as.character(infoTable$Fraction), names=colnames(allstar))

mTV=melt(TVals, measure.vars = c("MappedReadsM", "GeneSparsityK", "GeneVariabilityCounts"))

#pdf(sprintf("../rslt/DESeq/GE_preprocessing_%s_%s.pdf", BatchNo,Sys.Date()), height=5, width=8)

ggplot(mUnMap, aes(x=Var1, y=value, fill=Var2))+geom_bar(stat="identity")+facet_grid(~Batch, space="free", scale="free")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ylab("proportion of reads")+ggtitle("mapping summary")

ggplot(mTV, aes(x=names, y=value,fill=Type))+geom_bar(stat="identity")+
  facet_grid(variable~Batch, space="free_x", scale="free")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("#Mapped Reads, #Unique Gebes, #Variability")

par(mfrow=c(2,2))

plot(density(TVals$MappedReadsM), main="mapped reads")
x1=mean(TVals$MappedReadsM)
sdv=sd(TVals$MappedReadsM)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.07, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)

plot(density(TVals$GeneSparsityK), main="gene sparsity")
x1=mean(TVals$GeneSparsityK)
sdv=sd(TVals$GeneSparsityK)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.07, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)

plot(density(TVals$GeneVariabilityCounts), main="Gene Variability")
x1=mean(TVals$GeneVariabilityCounts)
sdv=sd(TVals$GeneVariabilityCounts)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.00015, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)


#dev.off()
```


Samples to remove from analysis:

The thresholds indicated below are based on the above density plots, and removes cases which are <1.5 SD of the mean

* low total number of mapped reads (under 1.5M)
* sparsity: less than 8K genes
* variability : threshold under 500


```{r}
rmSamples=which(TVals$MappedReadsM<1.5 | TVals$GeneSparsityK<8 | TVals$GeneVariabilityCounts<500)
allstarFinal=allstar[ ,-rmSamples]
allrsemFinal=allrsem[ ,-rmSamples]
allTPMFinal=allTPM[ ,-rmSamples]
allFPKMFinal=allFPKM[ ,-rmSamples]
infoTableFinal=infoTable[-rmSamples, ]
```

The omitted samples are:

```{r}
kable(TVals[rmSamples, ])
```


We are left with `r ncol(allstarFinal)` samples. 

There are `r table(infoTableFinal$Fraction)` samples in the `r unique(infoTableFinal$Fraction)` fractions.

There are `r table(infoTableFinal$Batch)` samples from batches 1, 2 and 3 respectively.

## Normalisation

Run through DESEq and normalise the library. Using all samples, we run the model:

expression ~ Celltype + factor (Batch)

and keep the genes which have a total count of at least half the number of samples. ie.
$ sum(gene_i) > N_{samples}/2 $


```{r deseq-1, cache=T, eval=T}
# remove rows where counts are low?
rownames(infoTableFinal)=infoTableFinal$SampleID
infoTableFinal$Batch=factor(infoTableFinal$Batch)
dds=DESeqDataSetFromMatrix(allstarFinal, infoTableFinal, design=~Fraction+factor(Batch)) ## change class
keep=rowSums(counts(dds))>(ncol(dds)/2)
dds=dds[keep, ]
dds=DESeq(dds)

vsd <- varianceStabilizingTransformation(dds)
normalizedTableVSD <- assay(vsd)

# infoTableFinal$Treatment=RNADNAsamples$Treatment[match(infoTableFinal$FqFile, RNADNAsamples$FqFile.CD45)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.Ep)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.DN)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]

save(dds, vsd,allstarFinal, allrsemFinal,allTPMFinal, normalizedTableVSD,infoTableFinal,  file=sprintf("../dds_normalised_data_newstar_RNAseq%s_%s.RData", BatchNo, Sys.Date()))
```

### preliminary visualisation (to remove outliers)

Below are PCA plots based on:

* Batch
* CellType

```{r vsd-transform,eval=T, cache=T, fig.height=4}
vsd2 <- vst(dds)

#pdf(sprintf("../rslt/DESeq/PCA_preliminary_%s_%s.pdf",BatchNo, Sys.Date() ), width=8, height=6)

#All samples
plotPCA(vsd2, "Batch")+ggtitle("Batch")
plotPCA(vsd2, "Fraction")+ggtitle("Fraction")
plotPCA(vsd2, c("Fraction"))+geom_label(aes(label = name)) 

```

Batches in general separate out well, however, some samples appear to be outliers in comparison to the main group. We look in closer detail the CD45, DN and EpCAM populations.

In the CD45 population, narrow down to only immune related genes to see if there is a difference.

```{r}
# plotPCA(vsd2, c("Treatment"))+ggtitle("Treatment")
# plotPCA(vsd2, c("Growth"))+ggtitle("Growth")
# plotPCA(vsd2, "TumSize")+ggtitle("tumor size")
# plotPCA(vsd2, "CD8Frac")+ggtitle("CD8 Fraction")
# plotPCA(vsd2, "SpatialManual")+ggtitle("CD8 distribution")
# plotPCA(vsd2, "IFEpAntstrRatio")+ggtitle("CD8 distribution")
# plotPCA(vsd2, "MHSMA")+ggtitle("CD8 distribution")
# plotPCA(vsd2, "MHEpCAM")+ggtitle("CD8 distribution")


#Cd45 specific
# plotPCA(vsd2[, grep("CD45", colnames(vsd2))], c("Treatment"))+ggtitle("CD45 only Treatment")+geom_label(aes(label = name))
plotPCA(vsd2[rownames(assay(vsd2))%in%RatAllImm , grep("CD45", colnames(vsd2))], c("Growth"))+ggtitle("CD45 only Treatment: immune only genes")+geom_label(aes(label = name))
# plotPCA(vsd2[rownames(assay(vsd2))%in%RatAllImm  , grep("CD45", colnames(vsd2))], c("Growth"))+ggtitle("CD45 only Growth")
plotPCA(vsd2[ , grep("Ep", colnames(vsd2))], "Growth")+geom_label(aes(label = name))+ggtitle("Ep only Growth")
plotPCA(vsd2[ , grep("DN", colnames(vsd2))], "Growth")+geom_label(aes(label = name))+ggtitle("DN only Growth")

# vsdLimma=vsd2
# assay(vsdLimma)<- limma::removeBatchEffect(assay(vsdLimma), vsd$Batch)
# plotPCA(vsdLimma, c("Fraction", "Batch"))
# plotPCA(vsdLimma, c("Fraction"))
# plotPCA(vsdLimma, c("Batch"))
# plotPCA(vsdLimma, c("Growth", "Fraction"))

#dev.off()
```

Based on the above plots, we remove the following outliers and re-run the normalisation:

* 2R_D_DN
* 4L_B_CD45

```{r rm-ill-samples, cache=T}
rmThese=c("2R_D_DN", "4L_B_CD45")

## Note based on the above plots, sample "2R_D_DN" is misclassified as a cd45 sample. Need to remove this sample and re-run the preprocessing:
allstarFinal=allstarFinal[ ,-match(rmThese, colnames(allstarFinal))]
infoTableFinal=infoTableFinal[-match(rmThese, rownames(infoTableFinal)), ]
allrsemFinal=allrsemFinal[ ,-match(rmThese, colnames(allrsemFinal))]
allTPMFinal=allTPMFinal[ ,-match(rmThese, colnames(allTPMFinal))]

dds=DESeqDataSetFromMatrix(allstarFinal, infoTableFinal, design=~Fraction+factor(Batch)) ## change class
keep=rowSums(counts(dds))>(ncol(dds)/2)
dds=dds[keep, ]
dds=DESeq(dds)

vsd <- varianceStabilizingTransformation(dds)
normalizedTableVSD <- assay(vsd)

infoTableFinal$MHEpCAM=df.Spatial$MH.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$IFEpCAM=df.Spatial$IF.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$knnEpCAM=df.Spatial$knn.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$CD8Frac=df.Spatial$CD8frac[match(gsub("_", "", infoTableFinal$TumorID),rownames(df.Spatial))]

# infoTableFinal$Treatment=RNADNAsamples$Treatment[match(infoTableFinal$FqFile, RNADNAsamples$FqFile.CD45)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.Ep)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.DN)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]

save(dds, vsd,allstarFinal, allrsemFinal,allTPMFinal, normalizedTableVSD,infoTableFinal,  file=sprintf("outputs/dds_normalised_data_newstar_RNAseq_%s_rm_outliers.RData", Sys.Date()))
```

## Processing files for external software

We also process these files for external software:

Software | RNA-data
---------|---------------
PAM50 | rsem data after quantile normalised, genes converted to human
TIMER | TPM values, retain rat ids
xcell | rsem data, genes converted ti human
cibersort | tpm?? convert to rat genes and use lm22 rat


```{r, cache=T}
#load("dds_normalised_data_newstar_RNAseqmay_2020-09-16.RData")

p50_annot=read.delim("../rscript/PAM50/bioclassifier_R/pam50_annotation.txt")

# remove counts
allRSEMrm=allrsemFinal[-which(rowSums(allrsemFinal)<ncol(allrsemFinal)),]

#allRSEMrm=allRSEMrm[ ,which(colnames(allRSEMrm) %in% infoTableFinal$SampleID[infoTableFinal$Cohort!="Progression"])]

# find the quantile: we can either
# 1. include all genes
data.quantileAll <- apply(allRSEMrm, 2, function(x){quantile(x, 0.75)});
# 2. only consider the expressed genes
data.quantileExpressed <-  apply(allRSEMrm, 2, function(x){quantile(x[x>0], 0.75)});

# normalise data
allRSEMnorm1 <- t(t(allRSEMrm) / data.quantileAll)
allRSEMnorm2 <- t(t(allRSEMrm) / data.quantileExpressed)

# compare the colsums of these samples after normalisation
a1=colSums(allRSEMnorm1)
b1=colSums(allRSEMnorm2)

# par(mfrow=c(1, 2))
# hist(a1, main="all genes")
# hist(b1, main="expressed genes")

# outliers
which(a1>5E5)
which(b1>5E4)

# log transform and set infinite values to NA

allRSEMnorm1log=log2(allRSEMnorm1)
allRSEMnorm2log=log2(allRSEMnorm2)

allRSEMnorm1log[which(allRSEMnorm1log=="-Inf", arr.ind=T)]=NA
allRSEMnorm2log[which(allRSEMnorm2log=="-Inf", arr.ind=T)]=NA

# Determine the number of NAs in each row

r1NA=sapply(1:nrow(allRSEMnorm1log), function(x) length(which(is.na(allRSEMnorm1log[x, ]))))
r2NA=sapply(1:nrow(allRSEMnorm2log), function(x) length(which(is.na(allRSEMnorm2log[x, ]))))

r1idx=which(r1NA > ncol(allRSEMnorm1log)*0.4)
r2idx=which(r2NA > ncol(allRSEMnorm2log)*0.4)

# match ids

lx1=match(p50_annot$GeneName, toupper(rownames(allRSEMnorm1log)))

r1idx=setdiff(r1idx, na.omit(lx1))
r2idx=setdiff(r2idx, na.omit(lx1))

# remove the genes with NAs

allRSEMnorm1log=allRSEMnorm1log[-r1idx, ]
allRSEMnorm2log=allRSEMnorm2log[-r2idx, ]

# change the names to human gene names
mmatcha=SymHum2Rat$HGNC.symbol[match(rownames(allRSEMnorm1log), SymHum2Rat$RGD.symbol)]
mmatchb=Rat2Hum$HGNC.symbol[match(rownames(allRSEMnorm1log), Rat2Hum$RGD.symbol)]
mmc=ifelse(is.na(mmatcha)==T, mmatchb, mmatcha)

mmatch2a=SymHum2Rat$HGNC.symbol[match(rownames(allRSEMnorm2log), SymHum2Rat$RGD.symbol)]
mmatch2b=Rat2Hum$HGNC.symbol[match(rownames(allRSEMnorm2log), Rat2Hum$RGD.symbol)]
mmc2=ifelse(is.na(mmatch2a)==T, mmatch2b, mmatch2a)

rownames(allRSEMnorm1log)=ifelse(is.na(mmc), rownames(allRSEMnorm1log), mmc)
rownames(allRSEMnorm2log)=ifelse(is.na(mmc2), rownames(allRSEMnorm2log), mmc2)

# save for non-CD45 samples by batch columns
write.table(allRSEMnorm1log[ ,which(colnames(allRSEMnorm1log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allgenes_noCD45_characterisationOnly%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm1log[ ,which(colnames(allRSEMnorm1log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allgenes_noCD45_progression%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm1log[ ,which(colnames(allRSEMnorm1log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="Ep"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allgenes_epOnly_progression%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm1log[ ,which(colnames(allRSEMnorm1log)%in%infoTableFinal$SampleID[infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allgenes_noCD45_%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)

write.table(allRSEMnorm2log[ ,which(colnames(allRSEMnorm2log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allExpressedgenes_noCD45_characterisationOnly%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm2log[ ,which(colnames(allRSEMnorm2log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allExpressedgenes_noCD45_progression%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm2log[ ,which(colnames(allRSEMnorm2log)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="Ep"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allExpressedgenes_epOnly_progression%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
write.table(allRSEMnorm2log[ ,which(colnames(allRSEMnorm2log)%in%infoTableFinal$SampleID[infoTableFinal$Fraction!="CD45"])], sep="\t", file=sprintf("../output4external/RSEM_for_PAM50_allExpressedgenes_noCD45_%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)

# save specifically for EP samples
#write.table(allRSEMnorm1log[ ,grep("Ep", colnames(allRSEMnorm1log))], sep="\t", file=sprintf("../output4external/EPonly_RSEM_for_PAM50_allgenes_%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
#write.table(allRSEMnorm2log[ ,grep("Ep", colnames(allRSEMnorm2log))], sep="\t", file=sprintf("../output4external/EPonly_RSEM_for_PAM50_allExpressedgenes_%s_%s.txt", BatchNo, Sys.Date()), col.names = NA)
```


```{r data4immune, cache=T, eval=T}
Rnames=rownames(allrsemFinal)
mNames1=SymHum2Rat$HGNC.symbol[match(Rnames, SymHum2Rat$RGD.symbol)]
mNames2=Rat2Hum$HGNC.symbol[match(Rnames, Rat2Hum$RGD.symbol)]

HumNameFinal=ifelse(is.na(mNames1), mNames2, mNames1)
x1=which(is.na(HumNameFinal)==T)

## save rsem for xcell
allrsemSave=allrsemFinal[-x1, ]
rownames(allrsemSave)=na.omit(HumNameFinal)

write.table(allrsemSave, sep="\t", file=sprintf("../output4external/RSEM_for_xcell%s__%s.txt",BatchNo, Sys.Date()), col.names = NA)

## save row names for cibersort
alltpmSave=allTPMFinal[-x1, ]
rownames(alltpmSave)=na.omit(HumNameFinal)
write.table(alltpmSave, sep="\t", file=sprintf("../output4external/TPM_for_cibersort%s_%s.txt",BatchNo, Sys.Date()), col.names = NA)
```

Save the mouse names for TIMER cistrome: check that this is actually required for TIMER

```{r, cache=T, eval=F}
allTPMCD45=allTPMFinal[ , grep("CD45", colnames(allTPMFinal))]
allTPMCD45_mus_ensmbl=allTPMCD45

# Finf Rat2Mouse

midx=Rat2Mouse$MGI.symbol[match(rownames(allTPMCD45),Rat2Mouse$RGD.symbol)]
lx1=rownames(allTPMCD45)[which(is.na(midx))]
# midx2=SymHum2Rat$HGNC.symbol[match(rownames(allTPMCD45), SymHum2Rat$RGD.symbol)]
# midx2=Rat2Hum$Gene.stable.ID[match(rownames(allTPMCD45), Rat2Hum$RGD.symbol)]
# midx2=SymHum2Rat$Gene.stable.ID[match(rownames(allTPMCD45), SymHum2Rat$MGI.symbol)]
# midxAll=ifelse(is.na(midx)==T,midx2, midx)


rownames(allTPMCD45_mus_ensmbl)=midx
t3=sort(unique(midx[which(duplicated(midx)==T)]))
t3=na.omit(t3)

for (i in t3){
  x1=which(rownames(allTPMCD45_mus_ensmbl)==i)
  allTPMCD45_mus_ensmbl[x1[1], ]=colSums(allTPMCD45_mus_ensmbl[x1, ])
}

allTPMCD45_mus_ensmbl=allTPMCD45_mus_ensmbl[-which(duplicated(rownames(allTPMCD45_mus_ensmbl))), ]

allTPMCD45_mus_ensmbl=allTPMCD45_mus_ensmbl[-which(is.na(rownames(allTPMCD45_mus_ensmbl))), ]
write.csv(allTPMCD45_mus_ensmbl, file=sprintf("../output4external/CD45_TPM_mm_mgi_names%s_%s.csv", BatchNo, Sys.Date()))

write.csv(allTPMCD45, file=sprintf("../output4external/CD45_TPM_rgd_names%s_%s.csv", BatchNo, Sys.Date()))


# Write files for CIBERSORT using rgd. Use cohort specific values
allTPMCD45=allTPMFinal[ , which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort!="Progression")]

write.csv(allTPMCD45, file=sprintf("../output4external/CD45_TPM_rgd_names_char_%s.csv", Sys.Date()))
```




<!--chapter:end:03-rna-preprocessing.Rmd-->

# RNA data: preliminary plots

Prior to doing any comparative analysis, we will look at the following plots to get an overview of the data.

```{r}
# Load any required files:
load("../anntotations/Rat_biomart_gene_annotations2.RData")
#load("../dds_normalised_data_newstar_RNAseqapril_2020-11-07_rm_outliers.RData")

```

## PCA plots

We can check the new PCA plots, and overlay parameters of interest including treatment, growth, tumor size, CD8 fraction, spatial distribution.

```{r vsd-corrected,eval=T, cache=T}
vsd2 <- vst(dds)
vsd2$MHEpCAMcut=cut(infoTableFinal$MHEpCAM, c(-1, median(infoTableFinal$MHEpCAM, na.rm = T), 1.1), c("low", "high"))
vsd2$knnEpCAMcut=cut(infoTableFinal$knnEpCAM, c(-1, median(infoTableFinal$knnEpCAM, na.rm = T), 1E7), c("low", "high"))
vsd2$IFEpCAMcut=cut(infoTableFinal$IFEpCAM, c(-1, median(infoTableFinal$IFEpCAM, na.rm = T), 1.1), c("low", "high"))
vsd2$CD8FracCut=cut(infoTableFinal$CD8Frac, c(-1, median(infoTableFinal$CD8Frac, na.rm = T), 1.1), c("low", "high"))

plotPCA(vsd2, c("Treatment"))+ggtitle("Treatment")
plotPCA(vsd2, c("Growth"))+ggtitle("Growth")
plotPCA(vsd2, "TumSize")+ggtitle("tumor size")
#plotPCA(vsd2, "CD8Frac")+ggtitle("CD8 Fraction")
plotPCA(vsd2, "CD8FracCut")+ggtitle("CD8 Fraction")
plotPCA(vsd2, "SpatialManual")+ggtitle("CD8 distribution")
plotPCA(vsd2, "MHEpCAMcut")+ggtitle("MH EpCAM")
plotPCA(vsd2, "IFEpCAMcut")+ggtitle("IF SMA")
plotPCA(vsd2, "knnEpCAMcut")+ggtitle("knn EpCAM")

```


In addition, we can look at the CD45 population and the distributions based on CD8 content and spatial infiltration

```{r}
# CD8 restricted/infil
plotPCA(vsd2[ , grep("CD45", colnames(vsd2))], "CD8FracCut")+ggtitle("CD8 content")
plotPCA(vsd2[ , grep("CD45", colnames(vsd2))], "IFEpCAMcut")+ggtitle("CD8-EpCAM Infiltrating Fraction")
plotPCA(vsd2[ , grep("CD45", colnames(vsd2))], "knnEpCAMcut")+ggtitle("CD8-EpCAM nearest neighbor distances")
plotPCA(vsd2[ , grep("CD45", colnames(vsd2))], "MHEpCAMcut")+ggtitle("CD8-EpCAM MH index")
```


## Expression patterns by cell type

Below, we check whether the different fractions are expressing expected markers 

The cell types are:

* Red: Cd45
* Epcam: green 
* DN:blue

Reference Genes:

* purple: immune
* blue: epithelial
* green: stroma
* orange: myoepithelial
* red: endothelial

Below, we see that the CD45 cells separate from the Ep/DN populations have high expression of immune related genes including CD3, CD4, IFNG.

However, the DN/Ep fractions are more intermixed. The DN fraction has expression of keratins, as well as fibroblast markers (Acta1), and myeoepithelial markers (Tp63)

```{r, fig.height=6}
Agenes=unlist(GeneListRat)

# Use the original desseq data,a nd then the limma data
x1=match(Agenes, rownames(assay(vsd2)))
RatExpr2=assay(vsd2)[na.omit(x1), ]

RowSideCol=names(Agenes)[which(!is.na(x1))]
RowSideCol=substr(RowSideCol, 1, 3)

ColSideCol=sapply(strsplit(colnames(RatExpr2), "_"), function(x) x[length(x)])

#pdf("rslt/DESeq/celltype_markers_RNA.pdf", height = 6, width=10)

a1=heatmap.2(RatExpr2, col=RdBu[11:1], trace="none", RowSideColors = brewer.pal(6, "Set1")[factor(RowSideCol)], scale="row",
             ColSideColors =brewer.pal(3, "Set1")[factor(ColSideCol)] )

a1=heatmap.2(RatExpr2[, -grep("CD45", colnames(RatExpr2))], col=RdBu[11:1], trace="none", RowSideColors = brewer.pal(6, "Set1")[factor(RowSideCol)], scale="row",
             ColSideColors =brewer.pal(3, "Set1")[factor(ColSideCol[-grep("CD45", colnames(RatExpr2))])] )



# plot the heatmap col-side bar
# ColBars=rbind(factor(infoTable$Fraction[a1$colInd]), factor(infoTable$Batch[a1$colInd]))
# image(t(ColBars), col=c(1:3), main="column index", yaxt="none", xaxt="none")
# axis(2, at=c(0, 1), labels=c("cell type", "batch"), las=2)
# par(oma=c(3, 0,0,0))
# a1=heatmap.2(RatExpr2[ ,grep("2[R|N]", colnames(RatExpr2))], col=RdBu[11:1], trace="none", RowSideColors = brewer.pal(6, "Set1")[factor(RowSideCol)], scale="row")

#dev.off()
```


<!--chapter:end:04-rna-prelim.Rmd-->

# DESeq analysis

This document sets up DESeq runs to compare:

* DN vs Ep samples
* growing vs stable samples (all 3 fractions)
* treatments (all 3 fractions)
* spatial patterns (all 3 fractions)

The outputs of these analyses will be used for Gene Set Enrichment Analysis,
using MSigDB databases (c2, c5, hallmark), alongside pathways from Metacore (Process Networks, Pathway Maps)

## DN vs Ep

In section 6.2, we have noticed that some DN samples had expression of epithelial markers. Here, we perform a differential gene expression analysis to find genes which are different between these two fractions. 

Below is a summary of the number of differential genes, using p value cut off of 0.05 and log2 fold change of 1.5 and base expression of 100+.

```{r ep-v-dn, cache=T}
resDNep=results(dds, contrast=c("Fraction", "DN", "Ep"))
summary(resDNep)

print('significant differential genes')

resDNeprslt2=resDNep[which(resDNep$padj<0.05 & abs(resDNep$log2FoldChange)>1.5 &
                             resDNep$baseMean>100), ]
resDNeprslt2$CellMarker=ifelse(rownames(resDNeprslt2)%in%unlist(GeneListRat), 1, 0)
resDNeprslt2=resDNeprslt2[order(resDNeprslt2$CellMarker, abs(resDNeprslt2$log2FoldChange), decreasing = T), ]


scroll_box(kable(resDNeprslt2, format="html"),
         height="300px", width="100%")

HighExprGenes=rownames(resDNeprslt2)[which(resDNeprslt2$baseMean>100 & resDNeprslt2$log2FoldChange<0) ]

colSide=factor(infoTableFinal$Fraction[ which(infoTableFinal$Fraction!="CD45")])
colSide2=factor(infoTableFinal$Growth[ which(infoTableFinal$Fraction!="CD45")])
colSide3=factor(infoTableFinal$Treatment[ which(infoTableFinal$Fraction!="CD45")])
colSide4=cut(infoTableFinal$CD8Frac[ which(infoTableFinal$Fraction!="CD45")], c(-1, 0.025, 0.05, 0.1, 1), brewer.pal(4, "Greens"))
colSide5=cut(infoTableFinal$IFEpCAM[which(infoTableFinal$Fraction!="CD45")], c(-1, 0.05, 0.1, 0.15, 1), brewer.pal(4, "Greens"))

TableCols=rbind(palette()[colSide], palette()[colSide2], palette()[colSide3], as.character(colSide4), as.character(colSide5))
rownames(TableCols)=c("Fraction", "growth", "treatment", "cd8 fraction", "cd8 int. fraction")
colnames(TableCols)=colnames(assay(vsd2))[which(infoTableFinal$Fraction!="CD45")]

#pdf(sprintf("rslt/DESeq/difference_between_DN_ep_samples_%s.pdf", Sys.Date()), height=7, width=8)

t1=assay(vsd2)[rownames(vsd2)%in%unlist(GeneListRat), ]

heatmap.2(t1[ ,-grep("CD45", colnames(t1))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="cell type specific markers")

t2=assay(vsd2)[which(rownames(vsd2)%in%RatCosmic & rownames(vsd2)%in%rownames(resDNeprslt2)), ]
heatmap.2(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="DEG cosmic genes")

t2=assay(vsd2)[which( rownames(vsd2)%in%HighExprGenes), ]
a1=heatmap.2(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="Enriched in Ep genes")
#heatmap.2(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide2], scale="row", main="Enriched in Ep genes")

TableCols2=TableCols[ ,a1$colInd]

colOutput=melt(TableCols2)
colOutput$Var2=factor(colOutput$Var2, levels=unique(colOutput$Var2))

heatmap.plus::heatmap.plus(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = t(TableCols), scale="row", main="Enriched in Ep genes")

write.csv(resDNeprslt2, file=sprintf("outputs/DESeq/difference_between_DN_Ep(ref)_samples_%s.csv", Sys.Date()))
```

Note that there seems to be two main groups of Ep cells:

The first one is enriched for canonical tumour progression pathways: eg. expression of wnt, fox1a etc.
The second one doesn't seem to have as high expression of these genes, but have high immune related signalling pathways.

We can append this information into the overall data file and determine whether there is an association with growth or treatment

```{r}
a2=heatmap.2(t2[ ,grep("Ep", colnames(t2))], trace="none", col=RdBu[11:1], scale="row", main="Enriched in Ep genes")
ac=as.hclust(a2$colDendrogram)
ad=cutree(ac, 3)
#table(ad)
head(ad)

infoTableFinal$EpCAMsubtype=NA
infoTableFinal$EpCAMsubtype[match(names(ad), rownames(infoTableFinal))]=ad

table(infoTableFinal$EpCAMsubtype, infoTableFinal$Growth)
table(infoTableFinal$EpCAMsubtype, infoTableFinal$Treatment)
table(infoTableFinal$EpCAMsubtype, infoTableFinal$SpatialManual)

```

## No. samples in comparisons

Separate out the tables into CD45, DN and Ep fractions. Compare

1. Differences based on treatment (and treatment vs control)
2. Specific treatments vs control
3. Growing vs stable (overall)
4. Growing vs stable (in each subgroup)

Below, we check the number of samples in each subgroup:

```{r, fig.height=5}
infoTableFinal$Treatment=factor(infoTableFinal$Treatment)#[which(is.na(infoTableFinal$Treatment))]="PDL1"
infoTableFinal$SpatialManual=factor(infoTableFinal$SpatialManual)
infoTableFinal$treatA=factor(ifelse(infoTableFinal$Treatment=="Vehicle", "control", "imm"))
infoTableFinal$Comp4=factor(paste(infoTableFinal$Growth, infoTableFinal$treatA, sep=""))
infoTableFinal$MHcut=factor(ifelse(infoTableFinal$MHEpCAM>=median(infoTableFinal$MHEpCAM, na.rm = T), "inf", "res"))
infoTableFinal$IFcut=factor(ifelse(infoTableFinal$IFEpCAM>=median(infoTableFinal$IFEpCAM, na.rm = T), "inf", "res"))
infoTableFinal$knncut=factor(ifelse(infoTableFinal$knnEpCAM<=median(infoTableFinal$knnEpCAM, na.rm = T), "inf", "res"))
infoTableFinal$CD8FracCut=factor(ifelse(infoTableFinal$CD8Frac>=median(infoTableFinal$CD8Frac, na.rm = T), "high", "low"))
# infoTableFinal$MHcutComp4=factor(paste(infoTableFinal$MHcut, infoTableFinal$treatA, sep=""))
# infoTableFinal$IFcutComp4=factor(paste(infoTableFinal$IFcut, infoTableFinal$treatA, sep=""))
infoTableFinal$Growth=factor(infoTableFinal$Growth)

# print('number of samples for each treatment and growth rate')
# table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$Growth)

a1=table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$Growth)
par(mfrow=c(2,2))
ContTable(t(a1[ , , 1]), "growing", F, ylabL="fraction", xlabL="treatment")
ContTable(t(a1[ , , 2]), "stable", F, ylabL="fraction", xlabL="treatment")

a1=table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$MHcut)
ContTable(t(a1[ , , 1]), "infiltrating (MH)", F, ylabL="fraction", xlabL="treatment")
ContTable(t(a1[ , , 2]), "restricted (MH)", F, ylabL="fraction", xlabL="treatment")

a1
```

Note that based on the above tables, there some comparisons which are slightly imbalanced:

* There are few "stable" samples for comparisons
* LY samples are overwhelmingly "infiltrating"


## Set-up cell-type specifoc the comparisons

Setup the following comparisons for each cell type:

expression ~ growing + treatment + batch (exclude 1)  (start with vehicle vs some treatment)

4 categories only: immunotherapy vs non-immuno

Separate out the tables into CD45, DN and Ep fractions. Compare:

1. Treatment (EpddsTreat)
2. Comp4: Growth + any immunotherapy treatment (Epdds)
3. Comp8: Growth + immunotherapy (EpddsTreatG)
4. Growth alone: (EpddsGrowth)
5. MH index: (EpddsStrMH)
6. Interacting Fraction (EpddsStrIF) 
7. knn values (EpddsStrknn)
8. CD8 content (EpddsCD8)
9. Manual scoring spatial (EpddsSpatMan)
10. MH index + CD8 frac (Epddscd8MH)

We remove genes which have 0 counts in more than half the samples, and genes which have a row sum less than $10^{(log10(mean(rowsums))-log10(sd(rowsums)))}$.


```{r deseq-assoc-runs, cache=T}
# find epithelial samples
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="Ep" & !is.na(infoTableFinal$Growth))])
Epdds=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~Comp4+factor(Batch)) ## change class
a1x=rowSums(counts(Epdds))
a1b=apply(counts(Epdds), 1, function(c) sum(c!=0))
 # par(mfrow=c(1,2))
 # hist(log10(a1x+1), main="log10 total counts")
 # hist((a1b+1), main="Non-zero entries")
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(Epdds))>10^sd1vals)
keep2=which(apply(counts(Epdds), 1, function(c) sum(c!=0))> (ncol(Epdds)/2))
Epdds=Epdds[intersect(keep, keep2), ]
Epdds=DESeq(Epdds)

EpddsTreat=Epdds
design(EpddsTreat)=~Treatment+factor(Batch)
EpddsTreat=DESeq(EpddsTreat)

EpddsTreatG=Epdds
EpddsTreatG$Comp8=factor(paste(EpddsTreatG$Growth, EpddsTreatG$Treatment, sep="."))
design(EpddsTreatG)=~Comp8+factor(Batch)
EpddsTreatG=DESeq(EpddsTreatG)

EpddsGrowth=Epdds
design(EpddsGrowth)=~Growth+factor(Batch)  ## error is here!
EpddsGrowth=DESeq(EpddsGrowth)

EpddsStrMH=Epdds[ ,which(!is.na(Epdds$MHcut))]
design(EpddsStrMH)=~MHcut+factor(Batch)
EpddsStrMH=DESeq(EpddsStrMH)

EpddsStrIF=Epdds[ ,which(!is.na(Epdds$IFcut))]
design(EpddsStrIF)=~IFcut+factor(Batch)
EpddsStrIF=DESeq(EpddsStrIF)

EpddsStrknn=Epdds[ ,which(!is.na(Epdds$knncut))]
design(EpddsStrknn)=~knncut+factor(Batch)
EpddsStrknn=DESeq(EpddsStrknn)

Epddscd8=Epdds[ ,which(!is.na(Epdds$CD8FracCut))]
design(Epddscd8)=~CD8FracCut+factor(Batch)
Epddscd8=DESeq(Epddscd8)

# EpddsStrMHComp4=Epdds[ ,which(!is.na(Epdds$MHcut))]
# EpddsStrMHComp4$MHcutComp4<-droplevels(EpddsStrMHComp4$MHcutComp4)
# design(EpddsStrMHComp4)=~MHcutComp4+factor(Batch)
# EpddsStrMHComp4=DESeq(EpddsStrMHComp4)
# 
# EpddsStrIFComp4=Epdds[ ,which(!is.na(Epdds$IFcut))]
# EpddsStrIFComp4$IFcutComp4<-droplevels(EpddsStrIFComp4$IFcutComp4)
# design(EpddsStrIFComp4)=~IFcutComp4+factor(Batch)
# EpddsStrIFComp4=DESeq(EpddsStrIFComp4)

EpddsSpatMan=Epdds[ , which(!is.na(Epdds$SpatialManual))]
design(EpddsSpatMan)=~SpatialManual+factor(Batch)
EpddsSpatMan=DESeq(EpddsSpatMan)


Epddscd8MH=Epdds[ ,which(!is.na(Epdds$MHcut))]
Epddscd8MH$cd8MH=factor(paste(Epddscd8MH$CD8FracCut, Epddscd8MH$MHcut, sep="."))
design(Epddscd8MH)=~cd8MH+factor(Batch)
Epddscd8MH=DESeq(Epddscd8MH)

#R1=results(EpddsTreatG, contrast = list(c("Treatment_LY_vs_Vehicle", "Growthgrowing")))
## CD45 samples

cdidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="CD45" & !is.na(infoTableFinal$Growth))])
CDdds=DESeqDataSetFromMatrix(allstarFinal[ ,cdidx], infoTableFinal[cdidx, ], design=~Comp4+factor(Batch)) ## change class
a1x=rowSums(counts(CDdds))
a1b=apply(counts(CDdds), 1, function(c) sum(c!=0))
# par(mfrow=c(1,2))
# hist(log10(a1x+1), main="log10 total counts")
# hist((a1b+1), main="Non-zero entries")
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(CDdds))>10^sd1vals)
keep2=which(apply(counts(CDdds), 1, function(c) sum(c!=0))> (ncol(CDdds)/2))
CDdds=CDdds[intersect(keep, keep2), ]
CDdds=DESeq(CDdds)

CDddsTreat=CDdds
design(CDddsTreat)=~Treatment+factor(Batch)
CDddsTreat=DESeq(CDddsTreat)

CDddsTreatG=CDdds
CDddsTreatG$Comp8=factor(paste(CDddsTreatG$Growth, CDddsTreatG$Treatment, sep="."))
design(CDddsTreatG)=~Comp8+factor(Batch)
CDddsTreatG=DESeq(CDddsTreatG)

CDddsGrowth=CDdds
design(CDddsGrowth)=~Growth+factor(Batch)
CDddsGrowth=DESeq(CDddsGrowth)

CDddsStrMH=CDdds[ ,which(!is.na(CDdds$MHcut))]
design(CDddsStrMH)=~MHcut+factor(Batch)
CDddsStrMH=DESeq(CDddsStrMH)

CDddsSpatMan=CDdds[ , which(!is.na(CDdds$SpatialManual))]
design(CDddsSpatMan)=~SpatialManual+factor(Batch)
CDddsSpatMan=DESeq(CDddsSpatMan)

CDddsStrIF=CDdds[ ,which(!is.na(CDdds$IFcut))]
design(CDddsStrIF)=~IFcut+factor(Batch)
CDddsStrIF=DESeq(CDddsStrIF)

CDddsStrknn=CDdds[ ,which(!is.na(CDdds$knncut))]
design(CDddsStrknn)=~knncut+factor(Batch)
CDddsStrknn=DESeq(CDddsStrknn)

CDddscd8=CDdds[ ,which(!is.na(CDdds$CD8FracCut))]
design(CDddscd8)=~CD8FracCut+factor(Batch)
CDddscd8=DESeq(CDddscd8)

CDddscd8MH=CDdds[ ,which(!is.na(CDdds$MHcut))]
CDddscd8MH$cd8MH=factor(paste(CDddscd8MH$CD8FracCut, CDddscd8MH$MHcut, sep="."))
design(CDddscd8MH)=~cd8MH+factor(Batch)
CDddscd8MH=DESeq(CDddscd8MH)
## DN samples

DNidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="DN" & !is.na(infoTableFinal$Growth))])
DNdds=DESeqDataSetFromMatrix(allstarFinal[ ,DNidx], infoTableFinal[DNidx, ], design=~Comp4+factor(Batch)) ## change class
a1x=rowSums(counts(DNdds))
a1b=apply(counts(DNdds), 1, function(c) sum(c!=0))
# par(mfrow=c(1,2))
# hist(log10(a1x+1), main="log10 total counts")
# hist((a1b+1), main="Non-zero entries")
sd1vals=median(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(DNdds))>10^sd1vals)
keep2=which(apply(counts(DNdds), 1, function(c) sum(c!=0))> (ncol(DNdds)/2))
keep=which(rowSums(counts(DNdds))>(ncol(DNdds)))
keep2=which(apply(counts(DNdds), 1, function(c) sum(c!=0))> (ncol(DNdds)/2))
DNdds=DNdds[intersect(keep, keep2), ]
DNdds=DESeq(DNdds)

DNddsTreat=DNdds
design(DNddsTreat)=~Treatment+factor(Batch)
DNddsTreat=DESeq(DNddsTreat)

DNddsTreatG=DNdds
DNddsTreatG$Comp8=factor(paste(DNddsTreatG$Growth, DNddsTreatG$Treatment, sep="."))
design(DNddsTreatG)=~Comp8+factor(Batch)
DNddsTreatG=DESeq(DNddsTreatG)

DNddsGrowth=DNdds
design(DNddsGrowth)=~Growth+factor(Batch)
DNddsGrowth=DESeq(DNddsGrowth)

DNddsStrMH=DNdds[ ,which(!is.na(DNdds$MHcut))]
design(DNddsStrMH)=~MHcut+factor(Batch)
DNddsStrMH=DESeq(DNddsStrMH)

# DNddsStrMHComp4=DNdds[ ,which(!is.na(DNdds$MHcut))]
# DNddsStrMHComp4$MHcutComp4=droplevels(DNddsStrMHComp4$MHcutComp4)
# 
# design(DNddsStrMHComp4)=~MHcutComp4+factor(Batch)
# DNddsStrMHComp4=DESeq(DNddsStrMHComp4)

DNddsStrIF=DNdds[ ,which(!is.na(DNdds$IFcut))]
design(DNddsStrIF)=~IFcut+factor(Batch)
DNddsStrIF=DESeq(DNddsStrIF)

# DNddsStrIFComp4=DNdds[ ,which(!is.na(DNdds$IFcut))]
# DNddsStrIFComp4$IFcutComp4=droplevels(DNddsStrIFComp4$IFcutComp4)
# design(DNddsStrIFComp4)=~IFcutComp4+factor(Batch)
# DNddsStrIFComp4=DESeq(DNddsStrIFComp4)

DNddsSpatMan=DNdds[ , which(!is.na(DNdds$SpatialManual))]
design(DNddsSpatMan)=~SpatialManual+factor(Batch)
DNddsSpatMan=DESeq(DNddsSpatMan)

DNddsStrknn=DNdds[ ,which(!is.na(DNdds$knncut))]
design(DNddsStrknn)=~knncut+factor(Batch)
DNddsStrknn=DESeq(DNddsStrknn)

DNddscd8=DNdds[ ,which(!is.na(DNdds$CD8FracCut))]
design(DNddscd8)=~CD8FracCut+factor(Batch)
DNddscd8=DESeq(DNddscd8)


DNddscd8MH=DNdds[ ,which(!is.na(DNdds$MHcut))]
DNddscd8MH$cd8MH=factor(paste(DNddscd8MH$CD8FracCut, DNddscd8MH$MHcut, sep="."))
design(DNddscd8MH)=~cd8MH+factor(Batch)
DNddscd8MH=DESeq(DNddscd8MH)

save(Epdds, EpddsTreat,CDdds, CDddsTreat, DNdds, DNddsTreat,
     EpddsTreatG, CDddsTreatG, DNddsTreatG, EpddsGrowth, CDddsGrowth, DNddsGrowth, 
     DNddsStrknn, DNddsStrIF, DNddscd8, DNddscd8MH, DNddsStrMH,
     CDddsStrknn, CDddsStrIF, CDddscd8, CDddscd8MH, CDddsStrMH,
     EpddsStrknn, EpddsStrIF, Epddscd8, Epddscd8MH, EpddsStrMH,
     EpddsSpatMan, CDddsSpatMan, DNddsSpatMan,
     file=sprintf("outputs/subfraction_analysis_%s.RData", Sys.Date()))

# Alist=results(EpddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))
# Clist=results(CDddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))
# Dlist=results(DNddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))

#load("rslt/DESeq/subfraction_analysis_2020-09-29.RData")
#write.csv(a2, sprintf("rslt/DESeq/Spatial_Manual_comparison_%s.csv", Sys.Date()))
```

These comparisons are saved in the temporary outputfile `r sprintf("outputs/subfraction_analysis_%s.RData", Sys.Date())`. In each comparison, there are 
`r nrow(Epdds); nrow(CDdds); nrow(DNdds)` genes compared.


```{r deseq-spatManual, cache=T, eval=F}
FractionTest="CD45"
# infoTableFinal$MHEpCAMcut=cut(infoTableFinal$MHEpCAM, c(-1, median(infoTableFinal$MHEpCAM, na.rm = T), 1.1), c("low", "high"))
 infoTableFinal$knnEpCAMcut=cut(infoTableFinal$knnEpCAM, c(-1, median(infoTableFinal$knnEpCAM, na.rm = T), 1E7), c("low", "high"))
# infoTableFinal$IFEpCAMcut=cut(infoTableFinal$IFEpCAM, c(-1, median(infoTableFinal$IFEpCAM, na.rm = T), 1.1), c("low", "high"))
 infoTableFinal$CD8FracCut=cut(infoTableFinal$CD8Frac, c(-1, median(infoTableFinal$CD8Frac, na.rm = T), 1.1), c("low", "high"))

EpSpatialddsList=list()

epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction==FractionTest & !is.na(infoTableFinal$MHcut))])
EpddsMH=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~MHcut) ## change class
EpSpatialddsList[[1]]=DESeq(EpddsMH)
EpddsIF=EpddsMH
design(EpddsIF)=~IFcut
EpSpatialddsList[[2]]=DESeq(EpddsIF)
Epddsknn=EpddsMH
design(Epddsknn)=~knnEpCAMcut
EpSpatialddsList[[3]]=DESeq(Epddsknn)
Epddscd8=EpddsMH
design(Epddscd8)=~CD8FracCut
EpSpatialddsList[[4]]=DESeq(Epddscd8)
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction==FractionTest & !is.na(infoTableFinal$SpatialManual))])
EpddsSM=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~SpatialManual) ## change class
EpSpatialddsList[[5]]=DESeq(EpddsSM)


#run the summaries?
Rlist=lapply(EpSpatialddsList, results)
RlistSum=lapply(Rlist, summary)
DiffGenes1=lapply(Rlist, function(x) x$log2FoldChange[which(x$padj<0.1 & abs(x$log2FoldChange)>1.5 & x$baseMean>50)])
DiffGenes2=lapply(Rlist, function(x) rownames(x)[which(x$padj<0.1 & abs(x$log2FoldChange)>1.5 & x$baseMean>50)])
DiffGenes1[[5]]=DiffGenes1[[5]]*(-1)
DiffGenes1[[3]]=DiffGenes1[[3]]*(-1)

#DiffGenes2=lapply(1:length(Rlist), function(x) {names(DiffGenes[[x]])<-rownames(Rlist[[x]])[which(Rlist[[x]]$padj<0.05 & abs(Rlist[[x]]$log2FoldChange)>1.5 & Rlist[[x]]$baseMean>50)]; DiffGenes[[x]]})
names(DiffGenes1)=c("MH", "IF", "knn", "CD8", "SpatMan")
names(DiffGenes2)=c("MH", "IF", "knn", "CD8", "SpatMan")
lxa=melt(DiffGenes1)
lxb=melt(DiffGenes2)
lx=cbind(lxa, lxb)
lx=lx[ ,-4]
colnames(lx)=c("value", "L1", "Gene")
lxTable=acast(lx, Gene~L1)
lxTable[which(is.na(lxTable), arr.ind = T)]=0

lxTableRS=rowSums(abs(sign(lxTable)))
idx=which(lxTableRS>0)

#pdf(sprintf("rslt/DESeq/Spatial_DEG_common_%s_%s.pdf", FractionTest, Sys.Date()), width = 14, height=6)
heatmap.2(t(lxTable[idx, ]), trace="none",scale="none", col=RdBu[11:1], main=sprintf("diffGenes fold change: %s Blue:low/rest, Red:high/infil ", FractionTest))
par(mfrow=c(1,2))
venn(DiffGenes2[1:3])
venn(DiffGenes2[c(1, 4:5)])
intersect(DiffGenes1[[1]], DiffGenes1[[2]])
intersect(intersect(DiffGenes2[[1]], DiffGenes2[[4]]), DiffGenes2[[5]])
#dev.off()

genelist1=rownames(Rlist[[1]])
midx=lapply(Rlist, function(x) match(rownames(x), genelist1))

df.All.save=cbind(Rlist[[1]][midx[[1]], c(1,2, 5:6) ], Rlist[[2]][midx[[2]], c(2, 5:6)], 
                  Rlist[[3]][midx[[3]], c(2, 5:6)],Rlist[[4]][midx[[4]], c(2, 5:6)],
                  Rlist[[5]][midx[[5]], c(2, 5:6)])
colnames(df.All.save)[2:ncol(df.All.save)]=paste(rep(names(DiffGenes1), each=3), colnames(df.All.save)[2:ncol(df.All.save)])

write.csv(df.All.save, file=sprintf("outputs/DESeq/DEG_spatial_manual_%s_%s.csv", FractionTest, Sys.Date()))

TestInput=read.csv(sprintf("outputs/DESeq/DEG_spatial_manual_%s_%s.csv", FractionTest, Sys.Date()), row.names = 1)
a1=match(lm22rat$Gene.symbol, rownames(TestInput))
TestInput$LM22gene=""
TestInput$LM22gene[na.omit(a1)]=1
write.csv(TestInput, "outputs/DEG_spatial_manual_Ep_2020-10-14_annot_Imm_genes.csv")
```

## PCA plots

Below, we look at PCA plots with information on treatment, growth, spatial patterns overlaid. 

These are separated based on cell type

### EpCAM

```{r}
#pdf(sprintf("rslt/DESeq/Sample_specific_PCA_%s.pdf", Sys.Date()), height=9, width=9)
Epdds$cd8MH=paste(Epdds$CD8FracCut, Epdds$MHcut)

vstEp=vst(Epdds, blind=T)
plotPCA(vstEp, intgroup=c("Treatment"))+geom_text(aes(label=colnames(vstEp)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep population: treatment")
plotPCA(vstEp, intgroup=c("Treatment", "Growth"))+geom_text(aes(label=colnames(vstEp)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep population: treatment + growth")
plotPCA(vstEp, intgroup=c("Comp4"))+geom_text(aes(label=colnames(vstEp)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep treatment (immune vs control) + growth")
plotPCA(vstEp, intgroup=c("Growth"))+geom_text(aes(label=Epdds$TumSize),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep population: growth: kinetics vs final tum size")
plotPCA(vstEp, intgroup=c("MHcut"))+geom_text(aes(label=Epdds$MHEpCAM),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep population: MH ep to stroma index")
plotPCA(vstEp, intgroup=c("IFcut"))+geom_text(aes(label=Epdds$IFEpCAM),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("Ep population: IF ep to stroma index")
plotPCA(vstEp, intgroup=c("cd8MH"))+geom_text(aes(label=Epdds$cd8MH),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: cd8 + MH")
```

### CD45

```{r}
CDdds$cd8MH=paste(CDdds$CD8FracCut, CDdds$MHcut)

vstCD=vst(CDdds, blind=T)
plotPCA(vstCD, intgroup=c("Treatment"))+geom_text(aes(label=colnames(vstCD)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: treatment")
plotPCA(vstCD, intgroup=c("Treatment", "Growth"))+geom_text(aes(label=colnames(vstCD)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: treatment + growth")
plotPCA(vstCD, intgroup=c("Comp4"))+geom_text(aes(label=colnames(vstCD)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("CD45 treatment (immune vs control) + growth")
plotPCA(vstCD, intgroup=c("Growth"))+geom_text(aes(label=CDdds$TumSize),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: growth: kinetics vs final tum size")
plotPCA(vstCD, intgroup=c("MHcut"))+geom_text(aes(label=CDdds$MHEpCAM),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("CD45 treatment MH value")
plotPCA(vstCD, intgroup=c("IFcut"))+geom_text(aes(label=CDdds$IFEpCAM),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: IF value")
plotPCA(vstCD, intgroup=c("cd8MH"))+geom_text(aes(label=CDdds$cd8MH),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: cd8 + MH")
```

### DN

```{r}
DNdds$cd8MH=paste(DNdds$CD8FracCut, DNdds$MHcut)

vstDN=vst(DNdds, blind=T)
plotPCA(vstDN, intgroup=c("Treatment"))+geom_text(aes(label=colnames(vstDN)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("DN population: treatment ")
plotPCA(vstDN, intgroup=c("Treatment", "Growth"))+geom_text(aes(label=colnames(vstDN)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("DN population: treatment + growth")
plotPCA(vstDN, intgroup=c("Comp4"))+geom_text(aes(label=colnames(vstDN)),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("DN treatment (immune vs control) + growth")
plotPCA(vstDN, intgroup=c("Growth"))+geom_text(aes(label=DNdds$TumSize),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("DN population: growth: kinetics vs final tum size")
plotPCA(vstDN, intgroup=c("MHcut"))+geom_text(aes(label=DNdds$MHEpCAM),vjust=1,check_overlap = TRUE,size = 4)+ggtitle("DN treatment (immune vs control) + growth")
plotPCA(vstDN, intgroup=c("IFcut"))+geom_text(aes(label=DNdds$IFEpCAM),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("DN population: growth: kinetics vs final tum size")
plotPCA(vstDN, intgroup=c("cd8MH"))+geom_text(aes(label=DNdds$cd8MH),vjust=2,check_overlap = TRUE,size = 4)+ggtitle("CD45 population: cd8 + MH")
#dev.off()

```


## Collating results and running GSEA

In this section, we combine all the comparisons together for downstream analysis, including

* number of differential genes per comparisons
* number of samples per comparison
* write the output to file (outputs/DESeq/Ep_growth_treat.xlsx)

For GSEA we

* convert rat to human symbols
* run overlap analysis if there are more than 3 hits (outputs/DESeq/HyperGeo_Ep_growth_treat.xlsx)
* run gene set enrichment analysis on all samples (outputs/DESeq/GSEA_Ep_growth_treat.xlsx)
* all outputs saved to outputs/all_differential_comparisons.RData)

```{r}
#load("rslt/DESeq/Epithelial_fraction.RData")

table(Epdds$Comp4)

xsearch=c("stablecontrol","growingimm",  "stableimm", "stableimm")
ysearch=c("growingcontrol","growingcontrol",  "stablecontrol", "growingimm")

## for treatment control: big differences here which are not replicated

EpComp4=list()
EpCompSig=list()
UpDn1=matrix(NA, nrow=2, ncol=21)

for (i in 1:4){
Eres1=results(Epdds, contrast=c("Comp4", xsearch[i], ysearch[i]))
EpComp4[[i]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
EpCompSig[[i]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
UpDn1[ ,i]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(EpddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
EpComp4[[i+4]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[i+4]]=g1
UpDn1[ ,i+4]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

xsearchA=c("stable.Vehicle","stable.LY",  "stable.PDL1+LY", "stable.PDL1")
ysearchB=c("growing.Vehicle","growing.LY",  "growing.PDL1+LY", "growing.PDL1")


for (i in 1:4){
Eres5=results(EpddsTreatG, contrast=c("Comp8", xsearchA[i], ysearchB[i]))
EpComp4[[i+7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[i+7]]=g1
UpDn1[ ,i+7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}


Eres5=results(EpddsGrowth, contrast=c("Growth", "stable", "growing"))
EpComp4[[12]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[12]]=g1
UpDn1[ ,12]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))



Eres5=results(EpddsStrMH, contrast=c("MHcut", "res", "inf"))
EpComp4[[13]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[13]]=g1
UpDn1[ ,13]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(EpddsStrIF, contrast=c("IFcut", "res", "inf"))
EpComp4[[14]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[14]]=g1
UpDn1[ ,14]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(EpddsStrknn, contrast=c("knncut", "res", "inf"))
EpComp4[[15]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[15]]=g1
UpDn1[ ,15]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(Epddscd8, contrast=c("CD8FracCut", "low", "high"))
EpComp4[[16]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[16]]=g1
UpDn1[ ,16]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(EpddsSpatMan, contrast=c("SpatialManual", "Infiltrating", "restricted"))
EpComp4[[17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[17]]=g1
UpDn1[ ,17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

xsearchC=c("low.inf","high.inf",  "low.inf", "low.res")
ysearchD=c("low.res","high.res", "high.inf", "high.res")

for (i in 1:4){
Eres5=results(Epddscd8MH, contrast=c("cd8MH", xsearchC[i], ysearchD[i]))
EpComp4[[i+17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[i+17]]=g1
UpDn1[ ,i+17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

#boxplot(assay(Epdds)["Snca", ]~Epdds$treatA+Epdds$Growth)

rownames(UpDn1)=c("down", "up")
colnames(UpDn1)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")
names(EpComp4)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")
names(EpCompSig)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")

## write to a xls
write_xlsx(EpComp4, path=sprintf("outputs/DESeq/Ep_growth_treat.xlsx"))
```


```{r run-gsea, cache=T}
#load("anntotations/Rat_biomart_gene_annotations.RData")

epGenes=rownames(Epdds)
cdGenes=rownames(CDdds)
dnGenes=rownames(DNdds)

l1=SymHum2Rat$HGNC.symbol[match(epGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(epGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(epGenes, Mouse2Hum$MGI.symbol)]
epGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, epGenes)))

l1=SymHum2Rat$HGNC.symbol[match(cdGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(cdGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(cdGenes, Mouse2Hum$MGI.symbol)]
cdGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, cdGenes)))

l1=SymHum2Rat$HGNC.symbol[match(dnGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(dnGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(dnGenes, Mouse2Hum$MGI.symbol)]
dnGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, dnGenes)))

```


```{r}
load("../anntotations/ListofGeneSets2.RData")
```

```{r ep-samples-gsea, cache=T, results='hide', warning=F, message=F}
#save(ListGSC, file="anntotations/ListofGeneSets2.RData")
OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(EpComp4)*2, nrow=length(x)))
ismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
ismrB<-ismr3 

for (i in 1:length(EpComp4)){

hits=EpCompSig[[i]]
hits=epGenesConv[match(hits, rownames(Epdds))]
fcTab=EpComp4[[i]]$log2FoldChange
names(fcTab)=epGenesConv


if (length(hits)>2){
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca=GSCA(listOfGeneSetCollections=ListGSC, geneList=fcTab)
  gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(ismr3[[j]]))
  ismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}

if (length(hits)>2){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(ismrB[[j]]))
  ismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}


}

Epismr3 <- lapply(ismr3, function(x){ colnames(x)<- paste(rep(names(EpComp4), each=2), c("NES", "padj")); x})
names(Epismr3)=names(ListGSC)
Epismr3<-lapply(Epismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(Epismr3, path=sprintf("outputs/DESeq/GSEA_Ep_growth_treat_%s.xlsx", Sys.Date()))

EpismrHG <- lapply( ismrB, function(x){ colnames(x)<- paste(rep(names(EpComp4), each=2), c("pval", "padj")); x})
names(EpismrHG)=names(ListGSC)
EpismrHG<-lapply(EpismrHG, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(EpismrHG, path=sprintf("outputs/DESeq/HyperGeo_Ep_growth_treat_%s.xlsx", Sys.Date()))
```


```{r cd45-samples-gsea, results='hide', warning=F, message=F, cache=T}
#load("rslt/DESeq/Epithelial_fraction.RData")

table(CDdds$Comp4)

xsearch=c("stablecontrol","growingimm",  "stableimm", "stableimm")
ysearch=c("growingcontrol","growingcontrol",  "stablecontrol", "growingimm")

## for treatment control: big differences here which are not replicated

CDComp4=list()
CDCompSig=list()
CDUpDn1=matrix(NA, nrow=2, ncol=21)

for (i in 1:4){
Eres1=results(CDdds, contrast=c("Comp4", xsearch[i], ysearch[i]))
CDComp4[[i]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
CDCompSig[[i]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
CDUpDn1[ ,i]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(CDddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
CDComp4[[i+4]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[i+4]]=g1
CDUpDn1[ ,i+4]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

xsearchA=c("stable.Vehicle","stable.LY",  "stable.PDL1+LY", "stable.PDL1")
ysearchB=c("growing.Vehicle","growing.LY",  "growing.PDL1+LY", "growing.PDL1")


for (i in 1:4){
Eres5=results(CDddsTreatG, contrast=c("Comp8", xsearchA[i], ysearchB[i]))
CDComp4[[i+7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[i+7]]=g1
CDUpDn1[ ,i+7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

#boxplot(assay(CDdds)["Snca", ]~CDdds$treatA+CDdds$Growth)

Eres5=results(CDddsGrowth, contrast=c("Growth", "stable", "growing"))
CDComp4[[12]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[12]]=g1
CDUpDn1[ ,12]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(CDddsStrMH, contrast=c("MHcut", "res", "inf"))
CDComp4[[13]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[13]]=g1
CDUpDn1[ ,13]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(CDddsStrIF, contrast=c("IFcut", "res", "inf"))
CDComp4[[14]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[14]]=g1
CDUpDn1[ ,14]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(CDddsStrknn, contrast=c("knncut", "res", "inf"))
CDComp4[[15]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[15]]=g1
CDUpDn1[ ,15]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(CDddscd8, contrast=c("CD8FracCut", "low", "high"))
CDComp4[[16]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[16]]=g1
CDUpDn1[ ,16]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(CDddsSpatMan, contrast=c("SpatialManual", "Infiltrating", "restricted"))
CDComp4[[17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[17]]=g1
CDUpDn1[ ,17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

xsearchC=c("low.inf","high.inf",  "low.inf", "low.res")
ysearchD=c("low.res","high.res", "high.inf", "high.res")

for (i in 1:4){
Eres5=results(CDddscd8MH, contrast=c("cd8MH", xsearchC[i], ysearchD[i]))
CDComp4[[i+17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[i+17]]=g1
CDUpDn1[ ,i+17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}


rownames(CDUpDn1)=c("down", "up")
colnames(CDUpDn1)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")
names(CDComp4)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")
names(CDCompSig)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")

## write to a xls
write_xlsx(CDComp4, path=sprintf("outputs/DESeq/CD_growth_treat_%s.xlsx", Sys.Date()))

OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(CDComp4)*2, nrow=length(x)))
CDismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
CDismrB=CDismr3
for (i in 1:length(CDComp4)){

hits=CDCompSig[[i]]
hits=cdGenesConv[match(hits, rownames(CDdds))]
fcTab=CDComp4[[i]]$log2FoldChange
names(fcTab)=cdGenesConv


if (length(hits)>3){
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(CDismr3[[j]]))
  CDismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}

if (length(hits)>3){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(CDismrB[[j]]))
  CDismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}

}

CDismr3 <- lapply(CDismr3, function(x){ colnames(x)<- paste(rep(names(CDComp4), each=2), c("NES", "padj")); x})
names(CDismr3)=names(ListGSC)
CDismr3<-lapply(CDismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(CDismr3, path=sprintf("outputs/DESeq/GSEA_CD_growth_treat.xlsx"))


CDismrB <- lapply(CDismrB, function(x){ colnames(x)<- paste(rep(names(CDComp4), each=2), c("pval", "padj")); x})
names(CDismrB)=names(ListGSC)
CDismrB<-lapply(CDismrB, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(CDismrB, path=sprintf("outputs/DESeq/HyperGeom_CD_growth_treat.xlsx"))
```


```{r dn-samples-gsea, cache=T, results='hide', warning=F, message=F}
#load("rslt/DESeq/Epithelial_fraction.RData")

table(DNdds$Comp4)

xsearch=c("stablecontrol","growingimm",  "stableimm", "stableimm")
ysearch=c("growingcontrol","growingcontrol",  "stablecontrol", "growingimm")

## for treatment control: big differences here which are not replicated

DNComp4=list()
DNCompSig=list()
DNUpDn1=matrix(NA, nrow=2, ncol=21)

for (i in 1:4){
Eres1=results(DNdds, contrast=c("Comp4", xsearch[i], ysearch[i]))
DNComp4[[i]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
DNCompSig[[i]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
DNUpDn1[ ,i]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(DNddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
DNComp4[[i+4]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[i+4]]=g1
DNUpDn1[ ,i+4]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

xsearchA=c("stable.Vehicle","stable.LY",  "stable.PDL1+LY", "stable.PDL1")
ysearchB=c("growing.Vehicle","growing.LY",  "growing.PDL1+LY", "growing.PDL1")


for (i in 1:4){
Eres5=results(DNddsTreatG, contrast=c("Comp8", xsearchA[i], ysearchB[i]))
DNComp4[[i+7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[i+7]]=g1
DNUpDn1[ ,i+7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

boxplot(assay(DNdds)["Snca", ]~DNdds$treatA+DNdds$Growth)

Eres5=results(DNddsGrowth, contrast=c("Growth", "stable", "growing"))
DNComp4[[12]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[12]]=g1
DNUpDn1[ ,12]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(DNddsStrMH, contrast=c("MHcut", "res", "inf"))
DNComp4[[13]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[13]]=g1
DNUpDn1[ ,13]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(DNddsStrIF, contrast=c("IFcut", "res", "inf"))
DNComp4[[14]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[14]]=g1
DNUpDn1[ ,14]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(DNddsStrknn, contrast=c("knncut", "res", "inf"))
DNComp4[[15]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[15]]=g1
DNUpDn1[ ,15]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(DNddscd8, contrast=c("CD8FracCut", "low", "high"))
DNComp4[[16]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[16]]=g1
DNUpDn1[ ,16]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(DNddsSpatMan, contrast=c("SpatialManual", "Infiltrating", "restricted"))
DNComp4[[17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[17]]=g1
DNUpDn1[ ,17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

xsearchC=c("low.inf","high.inf",  "low.inf", "low.res")
ysearchD=c("low.res","high.res", "high.inf", "high.res")

for (i in 1:4){
Eres5=results(DNddscd8MH, contrast=c("cd8MH", xsearchC[i], ysearchD[i]))
DNComp4[[i+17]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[i+17]]=g1
DNUpDn1[ ,i+17]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

rownames(DNUpDn1)=c("down", "up")
colnames(DNUpDn1)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")

  #c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"),"stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF")


names(DNComp4)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")

  #c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"),"stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF")
names(DNCompSig)=c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"), "stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF", "res_vs_inf.knn", "lo_vs_hi_cd8", "inf_vs_res.SpatMan", "low.inf_vs_low.res.cd8.mh",  "hi.inf_vs_hi.res.cd8.mh",  "low.inf_vs_hi.inf.cd8.mh",  "low.res_vs_hi.res.cd8.mh")

#c(paste(xsearch, "vs", ysearch, sep="_"), paste(cList, "_vs_Vehicle", sep=""), paste(xsearchA, "vs", ysearchB, sep="_"),"stable_vs_growing", "res_vs_inf.MH", "res_vs_inf.IF")

## write to a xls
write_xlsx(DNComp4, path=sprintf("outputs/DN_growth_treat.xlsx"))

OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(DNComp4)*2, nrow=length(x)))
DNismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
DNismrB=DNismr3

for (i in 1:length(DNComp4)){

hits=DNCompSig[[i]]
hits=dnGenesConv[match(hits, rownames(DNdds))]
fcTab=DNComp4[[i]]$log2FoldChange
names(fcTab)=dnGenesConv

gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
if (length(hits)>0){
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(DNismr3[[j]]))
  DNismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}


if (length(hits)>2){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(DNismrB[[j]]))
  DNismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}


}

DNismr3 <- lapply(DNismr3, function(x){ colnames(x)<- paste(rep(names(DNComp4), each=2), c("NES", "padj")); x})
names(DNismr3)=names(ListGSC)
DNismr3<-lapply(DNismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(DNismr3, path=sprintf("outputs/GSEA_DN_growth_treat.xlsx"))

DNismrB <- lapply(DNismrB, function(x){ colnames(x)<- paste(rep(names(DNComp4), each=2), c("pval", "padj")); x})
names(DNismrB)=names(ListGSC)
DNismrB<-lapply(DNismrB, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(DNismrB, path=sprintf("outputs/DESeq/HyperGeom_DN_growth_treat.xlsx"))


save(DNComp4, EpComp4, CDComp4, DNismr3,Epismr3, CDismr3,DNismrB, EpismrHG, CDismrB,
     DNCompSig, EpCompSig, CDCompSig, UpDn1, CDUpDn1, DNUpDn1, file="outputs/all_differential_comparisons.RData")
```


```{r, eval=F}

load("anntotations/Rat_biomart_gene_annotations.RData")

PathInH=getGmt(con="anntotations/h.all.v7.1.symbols.gmt", geneIdType=SymbolIdentifier(),
                collectionType=BroadCollection(category="h"))

HallmarkNames=unique(unlist(geneIds(PathInH)))

## change the HallmarkNames to rat

RatHallmark=SymHum2Rat$RGD.symbol[match(HallmarkNames, SymHum2Rat$HGNC.symbol)]
RatHallmark2=Rat2Hum$RGD.symbol[match(HallmarkNames, Rat2Hum$HGNC.symbol)]

RatUn=na.omit(unique(c(RatHallmark, RatHallmark2)))

midx=sapply(EpCompSig, function(x) intersect(x, RatUn))

mUnique2=unique(unlist(midx))

ColsideCols=DiffCols[EpddsTreatG$Comp8_v2]
ColsideColsB=hue_pal()(4)[EpddsTreatG$Treatment]
ColsideColsC=hue_pal()(2)[EpddsTreatG$Growth]

colTable=rbind(ColsideCols, ColsideColsB, ColsideColsC)
rownames(colTable)=c("Treat+growth", "Treatment", "growth")

x1=match(c("2N__Ep", "NMU12_RL_Ep", "10L_D_Ep", "3N_B_Ep"), colnames(vstEp))

heatmap.plus(assay(vstEp)[mUnique2, ], trace="none", scale="none", col=RdBu[11:1], ColSideColors = t(colTable), main=sprintf("Hallmark genes %s", SampleFrac))


```

<!--chapter:end:05-deseqruns.Rmd-->

# DESeq analysis

## Summary of comparisons

```{r}
#load("rslt/DESeq/all_differential_comparisons.RData")
#load("outputs/subfraction_analysis_2020-11-07.RData")
```

Quick plot of the differences in number of differential genes:

```{r}
Allchanges=rbind(UpDn1, CDUpDn1, DNUpDn1)
Allchanges=cbind(Allchanges, Frac=c("Ep", "Ep", "CD", "CD", "DN", "DN"), dir=rownames(Allchanges))

AllchangesB=melt(as.data.frame(Allchanges), id.vars = c("Frac", "dir"))

ggplot(AllchangesB, aes(x=variable, y=as.numeric(value), fill=dir))+geom_bar(stat="identity",position = "dodge")+facet_grid(Frac~., scale="free_y", space="free_y")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ylab("No. differential genes")+ggtitle("number of differential genes")+scale_y_log10()
## plot the number of samples in each comparison

Nsamp=matrix(NA, nrow=6, ncol=ncol(Allchanges))
ta=table(Epdds$Comp4)
tb=table(CDdds$Comp4)
tc=table(DNdds$Comp4)

for (i in 1:4){
  Nsamp[1:2, i]=c(ta[xsearch[i]], ta[ysearch[i]])
  Nsamp[3:4, i]=c(tb[xsearch[i]], tb[ysearch[i]])
  Nsamp[5:6, i]=c(tc[xsearch[i]], tc[ysearch[i]])
}

ta=table(Epdds$Treatment)
tb=table(CDdds$Treatment)
tc=table(DNdds$Treatment)

for (i in 1:3){
  Nsamp[1:2, i+4]=c(ta[cList[i]], ta["Vehicle"])
  Nsamp[3:4, i+4]=c(tb[cList[i]], tb["Vehicle"])
  Nsamp[5:6, i+4]=c(tc[cList[i]], tc["Vehicle"])
}

ta=table(EpddsTreatG$Comp8)
tb=table(CDddsTreatG$Comp8)
tc=table(DNddsTreatG$Comp8)

for (i in 1:4){
  Nsamp[1:2, i+7]=c(ta[xsearchA[i]], ta[ysearchB[i]])
  Nsamp[3:4, i+7]=c(tb[xsearchA[i]], tb[ysearchB[i]])
  Nsamp[5:6, i+7]=c(tc[xsearchA[i]], tc[ysearchB[i]])
}

Nsamp[ ,12]=c(table(EpddsGrowth$Growth), table(CDddsGrowth$Growth), table(DNddsGrowth$Growth))
Nsamp[ ,13]=c(table(EpddsStrMH$MHcut), table(CDddsStrMH$MHcut), table(DNddsStrMH$MHcut))
Nsamp[ ,14]=c(table(EpddsStrIF$IFcut), table(CDddsStrIF$IFcut), table(DNddsStrIF$IFcut))
Nsamp[ ,15]=c(table(EpddsStrknn$knncut), table(CDddsStrknn$knncut), table(DNddsStrknn$knncut))
Nsamp[ ,16]=c(table(Epddscd8$CD8FracCut), table(CDddscd8$CD8FracCut), table(DNddscd8$CD8FracCut))
Nsamp[ ,17]=c(table(EpddsSpatMan$SpatialManual), table(CDddsSpatMan$SpatialManual), table(DNddsSpatMan$SpatialManual))

ta=table(Epddscd8MH$cd8MH)
tb=table(CDddscd8MH$cd8MH)
tc=table(DNddscd8MH$cd8MH)


for (i in 1:4){
  Nsamp[1:2, i+17]=c(ta[xsearchC[i]], ta[ysearchD[i]])
  Nsamp[3:4, i+17]=c(tb[xsearchC[i]], tb[ysearchD[i]])
  Nsamp[5:6, i+17]=c(tc[xsearchC[i]], tc[ysearchD[i]])
}

colnames(Nsamp)=colnames(Allchanges)
Nsamp[ , 22:23]=Allchanges[ ,22:23]


Nsamp2=melt(as.data.frame(Nsamp), id.vars=c("Frac", "dir"))

ggplot(Nsamp2, aes(x=variable, y=as.numeric(value), fill=dir))+geom_bar(stat="identity",position = "dodge")+facet_grid(Frac~., scale="free_y", space="free")+theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_fill_discrete(name = "Comparison", labels = c("numerator", "reference"))+ylab("No. samples in comparison")+ggtitle("number of samples in comparison")

#dev.off()
```

Notes:

Comparison Type | Main cell type impacted
----------------|-----------------------
Treatment | CD45+, PDL1+LY in the DN, LY may affect Ep
growth | Ep and CD45
growth in control | CD and DN
Spatial Patterns | CD45, Ep
Spatial, high cd8 | all cases

## Summary of comaprisons

Pearson correlation:

* Pearson correlation of all the samples
* Unlist all genes, and pick out genes which are impacted in at least 1 comparison, and base expression >100
* columns are colored by: Spatial Distribution (MH),  Growth, Treatment, CD8 content

Differential genes:

* top 100 variable genes
* DEG in at least 2 samples
* differential genes in each comparison shown

Gene sets:

* c2, c5, Process networks, metacore, hallmark

### EPCAM samples

Note that there are a subset of samples different from the other based on CD8, growth and MH index (6RB, 3NB, 10LD, 8LD, 11ND) but these parameters don't group the other samples well


There is a small subset of samples which have high expression of CCls and based on the top variable genes, there seems to be three types of epithelial cases. 

```{r}
SampleFrac="Ep"

allEpGenes=unlist(EpCompSig)
allEpTab=table(allEpGenes)
EpGenesList=names(allEpTab)[which(allEpTab>1)]
#EpGenesList=EpGenesList[-grep("LOC", EpGenesList)]
#EpGenesList=EpGenesList[-grep("RGD", EpGenesList)]
# also, remove all samples which have a base mean less than 10
x1=EpComp4[[1]]$baseMean[match(EpGenesList, EpComp4[[1]]$Gene)]
x2=which(x1>100)
vstEp=vst(Epdds, blind=T)

#EpddsTreatG$Comp8_v2=factor(paste(EpddsTreatG$Treatment, EpddsTreatG$Growth))

ColsideCols=hue_pal()(2)[Epdds$CD8FracCut]
ColsideColsB=hue_pal()(4)[Epdds$Treatment]
ColsideColsC=hue_pal()(2)[Epdds$Growth]
ColsideColsD=hue_pal()(2)[Epdds$MHcut]

colTable=rbind(ColsideCols, ColsideColsB, ColsideColsC, ColsideColsD)
rownames(colTable)=c("CD8", "Treatment", "growth", "MH")

#pdf(sprintf("rslt/DESeq/DEseq_comparisons_%s.pdf", SampleFrac), width=7, height=10)

sampleDist=dist(t(assay(vstEp)))
sampleDistMatrix <- as.matrix(sampleDist)
heatmap.plus(sampleDistMatrix, trace="none", scale="none", col=brewer.pal(9, "Blues")[9:1], ColSideColors = t(colTable), main=sprintf("Similarity between %s samples", SampleFrac))

# Take the top 150 variable genes 
# compute the sds for each genes
sds = rowSds(assay(vstEp))
means=rowMeans(assay(vstEp))
CVs=sds/means
CVs=CVs[-which(means<7)]
sds2=sort(CVs, decreasing = T)

heatmap.plus(assay(vstEp)[names(sds2)[1:100], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable), main=sprintf("top 100 variable genes all %s samples", SampleFrac))


heatmap.plus(assay(vstEp)[EpGenesList[x2], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),
          main=sprintf("DEG at least 2 %s samples", SampleFrac))

# Make a table for these genes
FCvalues=matrix(NA, nrow=length(x2), ncol=length(EpComp4))

for (i in 1:length(EpComp4)){
  FCvalues[ ,i]=EpComp4[[i]]$log2FoldChange[match(EpGenesList[x2], EpComp4[[i]]$Gene)]
}

colnames(FCvalues)=names(EpComp4)
rownames(FCvalues)=EpGenesList[x2]


# for each list pick the top 50 diff genes FC>2 and baseman > 50
glist=NA
for (i in 1:length(EpComp4)){
  glist=c(glist, EpComp4[[i]]$Gene[which(EpComp4[[i]]$padj<0.1 & abs(EpComp4[[i]]$log2FoldChange)>2 & EpComp4[[i]]$baseMean>25)])
}

ColsideCols=SetCols[EpddsTreatG$Comp8]

glistmod=unique(glist)
glistmod=glistmod[-grep("LOC", glistmod)]
glistmod=na.omit(glistmod[-grep("RGD", glistmod)])

#heatmap.plus(assay(vstEp)[glistmod, ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),  main=sprintf("All DEG %s samples", SampleFrac))
```

We can also view this in the form of what is highly expressed in each comparison. Below is a heatmap of the fold changes:

```{r}
# distance of the samples to one another
par(oma=c(1,0,0,0))
heatmap.2(FCvalues, trace="none", scale="row", col=RdBu[11:1], 
          main=sprintf("All comparisons %s, log2FC for each gene", SampleFrac))
#dev.off()
```

Below, we visualise the enrichment scores using different gene sets and 

```{r}
#Epismr3=ismr4

#pdf(sprintf("rslt/DESeq/GSEA_signature_comparisons_%s.pdf", SampleFrac), width=10, height=12)

for (i in 1:length(Epismr3)){
  x1=Epismr3[[i]]
  # find padj<0.1
  idx2=lapply(seq(3, ncol(x1), by=2), function(x) which(as.numeric(as.character(x1[ ,x]))<0.01))
  unList=table(unlist(idx2))
  #pickThese=names(unList)#[which(unList>1)]
  pickThese2=names(unList)[which(unList>1)]
  
  if (length(pickThese2)>100){
    temp=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
    temp2=sapply(temp, function(x) as.numeric(as.character(x)))
    temp2=rowSds(abs(temp2))
    names(temp2)=pickThese2
    temp2=sort(temp2, decreasing = T)
    pickThese2=names(temp2)[1:100]
  }
  
  x23=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
  
  x234=sapply(x23, function(x) as.numeric(as.character(x)))
  rownames(x234)=rownames(x23)
  
  par(oma=c(2,0,0,2))
  heatmap.2(x234, col=RdBu[11:1], scale="none", trace="none", main=sprintf("%s pathways %s fraction", 
                                                                           names(Epismr3)[i], SampleFrac))
}

#dev.off()

# boxplot(assay(vstEp)["Tap1", ]~EpddsTreatG$Treatment)
# boxplot(assay(vstEp)["Cd74", ]~EpddsTreatG$Comp4)
# boxplot(assay(vstEp)["Cd8a", ]~EpddsTreatG$Treatment)
# boxplot(assay(vstEp)["Ctla4", ]~EpddsTreatG$Treatment)
# boxplot(assay(vstEp)["Tgfbr1", ]~EpddsTreatG$Comp8)
```

### CD45 comparisons

```{r}
SampleFrac="CD"

allCDGenes=unlist(CDCompSig)
allCDTab=table(allCDGenes)
CDGenesList=names(allCDTab)[which(allCDTab>1)]
#CDGenesList=CDGenesList[-grCD("LOC", CDGenesList)]
#CDGenesList=CDGenesList[-grCD("RGD", CDGenesList)]
# also, remove all samples which have a base mean less than 10
x1=CDComp4[[1]]$baseMean[match(CDGenesList, CDComp4[[1]]$Gene)]
x2=which(x1>25)
vstCD=vst(CDdds, blind=T)

CDddsTreatG$Comp8_v2=factor(paste(CDddsTreatG$Treatment, CDddsTreatG$Growth))

ColsideCols=DiffCols[CDddsTreatG$Comp8_v2]
ColsideColsB=hue_pal()(4)[CDddsTreatG$Treatment]
ColsideColsC=hue_pal()(2)[CDddsTreatG$Growth]

colTable=rbind(ColsideCols, ColsideColsB, ColsideColsC)
rownames(colTable)=c("Treat+growth", "Treatment", "growth")



#pdf(sprintf("rslt/DESeq/DEseq_comparisons_%s.pdf", SampleFrac), width=7, height=10)

sampleDist=dist(t(assay(vstCD)))
sampleDistMatrix <- as.matrix(sampleDist)
heatmap.plus(sampleDistMatrix, trace="none", scale="none", col=brewer.pal(11, "Blues")[11:1], ColSideColors = t(colTable), main=sprintf("Similarity between %s samples", SampleFrac))

# Take the top 150 variable genes 
# compute the sds for each genes
sds = rowSds(assay(vstCD))
means=rowMeans(assay(vstCD))
CVs=sds/means
CVs=CVs[-which(means<7)]
sds2=sort(CVs, decreasing = T)

heatmap.plus(assay(vstCD)[names(sds2)[1:200], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable), main=sprintf("top 200 variable genes all %s samples", SampleFrac))


heatmap.plus(assay(vstCD)[CDGenesList[x2], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),
          main=sprintf("DEG at least 2 %s samples", SampleFrac))

# Make a table for these genes
FCvalues=matrix(NA, nrow=length(x2), ncol=length(CDComp4))

for (i in 1:length(CDComp4)){
  FCvalues[ ,i]=CDComp4[[i]]$log2FoldChange[match(CDGenesList[x2], CDComp4[[i]]$Gene)]
}

colnames(FCvalues)=names(CDComp4)
rownames(FCvalues)=CDGenesList[x2]


# for each list pick the top 50 diff genes FC>2 and baseman > 50
glist=NA
for (i in 1:length(CDComp4)){
  glist=c(glist, CDComp4[[i]]$Gene[which(CDComp4[[i]]$padj<0.1 & abs(CDComp4[[i]]$log2FoldChange)>2 & CDComp4[[i]]$baseMean>25)])
}

ColsideCols=SetCols[CDddsTreatG$Comp8]

glistmod=unique(glist)
#glistmod=glistmod[-grep("LOC", glistmod)]
#glistmod=na.omit(glistmod[-grCD("RGD", glistmod)])

heatmap.plus(assay(vstCD)[na.omit(glistmod), ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),
          main=sprintf("All DEG %s samples", SampleFrac))

# distance of the samples to one another
par(oma=c(2,0,0,0))
heatmap.2(FCvalues, trace="none", scale="row", col=RdBu[11:1], 
          main=sprintf("All comparisons %s, log2FC for each gene", SampleFrac))
#dev.off()

#CDismr3=ismr4

#pdf(sprintf("rslt/DESeq/GSEA_signature_comparisons_%s.pdf", SampleFrac), width=10, height=12)

for (i in 1:length(CDismr3)){
  x1=CDismr3[[i]]
  # find padj<0.1
  idx2=lapply(seq(3, ncol(x1), by=2), function(x) which(as.numeric(as.character(x1[ ,x]))<0.01))
  unList=table(unlist(idx2))
  #pickThese=names(unList)#[which(unList>1)]
  pickThese2=names(unList)[which(unList>1)]
  
  if (length(pickThese2)>100){
    temp=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
    temp2=sapply(temp, function(x) as.numeric(as.character(x)))
    temp2=rowSds(abs(temp2))
    names(temp2)=pickThese2
    temp2=sort(temp2, decreasing = T)
    pickThese2=names(temp2)[1:100]
  }
  
  x23=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
  
  x234=sapply(x23, function(x) as.numeric(as.character(x)))
  rownames(x234)=rownames(x23)
  
  par(oma=c(2,0,0,2))
  heatmap.2(x234, col=RdBu[11:1], scale="none", trace="none", main=sprintf("%s pathways %s fraction", 
                                                                           names(CDismr3)[i], SampleFrac))
}

#dev.off()


```

### DN samples

```{r}
SampleFrac="DN"

allDNGenes=unlist(DNCompSig)
allDNTab=table(allDNGenes)
DNGenesList=names(allDNTab)[which(allDNTab>1)]
#DNGenesList=DNGenesList[-grep("LOC", DNGenesList)]
#DNGenesList=DNGenesList[-grep("RGD", DNGenesList)]
# also, remove all samples which have a base mean less than 10
x1=DNComp4[[1]]$baseMean[match(DNGenesList, DNComp4[[1]]$Gene)]
x2=which(x1>25)
vstDN=vst(DNdds, blind=T)

DNddsTreatG$Comp8_v2=factor(paste(DNddsTreatG$Treatment, DNddsTreatG$Growth))

ColsideCols=DiffCols[DNddsTreatG$Comp8_v2]
ColsideColsB=hue_pal()(4)[DNddsTreatG$Treatment]
ColsideColsC=hue_pal()(2)[DNddsTreatG$Growth]

colTable=rbind(ColsideCols, ColsideColsB, ColsideColsC)
rownames(colTable)=c("Treat+growth", "Treatment", "growth")



#pdf(sprintf("rslt/DESeq/DEseq_comparisons_%s.pdf", SampleFrac), width=7, height=10)

sampleDist=dist(t(assay(vstDN)))
sampleDistMatrix <- as.matrix(sampleDist)
heatmap.plus(sampleDistMatrix, trace="none", scale="none", col=brewer.pal(11, "Blues")[11:1], ColSideColors = t(colTable), main=sprintf("Similarity between %s samples", SampleFrac))

# Take the top 150 variable genes 
# compute the sds for each genes
sds = rowSds(assay(vstDN))
means=rowMeans(assay(vstDN))
CVs=sds/means
CVs=CVs[-which(means<7)]
sds2=sort(CVs, decreasing = T)

heatmap.plus(assay(vstDN)[names(sds2)[1:200], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable), main=sprintf("top 200 variable genes all %s samples", SampleFrac))


heatmap.plus(assay(vstDN)[DNGenesList[x2], ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),
          main=sprintf("DEG at least 2 %s samples", SampleFrac))

# Make a table for these genes
FCvalues=matrix(NA, nrow=length(x2), ncol=length(DNComp4))

for (i in 1:length(DNComp4)){
  FCvalues[ ,i]=DNComp4[[i]]$log2FoldChange[match(DNGenesList[x2], DNComp4[[i]]$Gene)]
}

colnames(FCvalues)=names(DNComp4)
rownames(FCvalues)=DNGenesList[x2]


# for each list pick the top 50 diff genes FC>2 and baseman > 50
glist=NA
for (i in 1:length(DNComp4)){
  glist=c(glist, DNComp4[[i]]$Gene[which(DNComp4[[i]]$padj<0.1 & abs(DNComp4[[i]]$log2FoldChange)>2 & DNComp4[[i]]$baseMean>25)])
}

ColsideCols=SetCols[DNddsTreatG$Comp8]

glistmod=na.omit(unique(glist))
#glistmod=glistmod[-grep("LOC", glistmod)]
#glistmod=na.omit(glistmod[-grep("RGD", glistmod)])

heatmap.plus(assay(vstDN)[glistmod, ], trace="none", scale="row", col=RdBu[11:1], ColSideColors = t(colTable),
          main=sprintf("All DEG %s samples", SampleFrac))

# distance of the samples to one another
par(oma=c(2,0,0,0))
heatmap.2(FCvalues, trace="none", scale="row", col=RdBu[11:1], 
          main=sprintf("All comparisons %s, log2FC for each gene", SampleFrac))
#dev.off()

#DNismr3=ismr4

#pdf(sprintf("rslt/DESeq/GSEA_signature_comparisons_%s.pdf", SampleFrac), width=10, height=12)

for (i in 1:length(DNismr3)){
  x1=DNismr3[[i]]
  # find padj<0.1
  idx2=lapply(seq(3, ncol(x1), by=2), function(x) which(as.numeric(as.character(x1[ ,x]))<0.01))
  unList=table(unlist(idx2))
  #pickThese=names(unList)#[which(unList>1)]
  pickThese2=names(unList)[which(unList>1)]
  
  if (length(pickThese2)>100){
    temp=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
    temp2=sapply(temp, function(x) as.numeric(as.character(x)))
    temp2=rowSds(abs(temp2))
    names(temp2)=pickThese2
    temp2=sort(temp2, decreasing = T)
    pickThese2=names(temp2)[1:100]
  }
  
  x23=x1[as.numeric(pickThese2), seq(2, ncol(x1), by=2)]
  
  x234=sapply(x23, function(x) as.numeric(as.character(x)))
  rownames(x234)=rownames(x23)
  
  par(oma=c(2,0,0,2))
  heatmap.2(x234, col=RdBu[11:1], scale="none", trace="none", main=sprintf("%s pathways %s fraction", 
                                                                           names(DNismr3)[i], SampleFrac))
}

#dev.off()

```

## Growing vs stable emphasis

Below, we focus specifically on the growing vs stable comparison in greater depth.
Here, we look at the 3 different fractions in greater depth and look at volcano plots of DEG and heatmaps of differential genes. Samples are colored according to whether they are growing or stable

### DN fraction

```{r}

#pdf(sprintf("rslt/DESeq/volcano_plots_differences_stable_vs_growing_%s.pdf", Sys.Date()), height=7, width=8)

DNa1=DNComp4$stable_vs_growing
DNa=DNComp4$stable_vs_growing[ which(DNComp4$stable_vs_growing$padj<0.1 & DNComp4$stable_vs_growing$baseMean>50 & abs(DNComp4$stable_vs_growing$log2FoldChange)>1.5), ]
with(DNa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: DN Stable (+) vs Growing (-)", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(DNa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(DNa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.05, Gene, pch=20, col="red", cex=0.75))


heatmap.2(assay(vstDN)[ DNa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstDN$Growth)), col=RdBu[11:1], main="DN genes")
```

### CD fraction

```{r}
CDa1=CDComp4$stable_vs_growing
CDa=CDComp4$stable_vs_growing[ which(CDComp4$stable_vs_growing$padj<0.05 & CDComp4$stable_vs_growing$baseMean>100 & abs(CDComp4$stable_vs_growing$log2FoldChange)>2), ]
with(CDa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: CD Stable (+) vs Growing (-)", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(CDa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(CDa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.05, Gene, pch=20, col="red", cex=0.75))

heatmap.2(assay(vstCD)[ CDa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstCD$Growth)), col=RdBu[11:1], main="CD genes")
```

### Ep Fraction

```{r}
Epa1=EpComp4$stable_vs_growing
Epa=EpComp4$stable_vs_growing[ which(EpComp4$stable_vs_growing$padj<0.1 & EpComp4$stable_vs_growing$baseMean>50 & abs(EpComp4$stable_vs_growing$log2FoldChange)>1.5), ]
with(Epa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: Ep Stable vs Growing", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(Epa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(Epa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.1, Gene, pch=20, col="red", cex=0.75))

heatmap.2(assay(vstEp)[ Epa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstEp$Growth)), col=RdBu[11:1], main="Ep genes")


#dev.off()

```

### Specific pathways

The above plots suggest that there could be a different in growing and stable based on :

* inflammation
* Kras signalling
* MHC presentation
* checkpoint proteins

We can pull out the genes in these sets and visualise the relative expression in a heatmap in the DN, CD45 and Ep samples:

Note that red is growing and green is stable

```{r}
# library(org.Hs.eg.db)
# load("../anntotations/ListofGeneSets2.RData")

SetNamesc2=names(PathInc2) #names(ListGSC$c2List)
x1=grep("MHC", SetNamesc2)
GeneNames=unique(unlist(geneIds(PathInc2[x1[c(1, 4,5)]])))

#test1=mapIds(org.Hs.eg.db, GeneNames, 'SYMBOL','ENTREZID')
RatGeneNamesMHC=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

#RatGeneNamesKras=mapIds(org.Hs.eg.db, ListGSC$Hallmark$HALLMARK_KRAS_SIGNALING_UP, 'SYMBOL','ENTREZID')
GeneNames=unlist(geneIds(PathInH["HALLMARK_KRAS_SIGNALING_UP"]))
RatGeneNamesKras=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

GeneNames=unlist(geneIds(PathInH["HALLMARK_INFLAMMATORY_RESPONSE"]))
RatGeneNamesInf=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

CheckpointProt=unlist(ImmSuppAPC)
RatGeneNamesCheckpoint=na.omit(unique(SymHum2Rat$RGD.symbol[match(CheckpointProt, SymHum2Rat$HGNC.symbol)]))

# RatCP=read.delim("../anntotations/immune_Suppression.csv", sep="\t", stringsAsFactors = F)
# RatCP=na.omit(unique(SymHum2Rat$RGD.symbol[match(unique(unlist(RatCP)), SymHum2Rat$HGNC.symbol)]))
# 
# 
# RatMHC=read.csv("../anntotations/MHCloss.csv", header = F, stringsAsFactors = F)[ ,1]
# RatMHCb=na.omit(unique(SymHum2Rat$RGD.symbol[match(RatMHC, SymHum2Rat$HGNC.symbol)]))
# read in checkpoint proteins
```

#### DN samples:

Note the distribution of growing/stable in DN is: `r table(DNdds$Growth)`

```{r}
ColsideColsC=hue_pal()(2)[DNdds$Growth]

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesMHC, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesKras, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesInf, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstDN)[na.omit(match(MHCPres2Rat, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```

#### CD45 samples:

Note the distribution of growing/stable in CD is: `r table(CDdds$Growth)`


```{r}
ColsideColsC=hue_pal()(2)[CDdds$Growth]

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesMHC, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesKras, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesInf, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstCD)[na.omit(match(MHCPres2Rat, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```

#### Epithelial samples:

```{r}
ColsideColsC=hue_pal()(2)[Epdds$Growth]

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesMHC, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesKras, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesInf, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstEp)[na.omit(match(MHCPres2Rat, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```



```{r, eval=F}
### comapre DN samples: PAM50 Lum vs Basal/Normal?

DNdds$PAM50_v2="ERplus"
DNdds$PAM50_v2[which(DNdds$PAM50%in%c("Basal", "Normal"))]="ERneg"
DNdds$PAM50_v2=factor(DNdds$PAM50_v2)
design(DNdds)=~PAM50_v2+factor(Batch)
DNddsP50=DESeq(DNdds)

DNresP50=results(DNddsP50)

x1=rownames(DNresP50)[which(abs(DNresP50$log2FoldChange)>2 & DNresP50$padj<0.05)]
```

<!--chapter:end:06-deseqoutputs.Rmd-->

# DESeq analysis

This document sets up DESeq runs to compare:

* CD45 samples
* Ep samples

according to size of the cohort samples

## CD45 samples

In section 6.2, we have noticed that some DN samples had expression of epithelial markers. Here, we perform a differential gene expression analysis to find genes which are different between these two fractions. 

Below is a summary of the number of differentisal genes, using p value cut off of 0.05 and log2 fold change of 1.5 and base expression of 100+.

```{r cd45-char-bigsmall, cache=T}
#infoTableFinal$TumSize=Cdata$Tumor.dia..sac..mm.[match(infoTableFinal$TumorID, Cdata$TumorID)]
infoTableFinal$SizeCat=factor(ifelse(infoTableFinal$Cohort=="Progression", ifelse(infoTableFinal$TumSize>X2a, "big", "small"), ifelse(infoTableFinal$TumSize>X1a, "big", "small")))
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction=="CD45" & !is.na(infoTableFinal$SizeCat))])
CD45ddsChar=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~(SizeCat)) ## change class

a1x=rowSums(counts(CD45ddsChar))
a1b=apply(counts(CD45ddsChar), 1, function(c) sum(c!=0))
 # par(mfrow=c(1,2))
 # hist(log10(a1x+1), main="log10 total counts")
 # hist((a1b+1), main="Non-zero entries")
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(CD45ddsChar))>10^sd1vals)
keep2=which(apply(counts(CD45ddsChar), 1, function(c) sum(c!=0))> (ncol(CD45ddsChar)/2))
CD45ddsChar=CD45ddsChar[intersect(keep, keep2), ]
CD45ddsChar=DESeq(CD45ddsChar)

print('significant differential genes')
CD45res=results(CD45ddsChar, contrast=c("SizeCat", "big", "small"))
CD45res2=CD45res[which(CD45res$padj<0.05 & abs(CD45res$log2FoldChange)>1.5 &
                             CD45res$baseMean>100), ]
#resDNeprslt2$CellMarker=ifelse(rownames(CD45ddsChar)%in%unlist(GeneListRat), 1, 0)
#resDNeprslt2=resDNeprslt2[order(resDNeprslt2$CellMarker, abs(resDNeprslt2$log2FoldChange), decreasing = T), ]

#scroll_box(kable(CD45res2, format="html"),
#         height="300px", width="100%")

#pdf("~/Desktop/DESeq-small-vs-largeCD45-characterisation.pdf", height=6, width=6)
namId=which(rownames(vsd)%in%RatAllImm & rownames(vsd)%in%rownames(CD45res2))
namIdN=rownames(vsd)[namId]

plot(CD45res$log2FoldChange, -log10(CD45res$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(CD45res2$log2FoldChange, -log10(CD45res2$padj), rownames(CD45res2), col="red")

CD45res3=CD45res[match(namIdN, rownames(CD45res)), ]

plot(CD45res$log2FoldChange, -log10(CD45res$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(CD45res3$log2FoldChange, -log10(CD45res3$padj), rownames(CD45res3), col="red")


#HighExprGenes=rownames(CD45res2)[which(CD45res2$baseMean>100 & CD45res2$log2FoldChange<0) ]

colSide=CD45ddsChar$SizeCat

t2=assay(vsd)[namId, match(colnames(CD45ddsChar), colnames(vsd))]
heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="immune genes DEG")


t2=assay(vsd)[which( rownames(vsd)%in%rownames(CD45res2)), match(colnames(CD45ddsChar), colnames(vsd))]
a1=heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="all DEG")
#heatmap.2(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide2], scale="row", main="Enriched in Ep genes")

boxplot(assay(vsd)["Havcr2", match(colnames(CD45ddsChar), colnames(vsd))]~CD45ddsChar$SizeCat,
        main="Havcr2 gene small vs big vst expression")
boxplot(assay(vsd)["Krt17", match(colnames(CD45ddsChar), colnames(vsd))]~CD45ddsChar$SizeCat,
        main="Krt17 gene small vs big vst expression")

#dev.off()

write.csv(CD45res2, file=sprintf("outputs/DESeq/difference_between_cd45characterisation-big-small%s.csv", Sys.Date()))
```

## Epithelial samples

```{r}
#infoTableFinal$TumSize=Cdata$Tumor.dia..sac..mm.[match(infoTableFinal$TumorID, Cdata$TumorID)]
#infoTableFinal$SizeCat=factor(ifelse(infoTableFinal$Cohort=="Progression", ifelse(infoTableFinal$TumSize>X2a, "big", "small"), ifelse(infoTableFinal$TumSize>X1a, "big", "small")))
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction=="Ep" & !is.na(infoTableFinal$SizeCat))])
EpddsChar=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~(SizeCat)) ## change class

a1x=rowSums(counts(EpddsChar))
a1b=apply(counts(EpddsChar), 1, function(c) sum(c!=0))
 # par(mfrow=c(1,2))
 # hist(log10(a1x+1), main="log10 total counts")
 # hist((a1b+1), main="Non-zero entries")
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(EpddsChar))>10^sd1vals)
keep2=which(apply(counts(EpddsChar), 1, function(c) sum(c!=0))> (ncol(EpddsChar)/2))
EpddsChar=EpddsChar[intersect(keep, keep2), ]
EpddsChar=DESeq(EpddsChar)

print('significant differential genes')
Epres=results(EpddsChar, contrast=c("SizeCat", "big", "small"))
Epres2=Epres[which(Epres$padj<0.05 & abs(Epres$log2FoldChange)>1.5 &
                             Epres$baseMean>100), ]
#resDNeprslt2$CellMarker=ifelse(rownames(EpddsChar)%in%unlist(GeneListRat), 1, 0)
#resDNeprslt2=resDNeprslt2[order(resDNeprslt2$CellMarker, abs(resDNeprslt2$log2FoldChange), decreasing = T), ]

#scroll_box(kable(Epres2, format="html"),height="300px", width="100%")

#pdf("~/Desktop/DESeq-small-vs-largeEp-characterisation.pdf", height=6, width=6)


plot(Epres$log2FoldChange, -log10(Epres$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(Epres2$log2FoldChange, -log10(Epres2$padj), rownames(Epres2), col="red")


#HighExprGenes=rownames(Epres2)[which(Epres2$baseMean>100 & Epres2$log2FoldChange<0) ]

colSide=EpddsChar$SizeCat

# t2=assay(vsd)[which(rownames(vsd)%in%RatAllImm & rownames(vsd)%in%rownames(Epres2)), match(colnames(EpddsChar), colnames(vsd))]
# heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="immune genes DEG")


t2=assay(vsd)[which( rownames(vsd)%in%rownames(Epres2)), match(colnames(EpddsChar), colnames(vsd))]
a1=heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="all DEG")
#heatmap.2(t2[ ,-grep("Ep", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide2], scale="row", main="Enriched in Ep genes")

boxplot(assay(vsd)["Creb1", match(colnames(EpddsChar), colnames(vsd))]~EpddsChar$SizeCat,
        main="Creb1 gene small vs big vst expression")
#dev.off()

write.csv(Epres2, file=sprintf("outputs/DESeq/difference_between_Epcharacterisation-big-small%s.csv", Sys.Date()))


```

<!--chapter:end:06b-characterisation-cohort.Rmd-->

# ER/Pgr Subtyping

In this section, we will look at whether there are differences in rat subtype using the following approaches:

* Creating our own subtyping approach using specific markers of interest (e.g. using PAM clustering)
    * Using known gene list 
    * Using random genes (top 50, 100, 200 etc variable genes)
* PAM50 subtyping using the methods published by [Parker et al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2667820/). This method uses rsem scores to classify samples.

As the DN samples do have keratin expression, we will also try to determine the subtypes in these samples too.

In the below analyses, we will conduct this subtyping as follows:

* progression specific epithelial cohort
* characterisation specific epithelial cohort
* dn specific cohort (progression)

## In-house classifier

The selected gene list includes three lists: A. is a mroe comprehensive list containing epithelial, mesenchymal markers and proliferation markers, B. has a more narrow list of subtype specific markers 

a. 'Ar', 'Cd24', 'Cdh1', 'Foxa1', 'Gata3', 'Krt8', 'Krt18', 'Krt5', 'Vim', 'Erbb2', 'Esr1', 'Pgr', 'Mki67', 'Pcna'
b. 'Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr'

We will be using variance stabilised counts in this section.

Firstly, we will look at the progression cohort. Note that the overlap between the two gene-sets are similar, and the heatmap is row-scaled. 

```{r}
Markers=c('Ar', 'Cd24', 'Cdh1', 'Foxa1', 'Gata3', 'Krt8', 'Krt18', 'Krt5', 'Vim', 'Erbb2', 'Esr1', 'Pgr', 'Mki67', 'Pcna')
Markers2=c('Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr')
Markers3=c('Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr', 'Krt5', 'Krt18', 'Vim', 'Tp63' )
Markers4=c('Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr', 'Krt5', 'Krt18', 'Vim', 'Tp63', 'Lalba', 
           'Kit', 'Prlr', 'Spdef', 'Xbp1', 'Krt14', 'Krt17', 'Acta2')

#pdf(sprintf("rslt/signatureAnalysis/new_classifer_PAM_%s.pdf", Sys.Date()), height=6, width=7)
# Progression cohort
Ax1=assay(vstEp)[ match(Markers4, rownames(assay(vstEp))),]
Pam1=pam(t(Ax1), 2)
plot(Pam1, main="extended list")
ColA=Pam1$clustering
ColA=ifelse(ColA==1, "Basal", "Lum")

Ax2=assay(vstEp)[ match(Markers3, rownames(assay(vstEp))),]
Pam2=pam(t(Ax2), 2)
plot(Pam2, main="narrow list")
ColB=Pam2$clustering
ColB=ifelse(ColB==1, "Basal", "Lum")

table(ColA, ColB)

CTable=cbind(ColA, ColB)
CTable=gsub("Basal", "red", CTable)
CTable=gsub("Lum", "blue", CTable)

heatmap.plus(Ax1, col=brewer.pal(11, "RdBu")[11:1], ColSideColors =CTable,scale="row", main="Progression cohort vsd marker list1", trace="none")
```

We can perform a similar analysis to the characterisation cohort:

```{r}
c2=infoTableFinal$SampleID[which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort!="Progression")]
Ax1=assay(vsd)[ match(Markers2, rownames(assay(vsd))), match(c2, colnames(vsd))]
Ax1b=scale(t(Ax1))
Pam3=pam((Ax1b), 2)
km3=kmeans((Ax1b), 2)
#plot(Pam3, "extended list")
ColC=Pam3$clustering
ColC=ifelse(ColC==2, "Basal", "Lum")
ColD=km3$cluster
ColD=ifelse(ColD==2, "Basal", "Lum")

#table(ColC, ColD)
CTable=cbind(ColC, ColD)
CTable=gsub("Basal", "red", CTable)
CTable=gsub("Lum", "blue", CTable)

#pdf("~/Desktop/PAM50-characterisation-different-list2.pdf", width=8, height=8)

heatmap.plus(t(Ax1b), col=brewer.pal(11, "RdBu")[11:1], ColSideColors =CTable,scale="none", main="Char cohort vsd marker list2", trace="none")


Ax2=assay(vsd)[ match(Markers2, rownames(assay(vsd))), match(c2, colnames(vsd))]
Pam4=pam(t(Ax2), 2)
km4=kmeans(t(Ax2),2)
#plot(Pam4, "narrow list")
ColD=km4$cluster
ColD=ifelse(ColD==2, "Basal", "Lum")



#Ax1=allTPMFinal[ , which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort!="Progression")]
Ax1=assay(vsd)[, match(c2, colnames(vsd))]
Test2=cor(Ax1)
ColSideCols=ColD
heatmap.2(Test2, col=RdBu[11:1], scale="none", trace = "none", ColSideColors = as.character(as.numeric(factor(ColD))))
```

DN samples:

```{r}
Ax1=assay(vstDN)[ match(Markers, rownames(assay(vstDN))),]
Pam5=pam(t(Ax1), 2)
plot(Pam5, main="extended list DN")
ColE=Pam5$clustering
ColE=ifelse(ColE==1, "Basal", "Lum")

Ax2=assay(vstDN)[ match(Markers2, rownames(assay(vstDN))),]
Pam6=pam(t(Ax2), 2)
plot(Pam6, main="narrow list")
ColF=Pam6$clustering
ColF=ifelse(ColF==1, "Basal", "Lum")

table(ColE, ColF)

CTable=cbind(ColE, ColF)
CTable=gsub("Basal", "red", CTable)
CTable=gsub("Lum", "blue", CTable)

heatmap.plus(Ax1, col=brewer.pal(11, "RdBu")[11:1], ColSideColors =CTable,scale="row", main="DN samples vsd marker list1", trace="none")

```

We can collate these different scores and assess whether there are similarities with PgR and ER staining:

```{r}
## match to infoTable here
infoTableFinal$Subtype_extendedList=NA
infoTableFinal$Subtype_compressedList=NA

id=match(names(ColA), infoTableFinal$Sample)
infoTableFinal$Subtype_extendedList[id]=ColA
infoTableFinal$Subtype_compressedList[id]=ColB

id2=match(names(ColE), infoTableFinal$Sample)
infoTableFinal$Subtype_extendedList[id2]=ColE
infoTableFinal$Subtype_compressedList[id2]=ColF

id3=match(names(ColC), infoTableFinal$Sample)
infoTableFinal$Subtype_extendedList[id3]=ColC
infoTableFinal$Subtype_compressedList[id3]=ColD


# Contingency Tables
par(mfrow=c(2,2))
a1=table(infoTableFinal$Subtype_compressedList, Cdata$PgR..IF.[match(infoTableFinal$TumorID, Cdata$TumorID)])
ContTable(a1[ ,-2], "Pgr Expr", T, "Pgr IF", "compressed subtype")
a1=table(infoTableFinal$Subtype_extendedList, Cdata$PgR..IF.[match(infoTableFinal$TumorID, Cdata$TumorID)])
ContTable(a1[ ,-2], "Pgr Expr", T, "Pgr IF", "Extended subtype")

# remove all the DN samples
x1=which(infoTableFinal$Fraction=="Ep")
a1=table(infoTableFinal$Subtype_compressedList[x1], Cdata$PgR..IF.[match(infoTableFinal$TumorID[x1], Cdata$TumorID)])
ContTable(a1[ ,-2], "Pgr Expr", T, "Pgr IF", "compressed subtype")
a1=table(infoTableFinal$Subtype_extendedList[x1], Cdata$PgR..IF.[match(infoTableFinal$TumorID[x1], Cdata$TumorID)])
ContTable(a1[ ,-2], "Pgr Expr", T, "Pgr IF", "Extended subtype")

# Contingency Tables
par(mfrow=c(2,2))
a1=table(infoTableFinal$Subtype_compressedList, Cdata$ER..IF.[match(infoTableFinal$TumorID, Cdata$TumorID)])
ContTable(a1[ ,-2], "ER Expr", T, "ER IF", "compressed subtype")
a1=table(infoTableFinal$Subtype_extendedList, Cdata$ER..IF.[match(infoTableFinal$TumorID, Cdata$TumorID)])
ContTable(a1[ ,-2], "ER Expr", T, "ER IF", "Extended subtype")

# remove all the DN samples
x1=which(infoTableFinal$Fraction=="Ep")
a1=table(infoTableFinal$Subtype_compressedList[x1], Cdata$ER..IF.[match(infoTableFinal$TumorID[x1], Cdata$TumorID)])
ContTable(a1[ ,-2], "ER Expr", T, "ER IF", "compressed subtype no DN")
a1=table(infoTableFinal$Subtype_extendedList[x1], Cdata$ER..IF.[match(infoTableFinal$TumorID[x1], Cdata$TumorID)])
ContTable(a1[ ,-2], "ER Expr", T, "ER IF", "Extended subtype no DN")

```


Finally, look at whether any of the above samples have similar DN and Ep calls: it appears that this call is random, and the subtype does not dictate growth rate

```{r}
idx1=substr(names(ColA), 1, nchar(names(ColA))-3)
idx2=substr(names(ColE), 1, nchar(names(ColE))-3)

a1=data.frame(nid=idx1, ep=ColA)
a2=data.frame(nid=idx2, dn=ColE)
a3=merge(a1, a2, by.x="nid", by.y="nid", all.x=T, all.y=T)
a3$growth=infoTableFinal$Growth[match(a3$nid, infoTableFinal$TumorID)]
print('extended list')
table(a3$ep, a3$dn, a3$growth)

a1=data.frame(nid=idx1, ep=ColB)
a2=data.frame(nid=idx2, dn=ColF)
a3=merge(a1, a2, by.x="nid", by.y="nid", all.x=T, all.y=T)
a3$growth=infoTableFinal$Growth[match(a3$nid, infoTableFinal$TumorID)]
print('narrow list')
table(a3$ep, a3$dn, a3$growth)
```

## PAM50 (Parker) scoring

Here, we have used rsem counts in PAM50 subtyping.

```{r}

ExpressedaprilChar=read.delim("../output4external/RSEM_for_PAM50_allExpressedgenes_noCD45_characterisationOnlyapril_2020-11-03_pam50scores.txt")
ExpressedaprilProg=read.delim("../output4external/RSEM_for_PAM50_allExpressedgenes_noCD45_progressionapril_2020-11-03_pam50scores.txt")
ExpressedaprilProg2=read.delim("../output4external/RSEM_for_PAM50_allExpressedgenes_epOnly_progressionapril_2020-11-03_pam50scores.txt")

Pall=rbind(ExpressedaprilChar, ExpressedaprilProg)
Pall$Call[match(ExpressedaprilProg2$X, Pall$X)]=ExpressedaprilProg2$Call

# add to pamcalls

Pall$PamCallLong=infoTableFinal$Subtype_extendedList[match(Pall$X, infoTableFinal$SampleID)]
Pall$PamCallshort=infoTableFinal$Subtype_compressedList[match(Pall$X, infoTableFinal$SampleID)]


```

Plot all samples together and compare the confidence and scores in different subtypes:
There is overlap between the LumB and Her2 scores, similarly Normal and LumA scores are similar

```{r}
t2=data.matrix(Pall[ ,2:6])
rownames(t2)=Pall$X
heatmap.2(t2, col=RdBu[11:1], trace="none")
```

We can pull out the main markers of interest: ER, PGR, Erbb2 and Ki67 (or PCNA). 
We also compare these expression distribution of these markers to CD45, DN and Ep overall:

Notes:

* Pgr highest in luminal samples
* Esr1 dynamic range is lower
* Ar is higher in basal samples
* Pcna is higher in Basal

```{r}
midx=match(ExpressedaprilChar$X, colnames(allTPMFinal))
midx3=match(Pall$X[grep("DN",Pall$X)], colnames(allTPMFinal))
midx2=match(ExpressedaprilProg2$X, colnames(allTPMFinal))

summ1=table(ExpressedaprilChar$Call)
summ2=table(ExpressedaprilProg2$Call)
summ3=table(Pall$Call[grep("DN",Pall$X)])

gList=c("Esr1", "Pgr", "Erbb2", "Ar", "Pcna", "Mki67")

par(mfrow=c(2,3))

for (i in gList){
boxplot(allTPMFinal[i, midx ]~ExpressedaprilChar$Call, main="Char",  names=paste(names(summ1)," N=",summ1, sep=""), las=2, ylab=i, xlab="")
boxplot(allTPMFinal[i, midx2 ]~ExpressedaprilProg2$Call, main="Prog", names=paste(names(summ2)," N=",summ2, sep=""), las=2,ylab=i, xlab="")
boxplot(allTPMFinal[i, midx3 ]~Pall$Call[grep("DN",Pall$X)], main="DN",  names=paste(names(summ3)," N=",summ3, sep=""), ylab=i, las=2, xlab="")
}

summ4=table(infoTableFinal$Fraction)

for (i in gList){
boxplot(allTPMFinal[i, ]~infoTableFinal$Fraction, main=i,  names=paste(names(summ4)," N=",summ4, sep=""), las=2, ylab=i, xlab="")
}

```

heatmap based on the previous markers:

```{r}
Ax1=assay(vsd)[ match(Markers, rownames(assay(vsd))),na.omit(midx)]
Ax1b=allRSEMnorm2log[na.omit(match(toupper(Markers), rownames(allRSEMnorm2log))), na.omit(midx)]

Ax2=assay(vsd)[ match(Markers, rownames(assay(vsd))),na.omit(midx2)]
Ax2b=allRSEMnorm2log[na.omit(match(toupper(Markers), rownames(allRSEMnorm2log))), na.omit(midx2)]

Ax3=assay(vsd)[match(Markers, rownames(assay(vsd))),na.omit(midx3)]
Ax3b=allRSEMnorm2log[na.omit(match(toupper(Markers), rownames(allRSEMnorm2log))), na.omit(midx3)]

BLcall=as.character(Pall$Call)
BLcall[grep("Lum", BLcall)]="blue"
BLcall[grep("Her2", BLcall)]="magenta"
BLcall[grep("Normal", BLcall)]="green"
BLcall[grep("Basal", BLcall)]="red"

heatmap.2(Ax1, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall[which(Pall$X%in%colnames(Ax1)) ],scale="row", main="vsd marker list1", trace="none")
heatmap.2(Ax1b, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall[which(Pall$X%in%colnames(Ax1)) ], trace="none", scale="row", main="RSEM marker1")

heatmap.2(Ax2, col=brewer.pal(11, "RdBu")[11:1], ColSideColors =BLcall[which(Pall$X%in%colnames(Ax2))], scale="row", main="vsd marker list2", trace="none")
heatmap.2(Ax2b, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall[which(Pall$X%in%colnames(Ax2))], trace="none", scale="row", main="RSEM marker2")

heatmap.2(Ax3, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall[which(Pall$X%in%colnames(Ax3))], scale="row", main="vsd marker list3", trace="none")
heatmap.2(Ax3b, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall[which(Pall$X%in%colnames(Ax3))], trace="none", scale="row", main="RSEM marker3")

```

Based on the above calls, we can condense the calls:

* Her2, LumB are sumilar and can be combined with LumA
* Normal and Basal are most likely most similar

```{r}
Pall$Call2=Pall$Call
Pall$Call2[which(Pall$Call2=="Her2")]="LumB"

Pall$Call3="Basal"
Pall$Call3[grep("Lum", Pall$Call2)]="Lum"

BLcall=ifelse(Pall$Call3=="Basal", "blue", "red")

midx4=match(Pall$X, colnames(allTPMFinal))
Ax4=assay(vsd)[match(Markers, rownames(assay(vsd))),na.omit(midx4)]
Ax4b=allRSEMnorm2log[na.omit(match(toupper(Markers), rownames(allRSEMnorm2log))), na.omit(midx4)]

heatmap.2(Ax4, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall, scale="row", main="vsd marker list3", trace="none")
heatmap.2(Ax4b, col=brewer.pal(11, "RdBu")[11:1], ColSideColors = BLcall, trace="none", scale="row", main="RSEM marker3")

```


## Clustering based on random genes

In this section we randomly select the most variable 200, 500, 1000, 2000 genes: we use both the standard deviation and coefficient of variation (sd normalised by the mean) to select these most variable genes.

Below is a correlation plot which visualises the concordance between the different methods.

```{r}
ProgCoh=assay(vsd)[ ,which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort=="Progression")]
CharCoh=assay(vsd)[ ,which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort!="Progression")]

GeneVar1=sapply(1:nrow(ProgCoh), function(x) sd(ProgCoh[x, ]))
GeneVar2=sapply(1:nrow(ProgCoh), function(x) sd(ProgCoh[x, ])/mean(ProgCoh[x, ]))
names(GeneVar2)=rownames(ProgCoh)
names(GeneVar1)=rownames(ProgCoh)
OrdGene1=sort(GeneVar1, decreasing = T)
OrdGene2=sort(GeneVar2, decreasing = T)

xsearch=c(200, 500, 1000, 2000)

CallsTableProg=matrix(NA, ncol=ncol(ProgCoh), nrow=11)
colnames(CallsTableProg)=colnames(ProgCoh)
CallsTableProg[1, ]=Pall$Call3[match(colnames(CallsTableProg), Pall$X)]
#CallsTableProg[2, ]=Pall$Call2[match(colnames(CallsTableProg), Pall$X)]
CallsTableProg[2, ]=Pall$PamCallLong[match(colnames(CallsTableProg), Pall$X)]
CallsTableProg[3, ]=Pall$PamCallshort[match(colnames(CallsTableProg), Pall$X)]

count=4

par(mfrow=c(2,2))

for (i in xsearch){
 # Int1=venn(list(SD=names(OrdGene1)[1:i], CoV=names(OrdGene2)[1:i]))
  ax1=pam(t(ProgCoh[names(OrdGene1)[1:i],  ]), 2)
  bx1=pam(t(ProgCoh[names(OrdGene2)[1:i],  ]), 2)
  CallsTableProg[count, ]=ax1$clustering
  CallsTableProg[count+1, ]=bx1$clustering
  count=count+2
}

ConcordanceMat=matrix(NA, nrow=nrow(CallsTableProg), ncol=nrow(CallsTableProg))
for (i in 1:nrow(CallsTableProg)){
  for (j in 1:nrow(CallsTableProg)){
    a1=table(CallsTableProg[i, ], CallsTableProg[j, ])
    ConcordanceMat[i, j]=sum(diag(a1))/sum(a1)
  }
}

colnames(ConcordanceMat)=c("P50", "PamLong","PamShort", paste(rep(c("sd", "cov"), 4), rep(xsearch, each=2), sep="."))
rownames(ConcordanceMat)=colnames(ConcordanceMat)
ConcordanceMat2=ConcordanceMat
ConcordanceMat2[which(ConcordanceMat2<0.5, arr.ind=T)]=1-ConcordanceMat2[which(ConcordanceMat2<0.5, arr.ind=T)]

# Example heatmap
Ax1=assay(vstEp)[ match(Markers, rownames(assay(vstEp))),]

TabOutput=cbind(ifelse(CallsTableProg[4, ]==1, "blue", "red"),ifelse(CallsTableProg[5, ]==1, "blue", "red"))
x1=match(colnames(Ax1), colnames(CallsTableProg))

heatmap.plus(Ax1, col=brewer.pal(11, "RdBu")[11:1], ColSideColors =(TabOutput[ x1,]),scale="row", main="Progression cohort vsd marker list1", trace="none")

```

## Consolidating the different results

Below is a concordance map of the similarity between the different metrics calculated as

$$ \frac{N_{b,b}+N_{l,l}}{N_{total}} $$

where $N_{b,b}$ is the number of cases which are basal in two comparisons and $N_{l,l}$ the number of cases which are luminal in both comparisons.

Note that the values extend from 0.5 to 1, which indicates that any two methods overlap more than just by chance. 

There is good overlap between the in-house specific list characterisation, and some overlap between pam50 calling and in-house short list. 

```{r}
heatmap.2(ConcordanceMat2, col=RdBu[11:1], trace="none",scale="none")

heatmap.2(ConcordanceMat2[1:7, 1:7], col=RdBu[11:1], trace="none",scale="none")
```

Below is a summary of the average expression values of the classes defined by the different methods:

* The targeted lists show differences in esr1, pgr, erbb2, pcna
* Ar has differing directions for the pam classifications
* Random genes selected show differences in pgr, erbb2, Ar and perhaps Mki67

```{r}
par(mfrow=c(2,3))

compv=c("PAM50", "pamlong", "pamshort", "top200sd", "top500sd", "top1000sd", "top2000sd")
gList=c(gList, "Foxa1", "Gata3", "Vim")

for (j in gList){
for (i in c(1:3,5, 7, 9, 11)){
  boxplot(ProgCoh[j, ]~CallsTableProg[i, ], main=rownames(ConcordanceMat2)[i], ylab=j, xlab="")
}}
mtext("ESR1", side=2, outer=T, line=-2)

```

We can summarise the outputs for each sample below

```{r}
CallsTableProg2=CallsTableProg[c(1:3,5, 7, 9, 11), ]
rownames(CallsTableProg2)=compv

scroll_box(kable(t(CallsTableProg2), format="html"),
         height="300px", width="100%")


```

# Signature analysis

In this section, we use a combination of gene-set enrichment analysis, heatmap visualisation and XX to investigate differences in 

- PAM50 expression
- Major signalling pathways
- MHC expression signatures

## MHC signature analysis

Look if there is an association between MHC class I and class II and checkpoint proteins with growth in the different fractions. The summary appears:

* class I: association with stable in ep samples
* class II: low expression in DN stable sampels
* MHC presentation: higher in stable samples Ep (and also the characterisation cohort in general), may also be the case in DN samples

### MHC-I

```{r}
classI <- c("RT1-A1", "RT1-A2", "RT1-A3", "RT1-Cl", "RT1-M2", "RT1-M3-1", "RT1-M4", "RT1-M5", "RT1-N1", "RT1-N2", "RT1-N3", "RT1-O1", "RT1-S2", "RT1-S3")
classII <- c("RT1-Ba", "RT1-Bb", "RT1-Da", "RT1-Db1", "RT1-Db2", "RT1-DMa", "RT1-DMb", "RT1-DOa", "RT1-DOb", "RT1-Ha")

#pdf(sprintf("rslt/signatureAnalysis/MHC_presentation_%s.pdf", Sys.Date()), height=6, width=7)

MHCclassSumm2=assay(vsd)[na.omit(match(classI, rownames(assay(vsd)))), ]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45")])], scale="row", main="CD: MHC class I")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep")])], scale="row", main="Ep: MHC class I")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN")])], scale="row", main="DN: MHC class I")
```

### MHC-II

```{r}
MHCclassSumm2=assay(vsd)[na.omit(match(classII, rownames(assay(vsd)))), ]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45")])], scale="row", main="CD: MHC class II")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep")])], scale="row", main="Ep: MHC class II")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN")])], scale="row", main="DN: MHC class II")
```

### MHC presentation proteins

```{r}
MHCclassSumm2=assay(vsd)[na.omit(match(MHCPres2Rat[-1], rownames(assay(vsd2)))), ]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45")])], scale="row", main="CD45: MHC presentation")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep")])], scale="row", main="Ep: MHC presentation")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN")], col=RdBu[11:1], trace="none", ColSideColors = palette()[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN")])], scale="row", main="DN: MHC presentation")

#dev.off()
```


<!--chapter:end:07-signature-analysis.Rmd-->

## Cancer pathways

In this section, we will assess whether certain fractions (eg. ep or dn) or certain tumors depend on specific cancer signalling axes. We will utilise the following information:

* Common cancer pathways listed by Bailey et al: This includes PIk3CA, cell cycle, Myc, tp53, notch, TGFB
* manually curated list of breast-specific genes (esr1, gata3, erbb2, pgr, tp53)

### ssGSEA

Figure out the signalling pathway expression (e.g using ssGSEA).

From top to bottom, the color codes are:

* cd8 content
* infiltration cd8
* Growht
* Fraction
* treatment

```{r}
gsList=list()
for (i in 1:length(PathwayListRat)){
gsList[[i]]=GeneSet(na.omit(PathwayListRat[[i]]), setName = names(PathwayListRat)[i], geneIdType=SymbolIdentifier())
}

CancerRatSig=GeneSetCollection(gsList)
# 
Cancer_counts=gsva(assay(dds)[ ,-grep("CD45", colnames(assay(dds)))], CancerRatSig, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)

idx=match(colnames(Cancer_counts), infoTableFinal$SampleID)
ColTable=cbind(palette()[as.numeric(factor(infoTableFinal$Treatment[idx]))],                             palette()[as.numeric(factor(infoTableFinal$Fraction[idx]))],
palette()[as.numeric(factor(infoTableFinal$Growth[idx]))],
palette()[as.numeric(factor(infoTableFinal$MHcut[idx]))],
palette()[as.numeric(factor(infoTableFinal$CD8FracCut[idx]))])

#Cancer_counts=gsva(allTPMFinal[ ,-grep("CD45", colnames(assay(dds)))], CancerRatSig, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)

# doesn't seem to matter that we convert to TPM or not. Also try the TPMs from the RSEM package
#Imm_counts2=gsva(allTPMFinal,ImmRatSig, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)

heatmap.plus(Cancer_counts, col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors=ColTable, scale="row", symkey=T)


CCount=Cancer_counts[ , grep("Ep", colnames(Cancer_counts))]

heatmap.plus(CCount, col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors =ColTable[grep("Ep", colnames(Cancer_counts)) ,], scale="row", symkey=T, main="Ep only samples")

CCount=Cancer_counts[ , grep("DN", colnames(Cancer_counts))]

heatmap.plus(CCount, col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors = ColTable[grep("DN", colnames(Cancer_counts)), ], scale="row", symkey=T,main="DN only samples")

cancerCountsMelt=melt(Cancer_counts[, which(colnames(Cancer_counts)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression"])])

cancerCountsMelt$Fraction=infoTableFinal$Fraction[match(cancerCountsMelt$Var2, infoTableFinal$SampleID)]
cancerCountsMelt$Treatment=infoTableFinal$Treatment[match(cancerCountsMelt$Var2, infoTableFinal$SampleID)]
cancerCountsMelt$Growth=infoTableFinal$Growth[match(cancerCountsMelt$Var2, infoTableFinal$SampleID)]
cancerCountsMelt$MHEpCAM=infoTableFinal$MHcut[match(cancerCountsMelt$Var2, infoTableFinal$SampleID)]
cancerCountsMelt$CD8Frac=infoTableFinal$CD8FracCut[match(cancerCountsMelt$Var2, infoTableFinal$SampleID)]

ggplot(data=cancerCountsMelt, aes(x=Treatment, y=value, col=Fraction))+geom_boxplot()+facet_wrap(~Var1, scales="free_y")+ggtitle("pathway enrichment: Treatment")

ggplot(data=cancerCountsMelt, aes(x=Growth, y=value, col=Fraction))+geom_boxplot()+facet_wrap(~Var1, scales="free_y")+ggtitle("pathway enrichment: Growth")

ggplot(data=cancerCountsMelt, aes(x=MHEpCAM, y=value, col=Fraction))+geom_boxplot()+facet_wrap(~Var1, scales="free_y")+ggtitle("pathway enrichment: Infiltration")

ggplot(data=cancerCountsMelt, aes(x=CD8Frac, y=value, col=Fraction))+geom_boxplot()+facet_wrap(~Var1, scales="free_y")+ggtitle("pathway enrichment: CD8 Fraction")
```

From the above plots:

* higher Hippom Notch RTK Wnt and TGFB signalling in DN samples
* LY epithelial samples are enriched in cell cycle genes

### regression model for covariates

Linear model: Create a linear model to explain the above, focusing on the Progression cohort.

I.e. 
Signature Score ~ Fraction + Treatment + CD8Fraction + Spatial Score + GrowthRate + Tumour size + PAM50

Note that the reference levels are:

* Fraction: DN 
* Treatment: Vehicle   
* PAM50: basal

We see:

* TP53 and Wnt pathways associated with CD8 content (particularly in CD8 low samples)
* TP53 more associated basal DN, and with treatment in DN samples, infiltrating tumors
* TGFB signalling higher in ep treated ith PDL1+LY

```{r}
#mx1=match(colnames(Cancer_counts), infoTableFinal$SampleID)

idx=which(colnames(Cancer_counts)%in%infoTableFinal$SampleID[infoTableFinal$Cohort=="Progression"])
idx2=colnames(Cancer_counts)[idx]
infoTabTemp=infoTableFinal[match(idx2, infoTableFinal$SampleID), ]
infoTabTemp$Fraction=factor(infoTabTemp$Fraction)
levels(infoTabTemp$Treatment)=c("Vehicle", "LY", "PDL1", "PDL1+LY")

CCount2=Cancer_counts[ ,idx2]

#infoTabTemp$PAM50_v2="Basal"
#infoTabTemp$PAM50_v2[grep("Lum", infoTabTemp$PAM50)]="Lum"

## First do a score based on DN vs Ep
a1=glm(infoTabTemp$Fraction~0+t(CCount2), family="binomial")
#summary(a1)


MatrixSumm=matrix(NA, nrow=nrow(CCount2), ncol=10)
PValsSumm=MatrixSumm


for (i in 1:nrow(Cancer_counts)){
  a1=glm(CCount2[i, ]~Fraction+Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp)
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

par(oma=c(2, 0,0,0))

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: All variables")

```

Focus specifically on the DN and Ep samples separately:

```{r}

MatrixSumm=matrix(NA, nrow=nrow(Cancer_counts), ncol=9)
PValsSumm=MatrixSumm

for (i in 1:nrow(Cancer_counts)){
  a1=glm(CCount2[i, infoTabTemp$Fraction=="DN"]~Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp[infoTabTemp$Fraction=="DN", ])
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: DN")

MatrixSumm=matrix(NA, nrow=nrow(Cancer_counts), ncol=9)
PValsSumm=MatrixSumm

for (i in 1:nrow(Cancer_counts)){
  a1=glm(CCount2[i, infoTabTemp$Fraction=="Ep"]~Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp[infoTabTemp$Fraction=="Ep", ])
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: Ep")

#dev.off()
```

Associations: 

* notch signalling with LY treatment
* TGFB with PDL1+LY treatment
* Ras and Wnt signalling lower CD8Fraction
* TP53 with CD8 fraction

### Taking into account directionality

Do the same scoring, taking into account oncogenic vs tumor suppressor activity (i.e.)
Usually, there is no difference. The pathway is increased either way

```{r}
gsListUP=list()
for (i in 1:length(PathwayListRat)){
gsListUP[[i]]=GeneSet(na.omit(PathwayListRat[[i]][which(PathwaySign[[i]]=="OG")]), setName = paste(names(PathwayListRat)[i], "OG", sep="_"), geneIdType=SymbolIdentifier())
}
gsListDOWN=list()
for (i in 1:length(PathwayListRat)){
gsListDOWN[[i]]=GeneSet(na.omit(PathwayListRat[[i]][which(PathwaySign[[i]]=="TSG")]), setName = paste(names(PathwayListRat)[i], "TS", sep="_"), geneIdType=SymbolIdentifier())
}
AllGS=c(gsListUP, gsListDOWN)

CancerRatSig_Dir=GeneSetCollection(AllGS)
# 
Cancer_counts_dir=gsva(assay(dds)[ ,-grep("CD45", colnames(assay(dds)))], CancerRatSig_Dir, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)
# doesn't seem to matter that we convert to TPM or not. Also try the TPMs from the RSEM package
#Imm_counts2=gsva(allTPMFinal,ImmRatSig, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)

#pdf(sprintf("rslt/signatureAnalysis/Main_cancer_Pathways_w_direction_%s.pdf", Sys.Date()), width=6, height=7)


heatmap.plus(Cancer_counts_dir, col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors =cbind(palette()[as.numeric(infoTableFinal$Treatment[match(colnames(Cancer_counts), infoTableFinal$SampleID)])+4], palette()[as.numeric(infoTableFinal$Batch[match(colnames(Cancer_counts), infoTableFinal$SampleID)])], palette()[as.numeric(infoTableFinal$Fraction[match(colnames(Cancer_counts), infoTableFinal$SampleID)])]), scale="row")

cancerCountsMelt_dir=melt(Cancer_counts_dir)
cancerCountsMelt_dir$Var1=as.character(cancerCountsMelt_dir$Var1)
cancerCountsMelt_dir$Fraction=infoTableFinal$Fraction[match(cancerCountsMelt_dir$Var2, infoTableFinal$SampleID)]
cancerCountsMelt_dir$Treatment=infoTableFinal$Treatment[match(cancerCountsMelt_dir$Var2, infoTableFinal$SampleID)]
cancerCountsMelt_dir$Dir=substr(cancerCountsMelt_dir$Var1,  nchar(cancerCountsMelt_dir$Var1)-1, nchar(cancerCountsMelt_dir$Var1))

ggplot(data=cancerCountsMelt_dir, aes(x=Treatment, y=value, col=Fraction))+geom_boxplot()+facet_wrap(~Var1, scales="free_y")

#dev.off()

```

Do a regression analysis for TSG vs ONCO signatures in this pathway


```{r}
mx1=match(colnames(Cancer_counts_dir), infoTableFinal$SampleID)

infoTabTemp=infoTableFinal[mx1, ]
infoTabTemp$Fraction=factor(infoTabTemp$Fraction)
levels(infoTabTemp$Treatment)=c("Vehicle", "LY", "PDL1", "PDL1+LY")

## First do a score based on DN vs Ep

# a1=glm(infoTableFinal$Fraction[mx1]~0+t(Cancer_counts_dir), family="binomial")
# summary(a1)


MatrixSumm=matrix(NA, nrow=nrow(Cancer_counts_dir), ncol=10)
PValsSumm=MatrixSumm


for (i in 1:nrow(Cancer_counts_dir)){
  a1=glm(Cancer_counts_dir[i, ]~Fraction+Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp)
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts_dir)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

#pdf(sprintf("rslt/signatureAnalysis/cancer_pathway_variables_withdirection_%s.pdf", Sys.Date()), height=6, width=6)
par(oma=c(4, 0,0,0))

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: All variables")

MatrixSumm=matrix(NA, nrow=nrow(Cancer_counts_dir), ncol=9)
PValsSumm=MatrixSumm

for (i in 1:nrow(Cancer_counts_dir)){
  a1=glm(Cancer_counts_dir[i, infoTabTemp$Fraction=="DN"]~Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp[infoTabTemp$Fraction=="DN", ])
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts_dir)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: DN")

MatrixSumm=matrix(NA, nrow=nrow(Cancer_counts_dir), ncol=9)
PValsSumm=MatrixSumm

for (i in 1:nrow(Cancer_counts_dir)){
  a1=glm(Cancer_counts_dir[i, infoTabTemp$Fraction=="Ep"]~Treatment+CD8Frac+MHEpCAM+GrowthRate+TumSize+Subtype_compressedList, data=infoTabTemp[infoTabTemp$Fraction=="Ep", ])
  MatrixSumm[i, ]=coefficients(a1)
  PValsSumm[i, ]=summary(a1)$coefficients[ ,4]
}

colnames(PValsSumm)=names(coefficients(a1))
rownames(PValsSumm)=rownames(Cancer_counts_dir)
colnames(MatrixSumm)=colnames(PValsSumm)
rownames(MatrixSumm)=rownames(PValsSumm)

MatrixSumm2=MatrixSumm
MatrixSumm2[which(PValsSumm>0.1, arr.ind = T)]=0

heatmap.2(MatrixSumm2[ ,-1], col=RdBu[11:1], trace="none", main="Contributors to signalling pathway: Ep")

#dev.off()

```

Looking at up vs down genes: are any of these differentially expressed?

```{r}
AllSearch=lapply(AllGS, function(x) geneIds(x))
AllSearchUn=unlist(AllSearch)

DiffGenes=AllSearchUn[which(AllSearchUn%in%rownames(resDNeprslt2))]
TypeGenes=sapply(AllSearch, function(x) which(DiffGenes%in%x))

colSide

heatmap.2(assay(vsd)[ match(DiffGenes, rownames(assay(vsd))), -grep("CD45", colnames(assay(vsd)))],
          trace="none", col=RdBu[11:1], scale="row") # ColSideColors = palette()[colSide],
```


<!--chapter:end:07b-cancer-pathways.Rmd-->

# Immune estimation

In this section, we will look at a number of methods for immune estimation:

1. ssGSEA using known signatures: This includes the Thorsson signatures, as well as signatures for activation and dysfunction as described by Tirosh and in the supplementary tables from Gil del Alcazar.
2. Deconvolution methods (CIBERSORT, TIMER etc)

## ssGSEA

Below, we use the GSVA package and TPM counts to assess variability in the different signatures. We will compare this to:

* growth
* CD8 counts 
* spatial patterns (infiltrating vs restricted, MH index)

```{r}
table(infoTableFinal$MHcut)

gsList=list()
for (i in 1:length(Exp2RatImm)){
gsList[[i]]=GeneSet(Exp2RatImm[[i]], setName = names(Exp2RatImm)[i], geneIdType=SymbolIdentifier())
}

ImmRatSig=GeneSetCollection(gsList)

Imm_counts=gsva(allTPMFinal[ , grep("CD45", colnames(allTPMFinal))],ImmRatSig, mx.diff=T, method="ssgsea", verbose=F, parallel.sz=1, kcdf="Poisson", ssgsea.norm=T)

growthDiff=sapply(1:nrow(Imm_counts), function(x) wilcox.test(Imm_counts[x,  ]~infoTableFinal$Growth[match(colnames(Imm_counts), infoTableFinal$SampleID)])$p.value)
names(growthDiff)=rownames(Imm_counts)

ax1=which(growthDiff<0.05)

SpatDiff=sapply(1:nrow(Imm_counts), function(x) wilcox.test(Imm_counts[x,  ]~infoTableFinal$MHcut[match(colnames(Imm_counts), infoTableFinal$SampleID)])$p.value)
names(SpatDiff)=rownames(Imm_counts)

bx1=which(SpatDiff<0.05)

CD8Diff=sapply(1:nrow(Imm_counts), function(x) wilcox.test(Imm_counts[x,  ]~infoTableFinal$CD8FracCut[match(colnames(Imm_counts), infoTableFinal$SampleID)])$p.value)
names(SpatDiff)=rownames(Imm_counts)

cx1=which(SpatDiff<0.05)

ColTable=cbind(palette()[as.numeric(infoTableFinal$Treatment[match(colnames(Imm_counts), infoTableFinal$SampleID)])+4],                             palette()[factor(infoTableFinal$MHcut[match(colnames(Imm_counts), infoTableFinal$SampleID)])],
palette()[factor(infoTableFinal$Growth[match(colnames(Imm_counts), infoTableFinal$SampleID)])],
palette()[factor(infoTableFinal$CD8FracCut[match(colnames(Imm_counts), infoTableFinal$SampleID)])])
colnames(ColTable)=c("Treatment", "Spatial", "Growth", "CD8")

#pdf(sprintf("rslt/signatureAnalysis/Immune_Pathways_%s.pdf", Sys.Date()), width=6, height=7)
# palette()[as.numeric(infoTableFinal$Batch[match(colnames(Cancer_counts), infoTableFinal$SampleID)])],   
heatmap.plus(Imm_counts, col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors =ColTable, scale="row", symkey=T, main="All CD45 samples")

xidx=which(infoTableFinal$Cohort[grep("CD45", colnames(allTPMFinal))]=="Progression")
xidx

heatmap.plus(Imm_counts[ ,xidx], col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors =ColTable[ xidx, ], scale="row", symkey=T, main="All Progression CD45 samples")
```

Based on wilcoxon tests for differences between growth, cd8 content, spatial arrangement, we can also pull out the significantly different signatures and plot these below:

```{r}
heatmap.plus(Imm_counts[unique(c(ax1, bx1, cx1)), ], col=brewer.pal(11, "RdBu")[11:1], trace="none", ColSideColors =ColTable, scale="row", symkey=T,
             main="significant differences")

AllTables=cbind(growthDiff, CD8Diff, SpatDiff)
colnames(AllTables)=c("growth", "cd8", "mh-idx")
rownames(AllTables)=rownames(Imm_counts)

x1=-log10(AllTables)
x1[which(x1<1, arr.ind = T)]=0


heatmap.2(x1,col=brewer.pal(9, "Blues"), scale="none", trace="none", main="p values of differences" , symmkey = F)
```

For the MH scores and the CD8 scores, we can do a correlation analysis using the raw values

```{r}
CD8Diff=sapply(1:nrow(Imm_counts), function(x) cor(Imm_counts[x, ], infoTableFinal$CD8Frac[match(colnames(Imm_counts), infoTableFinal$SampleID)], use="complete"))

MHDiff=sapply(1:nrow(Imm_counts), function(x) cor(Imm_counts[x, ], infoTableFinal$MHEpCAM[match(colnames(Imm_counts), infoTableFinal$SampleID)], use="complete"))

AllTables2=cbind(CD8Diff, MHDiff)
colnames(AllTables2)=c("CD8cor", "MHcor")
rownames(AllTables2)=rownames(Imm_counts)

heatmap.2(t(AllTables2),col=RdBu[11:1], scale="none", trace="none", main="correlation analysis" )
```

## Deconvolution methods

Deconvolution was performed using the TIMER website, which lists results from TIMER,
XCELL,
CIBERSORT,
EPIC, MMPCOUNTER

For TIDE, we need to:

* compute log(RPKM+1) values
* Determine the values of the reference/or compute a sample average
* Subtract the two
* We can convert from Rat gene names to Human and exclude all the non mapping gnes.

TPM counts were used for this analysis (using Rat gene names)

```{r}
output1=read.csv("../data/RNA_expression/CD45_rgd_10-02-20-estimation_matrix.csv")
colnames(output1)=gsub("X", "", colnames(output1))
CharSpecCD45=read.csv("../data/RNA_expression/CD45-tpm-rgdnames-char-2020-11-22-estimation_matrix.csv")
colnames(CharSpecCD45)=gsub("X", "", colnames(CharSpecCD45))
```


### Overview of the cell types

Below, we will look at the enrichment scores of specific cell types compared to others using these different methods. It appears that most methods have scores which skews towards high representation of T cells:

TIMER for example shows an enrichment of dendritic and CD8 T cells.
EPIC in contrast shows enrichment for CD4+ and to a lesser extend CD8 T cells
MMPCOUNTER puts an unusually large weighting to T cells and this does not fit our FACS analysis
XCELL enriches for T cells

```{r, fig.height=8}
RowNames=c("TIMER", "CIBERSORT$", "CIBERSORT-ABS", "EPIC", "MMCPCOUNTER", "XCELL")
Type=c("enrichment", "fraction", "enrichment", "fraction", "enrichment", "enrichment")

par(mfrow=c(3, 2))

for (i in 1:length(RowNames)){
timSamples=output1[grep(RowNames[i], output1$cell_type), ]
rownames(timSamples)=sapply(strsplit(as.character(timSamples$cell_type), "_"), function(x) x[1])
boxplot(t(timSamples[ ,-1]), las=2, main=RowNames[i], ylab=Type[i])
}
```

### TEMP: comparison of running Char and Prog cohorts separately?

```{r}
lx1=match(colnames(CharSpecCD45), colnames(output1))
T2=output1[ ,lx1]

## Rank all the samples according to increasing size

sizeInfo=infoTableFinal$TumSize[match(colnames(T2)[-1], rownames(infoTableFinal))]
x2=c(colnames(T2)[order(sizeInfo)+1])


##pdf("~/Dropbox (Partners HealthCare)/Carlos' leukocyte project/Manuscript/2F_Char_cell_types.pdf",width=12, height=8)

ax1=grep("TIMER", CharSpecCD45$cell_type)
T1melt=melt(CharSpecCD45[ax1, ])
T2melt=melt(T2[ax1, ])

T1melt$variable=factor(T1melt$variable, x2)
T2melt$variable=factor(T2melt$variable, x2)

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("TIMER:char cohort separately")+theme(axis.text.x = element_text(angle = 90))
ggplot(T2melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("TIMER:char with prog")+theme(axis.text.x = element_text(angle = 90))

ax1=grep("CIBERSORT$", CharSpecCD45$cell_type)
T1melt=melt(CharSpecCD45[ax1, ])
T2melt=melt(T2[ax1, ])

T1melt$variable=factor(T1melt$variable, x2)
T2melt$variable=factor(T2melt$variable, x2)


ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("CIBSERT:char cohort separately")+theme(axis.text.x = element_text(angle = 90))
ggplot(T2melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("CIBERSRT:char with prog")+theme(axis.text.x = element_text(angle = 90))
#dev.off()

```

Associations with size? Perform a correlation test between all of the information above and tumor size

```{r}

CorVals=rep(NA, nrow(CharSpecCD45))
names(CorVals)=CharSpecCD45$cell_type
CorValsP=CorVals

CorVals=sapply(1:nrow(CharSpecCD45), function(x) cor(t(CharSpecCD45[x, -1]), sizeInfo, use="complete"))
CorValsP=sapply(1:nrow(CharSpecCD45), function(x) cor.test(t(CharSpecCD45[x, -1]), sizeInfo, use="complete")$p.value)

naidx=which(CorValsP<0.05)

RNames1=sapply(strsplit(CharSpecCD45$cell_type, "_"), function(x) x[1])
RNamesMethod=sapply(strsplit(CharSpecCD45$cell_type, "_"), function(x) x[2])


df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorVals)
ax1=acast(df2, RNames1~RNamesMethod)

df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorValsP)
ax2=acast(df2, RNames1~RNamesMethod)
ax2[which(ax2>0.1, arr.ind=T)]=0
ax2[which(is.na(ax2), arr.ind = T)]=0

par(oma=c(3, 5, 2, 2))
OutputplotFun(ax1, scaleR="none", main="cell type correlation", classN="no", sigMat=ax2)

```


### Comparison with FACS data

In this section, we compare how well the estimates from RNAseq deconvolution methods associate with FACS data.

```{r, imm-assoc-facs}
## annotate the FACS data here

infoTableFinal$Name2=NA
infoTableFinal$Name2[which(infoTableFinal$Fraction=="CD45")]=paste(infoTableFinal$Rat_ID[which(infoTableFinal$Fraction=="CD45")], infoTableFinal$Location[which(infoTableFinal$Fraction=="CD45")], sep="")
m2=match(m1, infoTableFinal$Name2)

## get rid of the NA samples
naom=infoTableFinal$SampleID[m2[which(!is.na(m2))]]
mid=m1[which(!is.na(m2))]

lx1=Fdata[, c(1, match(mid, m1))]
out2=output1[, c(1,match(naom, colnames(output1)))]
colnames(lx1)=colnames(out2)

# Run all the association tests here
## New Table
# -cd8
# Th
# Tregs
# B cells
# Macrophage

# 
MergedTable=matrix(NA, ncol=21, nrow=1)
colnames(MergedTable)=colnames(out2)

tx1=sapply(strsplit(as.character(out2$cell_type), "_"), function(x) x[1])
MethodSumm=sapply(strsplit(as.character(out2$cell_type), "_"), function(x) x[2])
tabtx1=table(tx1)
TheseFracs=names(tabtx1)[which(tabtx1>3)]

testSetB=c("B cell", "MHCII-hi", "MHCII-lo", "Monocyte", "Neutrophil", "NK cells", "CD8", "Treg")
#  "CD8", "Th", "Treg", "B cells", "NK cells", "DC", "Neutrophil", "Monocyte", "gd T", "MHCII-hi", "MHCII-lo")
testSet=TheseFracs[-2]#c("CD8", "CD4", "Treg", "B cell", "NK", "dendritic", "Neutrophil", "Monocyte", "gamma delta", "M1", "M2")
 
CMat=matrix(NA, nrow=length(testSet), ncol=length(unique(MethodSumm)))
rownames(CMat)=testSet
colnames(CMat)=unique(MethodSumm)
 
PMat=CMat
#testSet="M2"
#testSetB="MHCII-lo"

for (j in 1:length(testSet)){
CD8Table=rbind(lx1[grep(testSetB[j], lx1$cell_type), ],
               out2[which(tx1==testSet[j]), ])
CD8Table[1,1]=paste(testSetB[j], "facs", sep="_")
ms=MethodSumm[which(tx1==testSet[j])]
par(mfrow=c(3,3))


cVals=sapply(2:nrow(CD8Table), function(x) cor(t(CD8Table[1, -1]), t(CD8Table[x, -1]), use="complete"))
cVals2=sapply(2:nrow(CD8Table), function(x) cor.test(t(CD8Table[1, -1]), t(CD8Table[x, -1]), use="complete")$p.value)

CMat[j, match(ms, colnames(CMat))]=cVals
PMat[j, match(ms, colnames(PMat))]=cVals2

MergedTable=rbind(MergedTable, CD8Table)

#for (i in 2:nrow(CD8Table)){
  #a1=cor(t(CD8Table[1, -1]), t(CD8Table[i, -1]), use="complete")
  #plot(t(CD8Table[1, -1]), t(CD8Table[i, -1]), main=CD8Table[i,1], ylab="method", xlab="FACS")
  #text(min(t(CD8Table[1, -1]), na.rm=T)*2, max(t(CD8Table[i, -1]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
  
}


##for the following, find the terms and calculate the sum

testSetB=c("Macro", "Th", "B cell")
testSet=c("Macro", "CD4", "B cell")
rmThese=c("M0", "naive", NULL)

savTemp=matrix(NA, nrow=3, ncol=ncol(CMat))
rownames(savTemp)=paste("all", testSet, sep="")
savTempP=savTemp


for (j in 1:length(testSetB)){
  
  CD8Table=lx1[grep(testSetB[j], lx1$cell_type), ]
  CD8Table=colSums(CD8Table[, -1])
  #rownames(CD8Table)="facs"
  
  outB=out2[grep(testSet[j], out2$cell_type), ]
  rm2=grep(rmThese[j], outB$cell_type)
  
  if (length(na.omit(rm2))>0){
    outB=outB[-rm2, ]
  }
  
  namOut=sapply(strsplit(as.character(outB$cell_type), "_"), function(x) x[2])
  nam2=unique(namOut[which(duplicated(namOut))])
  
  outC=sapply(nam2, function(x) colSums(outB[which(namOut==x), -1 ]))
  outB=outB[-which(namOut%in%nam2), ]
  rownames(outB)=sapply(strsplit(as.character(outB$cell_type), "_"), function(x) x[2])
  
  allD=rbind(CD8Table, outB[, -1], t(outC))
  rownames(allD)[1]="facs"
  allD$method=rownames(allD)
  
 # allD=data.matrix(allD)
  
#pdf(sprintf("rslt/Immune decomposition/correlations_combined_%s.pdf", testSetB[j]), width=10, height=10)

#ggplot(temp8, aes(x=method, y=value, col=variable))+geom_bar(stat="identity")+facet_wrap(~variable, scale="free_y")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

par(mfrow=c(3,3))

for (i in 2:nrow(allD)){
  a1=cor(t(allD[1, -ncol(allD)]), t(allD[i, -ncol(allD)]), use="complete")
  a2=cor.test(t(allD[1, -ncol(allD)]), t(allD[i, -ncol(allD)]), use="complete")$p.value
  savTemp[j, match(rownames(allD)[i], colnames(CMat))]=a1
  savTempP[j, match(rownames(allD)[i], colnames(CMat))]=a2
# plot(t(allD[1, -ncol(allD)]), t(allD[i,-ncol(allD)]), main=allD[i,ncol(allD)], ylab="method", xlab="FACS")
#  text(min(t(allD[1, -ncol(allD)]), na.rm=T)*2, max(t(allD[i, -ncol(allD)]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
  
}

cell_type=paste(testSetB[j], allD$method, sep="_all_")

MergedTable=rbind(MergedTable, cbind(cell_type, allD[ ,-21]))

}

CorMatAll=rbind(CMat, savTemp)
CorMatP=rbind(PMat, savTempP)

par(oma=c(2, 0,0,5))
heatmap.2(CorMatAll, col=RdBu[11:1], scale="none", trace="none", main="correlation FACS and GE")

```

We can plot associations between the different cell types below, here selecting:

* Bcells
* CD8 T cells
* M2 macophage
* M1 macrophage

```{r, fig.height=7}
testSetB=c("CD8",  "B cells", "MHCII-hi", "MHCII-lo")
testSet=c("CD8", "B cell","M1", "M2")

par(mfrow=c(3,3))

for (j in 1:length(testSetB)){ 
CMat=matrix(NA, ncol=length(testSet), nrow=10) 
CD8Table=rbind(lx1[grep(testSetB[j], lx1$cell_type), ],
               out2[grep(testSet[j], out2$cell_type), ])

for (i in 2:nrow(CD8Table)){
  a1=cor(t(CD8Table[1, -1]), t(CD8Table[i, -1]), use="complete")
  plot(t(CD8Table[1, -1]), t(CD8Table[i, -1]), main=CD8Table[i,1], ylab="method", xlab="FACS")
  text(min(t(CD8Table[1, -1]), na.rm=T)*2, max(t(CD8Table[i, -1]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
}
mtext(testSetB[j], side=3, line=-2, outer=T)
  
}

```

### Associate with Treatment

Look at association with treatment, growth and spatial infiltration for each method. 

Associations with treatment:

* higher CD4, CD8 in most treatments 
* growth: stable associated with higher CD8
* infiltration: more neutrophils and CD8? maybe CD4 cells


```{r, immune-assoc-outcome, cache=T}
#sizeCutOff=7

MergedTablemelt=melt(MergedTable[-1, ])
MergedTablemelt$Treatment=infoTableFinal$Treatment[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$Growth=infoTableFinal$Growth[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$InfRes=infoTableFinal$MHcut[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$cell_type2=sapply(strsplit(MergedTablemelt$cell_type, "_"), function(x) x[1])
MergedTablemelt$method=sapply(strsplit(MergedTablemelt$cell_type, "_"), function(x) x[length(x)])

unValues=unique(MergedTablemelt$cell_type2)

CompTest=list()

for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=Treatment, y=as.numeric(value), col=Treatment))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Treatment"))
print(p)
p<-ggplot(ax, aes(x=Growth, y=as.numeric(value), col=Growth))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Growth"))
print(p)
p<-ggplot(ax, aes(x=InfRes, y=as.numeric(value), col=InfRes))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Infiltration"))
print(p)

unT=sort(unique(ax$Treatment))
unB=sort(unique(ax$method))
Outcome1=matrix(NA, nrow=5, ncol=length(unB))

rownames(Outcome1)=c(paste(unT[1:3], "vs.Vehicle", sep=""), "Grow.Stable", "Inf.res")
colnames(Outcome1)=unB

for (j in 1:nrow(Outcome1)){
Outcome1[1 , ]=sapply(unB, function(x) wilcox.test(ax$value[which(ax$Treatment=="LY" & ax$method==x)], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[2 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Treatment=="PDL1" & ax$method==x], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[3 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Treatment=="PDL1+LY" & ax$method==x], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[4 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Growth=="growing" & ax$method==x], 
                  ax$value[ax$Growth=="stable" & ax$method==x])$p.value)
Outcome1[5 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$InfRes=="inf" & ax$method==x], 
                  ax$value[ax$InfRes=="res" & ax$method==x])$p.value)

}
CompTest[[i]]=t(Outcome1)
o1=Outcome1
o1[which(o1<0.05, arr.ind=T)]=3
o1[which(o1<0.1, arr.ind=T)]=2
o1[which(o1<=1, arr.ind=T)]=0
#heatmap.2(o1, col=brewer.pal(9, "Blues"), scale="none", trace="none", main=paste("pvalue summary", unValues[i]), Colv = NA, Rowv = NA)
}
```

Using wilcox tests for significance, we can make the above comparisons and see if there is an association with outcome:

* There are differences in B-cell content between LY vs V comaprisons using xcell and cibersort
* Macrophages are different in PDL1+LY

### Association with Growth 

```{r}
for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=Growth, y=as.numeric(value), col=Growth))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Growth"))
print(p)
}

```

### Association with infiltration 

```{r}
for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=InfRes, y=as.numeric(value), col=InfRes))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Infiltration"))
print(p)
}

```
### Summary of the outcome

```{r, fig.width=8}
CompTest2=do.call(rbind, CompTest)
 
write.csv(CompTest2, file=sprintf("outputs/p_values_differences_treatment_growth_infiltration_%s.csv", Sys.Date()))

scroll_box(kable(CompTest2, format="html"),
         height="300px", width="100%")

CompTest2=data.frame(CompTest2)
# CompTest2$Method=sapply(strsplit(rownames(CompTest2), "_"), function(x) x[2])
# CompTest2$CellType=sapply(strsplit(rownames(CompTest2), "_"), function(x) x[1])
# 
# x2=unique(CompTest2$CellType[which(duplicated(CompTest2$CellType))])
# 
# CompTest3=CompTest2[which(CompTest2$CellType%in%x2), ]
# CompTest3melt=melt(CompTest3)
# 
# CompTest3melt$P2=ifelse(CompTest3melt$value<0.05, "**", ifelse(CompTest3melt$value<0.1, "*", "ns"))
# 
# 
# 
# p=ggplot(CompTest3melt, aes(x=CellType, y=Method, fill=P2))+geom_tile()+facet_wrap(~variable)+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ylab("No. differential genes")+scale_fill_manual(values=c("#084594", "#2171b5", "#deebf7"))+ggtitle("p values of comparisons")
# print(p)

##dev.off()
```



<!--chapter:end:08-immune-estimation.Rmd-->

# BCR clonotype analysis

## Processing summary

Fastq files have previously been run through TRUST4 using the Rn6 BCR annotations using the following code (not run here). Note that the bcr/tcr .fa files were assembled using the ensembl annotation (these annotations are not present in the UCSC genomic files). Annotation files for the rn6 BCR regions are available at [IMGT](http://www.imgt.org//download/V-QUEST/IMGT_V-QUEST_reference_directory/Rattus_norvegicus/), but TCR regions are not available

```{r, eval=F, echo=T}
# obtain the gene names for rat:
library(biomaRt)
human = useEnsembl("ensembl", mirror="useast", dataset = "hsapiens_gene_ensembl")
rat = useEnsembl("ensembl", mirror="useast", data="rnorvegicus_gene_ensembl")
TS = human_igg_trv_list
Hum2RatProt = getLDS(attributes = c("hgnc_symbol", "ensembl_transcript_id"), filters = "hgnc_symbol",  values = TS , mart = human, attributesL = c("rgd_symbol", "ensembl_transcript_id”, “ensemble_gene_id"), martL = rat, uniqueRows=T)
write.table(unique(Hum2RatProt$ensemble_gene_id), "ensbl_rat_bcr.txt", quote=F, row.names=F,colnames=F)

# obtain the tcr/bcr.fa file
#(Note that BuildDatabaseFa.pl needs to be edited on lines 95, 102, 114 and 121 to use transcript_id or gene_id instead)

perl BuildDatabaseFa.pl Rattus_norvegicus.Rnor_6.0.dna_sm.toplevel.fa Rattus_norvegicus.Rnor_6.0.99.gtf ensbl_rat_bcr.txt > bcrtcr_rat_ens.fa

# Obtain the reference annotation file
perl BuildImgtAnnot.pl Rattus_norvegicus > Rnor_IMGT+C.fa

# Run TRUST (below is single end)
./run-trust4 -u 20170125_NMU7_Tumor_RLU_CD45_CGDA5146_S1_R1_001.fastq.gz -f bcrtcr_rat_ens.fa --ref Rnor_IMGT+C.fa
```


```{r, trust4, cache=T}
#Annotation file: Load in an annotation file indicating all the samples, batch effects etc 


TRUST4path="../data/TRUST4/"
TRUST4files=dir(TRUST4path,"*.tsv")
#FileNames=sapply(strsplit(TRUST4files, "_report.tsv"), function(x) x[1])
matchidx=match(TRUST4files, infoTableFinal$TRUSTName)

#RepNames=paste(infoTableFinal$Rat_ID, tempAnnot$Location, tempAnnot$Fraction, sep="_")[matchidx]
# load in all the files and save the list to file
RatTrust=lapply(TRUST4files, function(x) read.delim(paste(TRUST4path, x, sep=""), sep="\t"))
names(RatTrust)=infoTableFinal$SampleID[matchidx]


TRUST4path="../data/TRUST4/matchedNormal/"
TRUST4files=dir(TRUST4path,"*.tsv")
#FileNames=sapply(strsplit(TRUST4files, "_report.tsv"), function(x) x[1])
FileNames=paste(substr(TRUST4files, 10, 12), "matchedNMUCD45", sep="_")
RatTrustNormal=lapply(TRUST4files, function(x) read.delim(paste(TRUST4path, x, sep=""), sep="\t"))
names(RatTrustNormal)=FileNames

RatTrust=c(RatTrust, RatTrustNormal)

save(RatTrust, file=sprintf("outputs/Rat_TRUST4_%s.RData", Sys.Date()))

```

## Summary Stats


Firstly, look at the number of BCR regions which have been identified by TRUST4. In green are the CD45 populations, which as expected appear to have a higher number of clonotypes compared to the epithelial and the double-negative populations (in read and orange). 

```{r}
NSamples=sapply(RatTrust, nrow)
NSamplesCt2=sapply(RatTrust, function(x) length(which(x$X.count>=2)))
NSamplesCDR3comp=sapply(RatTrust, function(x) length(which(x$CDR3aa!="partial")))
NSamplesCDR3compCt2=sapply(RatTrust, function(x) length(which(x$CDR3aa!="partial" & x$X.count>=2)))

TableOut=cbind(NSamples, NSamplesCt2, NSamplesCDR3comp, NSamplesCDR3compCt2)

matchidx=match(rownames(TableOut), infoTableFinal$SampleID)
ColOut=factor(paste(infoTableFinal$Fraction[matchidx], infoTableFinal$Batch[matchidx]))
#palette(c("#e5f5e0","#a1d99b", "#31a354",  "#fd8d3c","#fa9fb5", "#f03b20", "#005824"))

#pdf(sprintf("rslt/TRUST4/BCR_summary_QC_%s.pdf", Sys.Date()), height=5, width = 7)

# plot the clonotype diversity, color-code according to both batch and the sample used
par(mar = c(4, 4, 4, 2),  xpd = TRUE)
barplot(NSamplesCt2+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Overview of clonotype diversity (2+ reads)", col=ColOut, cex.names = 0.75)
legend("top", inset = c(-0.5, 0.03),  legend = levels(ColOut),  pch = c(19, 19, 19, 19, 19),  col = c(1:6), horiz = T)

# plot the number of full vs partial clonotypes
PartialvsFull=rbind(NSamplesCDR3compCt2,NSamplesCt2-NSamplesCDR3compCt2)
rownames(PartialvsFull)=c("full", "partial")


par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(PartialvsFull+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Proportion of full vs partial CDR3a", col=c(1:2), cex.names = 0.75)
legend("bottom", inset = c(-0.5, -0.5),  legend = c("full", "partial"),  pch = c(19, 19),  col = c(1:2), horiz = T)

par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(t(TableOut[ which(infoTableFinal$Fraction[matchidx]=="CD45"),]+1), las=2,log ='y', ylab = "Number of BCR clonotypes", main="Clonotype diversity CD45+ samples", col=c(1:4), cex.names = 0.75, beside = T)
legend("bottom", inset = c(-0.5, -0.5),  legend = c("# clonotypes", "clonotypes >2reads", "complete CDR3", "both"),  pch = c(19, 19, 19),  col = c(1:4), horiz = T)

par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(NSamplesCDR3compCt2+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Filtered Clonotypes based on batch", col=ColOut, cex.names = 0.75, beside = T)
legend("top", inset = c(-0.5, 0.03),  legend = levels(ColOut),  pch = c(19, 19, 19, 19, 19),  col = c(1:5), horiz = T)

#dev.off()

```

We will refine the above plot to contain only the CD45 population and assess:

* number of clonotypes
* number of clonotypes with at least 2 reads
* number of clonotypes which have a complete CDR3a region

Note: although this does not look like a big drop, the data is plotted on a log-scale. For example, in the control 4 (first column) a quarter of the clonotypes have at least 2 counts and about half have a complete CDR3 sequence.

For the following analyses, the clonotypes are filtered to <span style="color:red"> only clonotypes with at least 2 supporting reads and a complete VDJ read </span>. When applying this restriction, we have the following distribution of BCR regions. Almost all the epithelial cases do not have supporting reads, and few of the DN cases have supporting reads too.

```{r}
RatTrustB=lapply(RatTrust, function(x) x[which(x$CDR3aa!="partial" & x$X.count>=2), ])
for (i in 1:length(RatTrustB)){
  RatTrustB[[i]]$frequency=RatTrustB[[i]]$X.count/sum(RatTrustB[[i]]$X.count)
}
```

## Diversity metrics

We will assess BCR diversity using the following metrics:

** Shannon index **

The shannon index is computed by:

* filtering through reads of interest
* recalculate the fraction such that the new list sums to 1
* compute entropy as the sum of log(freq_x)*freq_x amongst all populations x
* compute the maximum entropy expected for that case -log(1/N), where N is the number of populations present
* to determine confidence intervals, bootstrap the population (500 times) and compute the expected entropy

** Gini index **

The Gini index can be considered as an inverse of the Shannon index 

** Top Clonotypes **

We will see the proportion of the BCR repertoire which is computed using the top 10 frequent clones.
This will give an idea of whether there is a clonal expansion 

```{r, warning=F,message=F}
# compute values here
Div1=sapply(RatTrustB, function(x) -sum(x$frequency*log(x$frequency), na.rm=T))
EDiv=sapply(NSamplesCDR3compCt2, function(x) -log(1/x))
NormDiv=Div1/EDiv

## Shannon index
# bootstrap rslt
BSrslt=sapply(RatTrustB, function(x) tryCatch(BootstrapShannonIdx(x[ ,1], 1000), error=function(e) c(NA, NA)))
# divide the CI by the maximum possible diversity

BSCI=t(BSrslt)/EDiv

df=data.frame(sample=rownames(BSCI), Val=NormDiv, Lower=BSCI[ , 1], Upper=BSCI[ ,2 ], Type=infoTableFinal$Fraction[matchidx], Batch=infoTableFinal$Batch[matchidx])

## Gini index

Gini=sapply(RatTrustB, function(x) gini(x$frequency))

PGini=sapply(RatTrustB, function(x) tryCatch(PermuteGini(x$X.count, 1000), error=function(e) c(NA, NA)))

df$Calc="shannon"

df2=data.frame(sample=df$sample, Val=Gini, Lower=PGini[1, ], Upper=PGini[2, ], Type=df$Type, Batch=df$Batch,
               Calc="Gini")

dfAll=rbind(df, df2)

## Top Clonotypes

TopClones=sapply(RatTrustB, function(x) sum(x$frequency[1:5], na.rm = T))
TopClones[which(NSamplesCDR3compCt2==0)]=0
df2$Val=TopClones
df2$Calc="Top10"
df2$Lower=TopClones
df2$Upper=TopClones

dfAll=rbind(dfAll, df2)

dfAll$Batch=as.character(dfAll$Batch)
dfAll$Batch[grep("matchedNMU", rownames(dfAll))]="match"
dfAll$Type[grep("matchedNMU", rownames(dfAll))]="CD45"
#ggplot(df[df$Type=="CD45", ], aes(x=sample, y=Val, fill=Type))+geom_bar(stat="identity")+facet_grid(~Batch, scales="free_x", space="free")+geom_errorbar( aes(ymin=Lower, ymax=Upper), width=.2)+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("Shannon idx of BCR diversity")

```

The following plot demonstrates the relationship between the above metrics

```{r}
#pdf(sprintf("rslt/TRUST4/summary_Scores_diversity_%s.pdf", Sys.Date()), width=7, height=5)

ggplot(dfAll[dfAll$Type=="CD45", ], aes(x=sample, y=Val, fill=Type))+geom_bar(stat="identity")+facet_grid(Calc~Batch, scales="free_x", space="free")+geom_errorbar( aes(ymin=Lower, ymax=Upper), width=.2)+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("BCR diversity across samples")+ylab("index value")

#dev.off()
```

Notice that some samples have very few clones. An example is 5RB which is represented by a single clonotype, accounting for the absence of a Gini or shannon index

## Compare the characterisation cohort

In the characterisation cohort, we have 3 cases which have CD45 samples in both the tumor and a matched NMU treated mammary gland.
Is there a difference in the clonotypes between these samples?

```{r}
CharTemp=dfAll[which(dfAll$Type=="CD45" & dfAll$Batch%in%c("1", "match")), ]
CharTemp$Batch[grep("Control", CharTemp$sample)]="Normal"
Nclonotypes=TableOut[which(rownames(TableOut)%in%CharTemp$sample), ]
Nclonotypes2=melt(Nclonotypes)
Nclonotypes2$Case="tumor"
Nclonotypes2$Case[grep("match", Nclonotypes2$Var1)]="mammary"
Nclonotypes2$Case[grep("Control", Nclonotypes2$Var1)]="control"

#pdf(sprintf("rslt/TRUST4/compare_mammary_vs_tumor_%s.pdf", Sys.Date()), width=8, height=6)
a1=sapply(unique(CharTemp$Calc), function(x) wilcox.test(CharTemp$Val[CharTemp$Calc==x & CharTemp$Batch==1], CharTemp$Val[CharTemp$Calc==x & CharTemp$Batch=="match"])$p.value)
p=ggplot(CharTemp, aes(x=Batch, y=Val))+geom_boxplot()+facet_grid(~Calc)+ggtitle(sprintf("wilcox pval: Gini %s, Shannon %s, Top10 = %s", round(a1[2],2), round(a1[1],2), round(a1[3],2)))+geom_jitter(col="grey")+theme_bw()
print(p)

a1=sapply(unique(Nclonotypes2$Var2), function(x) wilcox.test(Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="tumor"], 
                                                             Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="mammary"])$p.value)

ann_text2 <- data.frame(lab=paste("p=", round(a1,4),sep=""), Var2=unique(Nclonotypes2$Var2), Case=1, value=2)
p=ggplot(Nclonotypes2, aes(x=Case, y=value))+geom_boxplot()+facet_grid(~Var2)+ggtitle("Nclonotype with different filters")+geom_jitter(col="grey")+theme_bw()+
  geom_text(data=ann_text2, aes(label=lab))
print(p)

#dev.off()
```


## Associate with clinicopathological data

We will associate the following metrics:

* total unique clones
* diversity

with the following immune data:

* CD45 fraction (from FACS)
* CD8 fraction (from WSI)
* MH-mixing indices
* Tumor Size
* Growth
* Treatment

```{r}
TrustTab=infoTableFinal[matchidx, ]
TrustTab$TrustNclonotypes=TableOut[match(TrustTab$SampleID, rownames(TableOut)) ,2]
TrustTab$TrustShannon=dfAll$Val[match(TrustTab$SampleID, dfAll$sample) ]
TrustTab$TrustTop10=df2$Val[match(TrustTab$SampleID, df2$sample)]
TrustTab$TrustGini=dfAll$Val[which(dfAll$Calc=="Gini")[match(TrustTab$SampleID, dfAll$sample)] ]
TrustTab$CD45FACS=as.numeric(as.character(Cdata$X..CD45..by.FACS.[match(TrustTab$TumorID, Cdata$TumorID)]))
TrustTab$UnclassFrac=as.numeric(as.character(Cdata$UnclassFraction[match(TrustTab$TumorID, Cdata$TumorID)]))
CD45F=which(TrustTab$Fraction=="CD45")
#TrustTab=TrustTab[TrustTab$Fraction=="CD45", ]

paramSearch=c("CD8Frac", "TumSize", "CD45FACS", "MHEpCAM", "MHSMA", "IFEpCAM", "IFSMA", "UnclassFrac")
FeatTrust=c("TrustNclonotypes", "TrustShannon", "TrustGini", "TrustTop10")

Nclon=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[ CD45F,c("TrustNclonotypes")], use="complete", method="spearman")$p.value)
SDiv=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[CD45F ,c("TrustShannon")], use="complete", method="spearman")$p.value)
GDiv=sapply(paramSearch, function(x) cor.test(TrustTab[ CD45F,x], TrustTab[CD45F ,c("TrustGini")], use="complete", method="spearman")$p.value)
TDiv=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[CD45F ,c("TrustTop10")], use="complete", method="spearman")$p.value)

AllSmerge=rbind(Nclon, SDiv, GDiv, TDiv)

#pdf(sprintf("rslt/TRUST4/association_trustmetrics_clinicopathological_%s.pdf", Sys.Date()), width=10, height=8)

heatmap.2(AllSmerge, scale="none", col=RdBu[11:1], trace="none", main="p values of associations")

par(mfrow=c(2,2))
idx=which(AllSmerge<0.1, arr.ind=T)
for (i in 1:nrow(idx)){
  a1=cor.test(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], use="complete", method="spearman")
  plot(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], xlab=FeatTrust[idx[i, 1]], ylab=paramSearch[idx[i, 2]],
       main=sprintf("cor:%s p:%s", round(a1$estimate,2), round(a1$p.value,2)))
  text(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], rownames(TrustTab)[CD45F], cex=0.75)
}

CD45F2=which(TrustTab$Fraction=="CD45" & TrustTab$Cohort=="Progression")
## associate with growth and treatment type
par(mfrow=c(2,2))
boxplot(TrustTab[CD45F2 ,c("TrustNclonotypes")]~TrustTab[CD45F2, "Treatment"], main="BCR # clonotypes")
boxplot(TrustTab[CD45F2 ,c("TrustShannon")]~TrustTab[CD45F2, "Treatment"], main="BCR shannon idx")
boxplot(TrustTab[CD45F2 ,c("TrustGini")]~TrustTab[CD45F2, "Treatment"], main="BCR Gini idx")
boxplot(TrustTab[CD45F2 ,c("TrustTop10")]~TrustTab[CD45F2, "Treatment"], main="BCR Trust Top 10")

par(mfrow=c(2,2))
boxplot(TrustTab[CD45F2 ,c("TrustNclonotypes")]~TrustTab[CD45F2, "Growth"], main="Growth: BCR # clonotypes")
boxplot(TrustTab[CD45F2 ,c("TrustShannon")]~TrustTab[CD45F2, "Growth"], main="Growth: BCR shannon idx")
boxplot(TrustTab[CD45F2 ,c("TrustGini")]~TrustTab[CD45F2, "Growth"], main="Growth: BCR Gini idx")
boxplot(TrustTab[CD45F2 ,c("TrustTop10")]~TrustTab[CD45F2, "Growth"], main="Growth: BCR Trust Top 10")

par(mfrow=c(2,2))
boxplot(TrustTab[CD45F2 ,c("TrustNclonotypes")]~TrustTab[CD45F2, "SpatialManual"], main="Spatial Manual: BCR # clonotypes")
boxplot(TrustTab[CD45F2 ,c("TrustShannon")]~TrustTab[CD45F2, "SpatialManual"], main="Spatial Manual: BCR shannon idx")
boxplot(TrustTab[CD45F2 ,c("TrustGini")]~TrustTab[CD45F2, "SpatialManual"], main="Spatial Manual: BCR Gini idx")
boxplot(TrustTab[CD45F2 ,c("TrustTop10")]~TrustTab[CD45F2, "SpatialManual"], main="Spatial Manual: BCR Trust Top 10")

#dev.off()
```


## Associate with signature scores

Compare to B cell counts and activation status based on RNA-seq

* B cell signature enrichments scores (from RNA data)

```{r}
bidx=grep("B cell", output1$cell_type)
idx2=match(TrustTab$SampleID, colnames(output1))

Bsig=output1[bidx, na.omit(idx2)]
rownames(Bsig)=output1$cell_type[bidx]


Bassoc=sapply(FeatTrust, function(y) sapply(1:nrow(Bsig), function(x) cor( t(Bsig[x, ]),(TrustTab[CD45F, y]), use="complete", method="spearman")))
Bassoc2=sapply(FeatTrust, function(y) sapply(1:nrow(Bsig), function(x) cor.test( t(Bsig[x, ]),(TrustTab[CD45F, y]), use="complete", method="spearman")$p.value))
rownames(Bassoc)=rownames(Bsig)

BassocM=Bassoc
BassocM[which(Bassoc2<0.1, arr.ind=T)]=0


#pdf(sprintf("rslt/TRUST4/association_Bcell_signatures_%s.pdf", Sys.Date()), width=7, height=6)
par(oma=c(3, 0,0,5))
heatmap.2(Bassoc, scale="none", trace="none", col=RdBu[11:1], main="correlation")
heatmap.2(BassocM, scale="none", trace="none", col=RdBu[11:1], main="significant associations p<0.1 only")
#dev.off()
```

* B cell frequencies based on FACS:

```{r}
lx1=match(colnames(Fdata), gsub("_", "", unlist(strsplit( rownames(TrustTab), "_CD45"))))

#pdf(sprintf("rslt/TRUST4/BCR_association_FACS_%s.pdf", Sys.Date()), width=8, height=8)
par(mfrow=c(2,2))
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustNclonotypes[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustNclonotypes[lx1], xlab="B cell FACS fraction", ylab="# clonotypes", main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2) ,sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustNclonotypes[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustShannon[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustShannon[lx1], xlab="B cell FACS fraction", ylab="Shannon Index",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustShannon[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustGini[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustGini[lx1], xlab="B cell FACS fraction", ylab="Gini Index",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustGini[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustTop10[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustTop10[lx1], xlab="B cell FACS fraction", ylab="Top10",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustTop10[lx1], TrustTab$TumorID[lx1])
#dev.off()

```

## Check whether the clonotype percentages match with gsva signatures or CD20 populations

associate with immune signature scores (ssgsea)
fdr adjust the correlation p values

```{r}
#s1=dfAll[which(dfAll$Type=="CD45" & dfAll$Calc=="Gini"), ]
x1=match(TrustTab$SampleID, colnames(Imm_counts))
SGiniCor=sapply(1:nrow(Imm_counts), function(x) cor(TrustTab[CD45F, "TrustGini"], Imm_counts[ x, na.omit(x1) ], use="complete"))
SGiniCorP=sapply(1:nrow(Imm_counts), function(x) cor.test(TrustTab[CD45F, "TrustGini"], Imm_counts[ x, na.omit(x1) ], use="complete")$p.value)
SGiniCorPadj=p.adjust(SGiniCorP, "fdr")

#s1=dfAll[which(dfAll$Type=="CD45" & dfAll$Calc=="shannon"), ]
#x1=match(s1$sample, infoTableFinal$SampleID)
SShanCor=sapply(1:nrow(Imm_counts), function(x) cor(TrustTab[CD45F, "TrustShannon"], Imm_counts[ x, na.omit(x1) ], use="complete"))
SShanCorP=sapply(1:nrow(Imm_counts), function(x) cor.test(TrustTab[CD45F, "TrustShannon"], Imm_counts[ x, na.omit(x1) ], use="complete")$p.value)
SShanCorPadj=p.adjust(SShanCorP, "fdr")

OutputCorrs=rbind(SGiniCor, SShanCor)
colnames(OutputCorrs)=rownames(Imm_counts)
par(oma=c(4, 0,0,0))
barplot(OutputCorrs, beside=T, las=2, ylab="correlation coefficient")
text(which(SGiniCorPadj<0.1)*3-1.5, 0.3, "*", col="red")
text(which(SShanCorPadj<0.1)*3+0.5, 0.3, "*", col="blue")
legend("topleft", c("gini", "shannon"), col=c("grey35", "grey85"), pch=c(19, 19))

```


<!--chapter:end:09-clonotype.Rmd-->

# Whole Genome Sequencing Mutations

Whole genome sequencing was performed on XX samples by the new york genome centre.
The pipeline involves:

<span style="color:red"> Insert information on the NYGC pipeline here </span>

## Data 

In this section, we load the maf output files and create lists which

* filter out coding mutations
* Determine mutational signatures by:
    * Creating bed files with genomic locations of the SNP +- 1 base location
    * Extracting the nucleotide sequence using bedtools
    * Convert all mutations to C > N and T > N to obtain 96 mutational signatures
    * run with single sample SigProfiler to obtain the signature scores
* Annotate data with common human variants

```{r, load-mutations, cache=T}
# Load and save for the first time here

mafdir='../data/wholegenome_mutations/maf/'
x1=dir(mafdir, 'annotated.maf')
#names2=sapply(strsplit( x1,"--"), function(x) x[1])
AllMutWGS=lapply(x1, function(x) read.delim(paste(mafdir, x, sep=""), sep="\t", skip = 1))
names(AllMutWGS)=sapply(strsplit( x1,"--"), function(x) x[1])
# # ## summary of the number of mutations?
print('no of mutations')
TotCount=lapply(AllMutWGS, nrow)

SearchVars=c("Splice_Site", "Nonstop_Mutation", "Nonsense_Mutation", "Missense_Mutation", "Frame_Shift_Ins", "Frame_Shift_Del")

AllMutWGScoding=lapply(AllMutWGS, function(x) x[ x$Variant_Classification%in%SearchVars, ])
A2=sapply(AllMutWGScoding, nrow)

# Save the combined mutation lists
save(AllMutWGS, AllMutWGScoding, file=sprintf("outputs/WGS_mutations_coding_%s.RData", Sys.Date()))

#load('data/wholegenome_mutations/WGS_mutations_coding_2020-10-14.RData')
MeltWGSCoding=melt(AllMutWGScoding, measure.vars=c("Tumor_Sample_Barcode"))
MeltWGSCoding$Hum_Gene=SymHum2Rat$HGNC.symbol[match(MeltWGSCoding$Gene_Symbol, SymHum2Rat$RGD.symbol)]
MeltWGSCoding$Hum_Gene[which(is.na(MeltWGSCoding$Hum_Gene))]=toupper(MeltWGSCoding$Gene_Symbol[which(is.na(MeltWGSCoding$Hum_Gene))])
MutAllCosmic=lapply(AllMutWGScoding, function(x) x[which(x$Gene_Symbol%in%RatCosmic), ])
MeltCosmic=melt(MutAllCosmic, measure.vars=c("Tumor_Sample_Barcode"))
```

```{r}
# Find complete numbers here, so we don't have to go back 
TotCount=sapply(AllMutWGS, nrow)
SearchVars=c("Splice_Site", "Nonstop_Mutation", "Nonsense_Mutation", "Missense_Mutation", "Frame_Shift_Ins", "Frame_Shift_Del")

head(TotCount)
```

### Extract mutation signatures

Annotate the files so that the nucleotide codon can be extracted based on the genome file. 
See the bash file extract-trinucleotide-forSigProfiler.sh to see the output of this.
The output table $fout3 should have 6 columns with the genomic location, the reference and alt allele and codon context.

```{r, eval=F, echo=T}
TBed=lapply(AllMutWGS, function(x) cbind(as.character(x$Chromosome), x$Start_Position-2, x$End_Position+1, as.character(x$Reference_Allele), as.character(x$Tumor_Seq_Allele2)))
TBed=lapply(TBed, function(x) x[which(nchar(x[ ,4])==1), ])
sapply(1:length(TBed), function(x) write.table(TBed[[x]], file=paste(names(TBed)[x], "tricodon.bed", sep="_"),col.names=F, row.names = F, sep="\t", quote = F))

## bedtools command
bedtools getfasta -fi ../Genomic_Files/rn6.fa -bed $f -tab -fo $fout
f3() { awk '{print $1, $2, $3, $4 ,$5}' "$1"; }; paste <(f3 $f) <(f3 $fout) > $fout2
awk '{if (length($7)==3) print $1, $2, $3, $4, $5, toupper($7)}' $fout2 > $fout3
## see the bash file extract-trinucleotide-forSigProfiler.sh to see the output of this.
```

Following running the above bash script, we can run the following extract the tri-nucleotide sequence

```{r, eval=F, echo=T}
FFiles=dir("../data/tricodon_mut_sigs/", "*.txt",full.names=T)
OutputList=sapply(FFiles, function(x) FindTriNucleotideContext(x))
TableOut=sapply(1:ncol(OutputList), function(x) unlist(OutputList[3, x]))
a1=basename(FFiles)
a2=sapply(strsplit(a1, "_"), function(x) x[1])
TableOut=cbind(as.character(unlist(OutputList[1, 1])), as.character(unlist(OutputList[2, 1])), TableOut)
colnames(TableOut)=c("MutationType","Nutrinucleotide", paste("BRCA", a2, sep="::"))
write.csv(TableOut, file="../data/tricodon_mut_sigs/output4SigProfiler.csv", sep = ",", row.names = F)
```

This is then run in python (sigprofiler) with the following code:

```{r,eval=F, echo=T}
module load gcc
module load python/3.7.4
from SigProfilerExtractor import spss_pcwag (spss uses only vcf files)
spss_pcwag.single_sample_pcwag("output4SigProfiler.csv", output="example_output")
```

The results from this analysis are shown below

```{r}
SBSprof=read.delim("../data/tricodon_mut_sigs/sigpross/sig_activities.txt", sep="\t")
SBSprofb=SBSprof[ ,-1]/rowSums(SBSprof[ ,-1])
SBSprofb=SBSprofb[ ,-which(colSums(SBSprofb)==0)]
rownames(SBSprofb)=SBSprof[ ,1]


#pdf(sprintf("rslt/WGS/mutational_signatures_%s.pdf", Sys.Date()), height=9, width=7)
heatmap.2(data.matrix(SBSprofb[ ,-1]), col=brewer.pal(9, "Blues"), scale="none", trace="none", Colv = NA, Rowv=NA)

SBSmelt=melt(cbind(SBSprofb[ , -1], id=rownames(SBSprofb)))
SBSsummary <- aggregate(. ~ variable, mean, data=SBSmelt)

ggplot(SBSmelt, aes(x=variable, y=value, col=variable))+geom_jitter()+geom_crossbar(data=SBSsummary , aes(ymin = value, ymax = value),size=0.5,col="black", width = .7)+theme_bw()

## Assign with growth data or tumor size?
tname=substr(SBSprof$Cancer.Types, 7, 20)
idx=sapply(tname, function(x) grep(x, Cdata$WGS))
sizeInfo=Cdata$Tumor.dia..sac..mm.[idx]

#par(mfrow=c(2,1))
cor1=cor.test(SBSprofb$SBS32+SBSprofb$SBS11, sizeInfo, use="complete")
cor2=cor.test(SBSprofb$SBS32[which(SBSprofb$SBS32>0)], sizeInfo[which(SBSprofb$SBS32>0)], use="complete")
cor3=cor.test(SBSprofb$SBS11[which(SBSprofb$SBS11>0)], sizeInfo[which(SBSprofb$SBS11>0)], use="complete")
plot(SBSprofb$SBS32+SBSprofb$SBS11, sizeInfo, xlab="SBS 32 or 11 score", ylab="tumor size",
     col=ifelse(SBSprofb$SBS11==0, "red", "blue"), main=sprintf("association between signature score and size, p=%s", round(cor1$p.value, 2)))
legend("topleft",c(paste("SB32", round(cor2$p.value,2)), paste("SB11",round(cor3$p.value,2))), col=c("red", "blue"), lwd=2, pch=19)

#dev.off()
```

### Annotate the data with human common variants


```{r, find-mut-variant, cache=T, eval=F}
## The following is run independently and saved to fle
## issues with the RnvorV87 pointer when cached
# remove sourcing CreateRnor87
## Append to MeltCosmic?
source("../rscript/CreateRnor87db.R")
AAout=strsplit(as.character(MeltCosmic$HGVSp_Short), "[0-9]+")
AAwt=sapply(AAout, function(x) x[1])
AAmt=sapply(AAout, function(x) x[2])
AAno=regmatches(MeltCosmic$HGVSp_Short, gregexpr("[[:digit:]]+", MeltCosmic$HGVSp_Short))

MeltCosmic$AAno=NA
MeltCosmic$AAno[which(sapply(AAno, length)==1)]=as.numeric(as.character(unlist(AAno)))
FindVarTest=FindHumanAAHomolog(MeltCosmic$Gene_Symbol, AAwt, MeltCosmic$AAno, AAmt)
MeltCosmic=cbind(MeltCosmic, FindVarTest)



save(MeltCosmic, file=sprintf("outputs/MeltCosmic_coding_genes_WGS_rat_%s.RData", Sys.Date())) #, sep="\t", row.names=F)
write.csv(MeltCosmic, file="outputs/SupplementalTable_AllRatMutations_annotated_w_human_homolog.csv", row.names = F, quote=F)
```

From this analysis, below are the genes with mutations in known human hotpot mutations in common genes

```{r}
load("outputs/MeltCosmic_coding_genes_WGS_rat_2020-11-11.RData")

Xa=which(MeltCosmic$Gene_Symbol %in% BList$RatGene)
Xb=match(paste(MeltCosmic$Gene_Symbol, MeltCosmic$AAno), paste(BList$RatGene,BList$RatAAno))
Xc=match(paste(MeltCosmic$Gene_Symbol, MeltCosmic$AAno), paste(ChangList2$RatGene, ChangList2$RatAAno))
x2=c(which(!is.na(Xb)), which(!is.na(Xc)))

#head(MeltCosmic)

Xb=match(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno), paste(BList$Gene,BList$AAno))
Xc=match(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno), paste(ChangList2$Gene, ChangList2$AAno))
x3=c(which(!is.na(Xb)), which(!is.na(Xc)))
x4=unique(c(x2, x3))
kable(MeltCosmic[x4, 39:50])

```

And here, we plot the frequency of these different mutations

```{r}
idx=which(!is.na(MeltCosmic$HumGene))
#length(idx)
Nx=paste(MeltCosmic$Gene[idx], MeltCosmic$AAno[idx])
T2=sort(table(Nx), decreasing = T)
#head(T2)

ind2=which(T2>1)
barplot(T2[ind2], ylim=c(0, 14), main="most frequent coding mutations with human homolog", las=2)
```

## Plots

### Quick overview

WGS all mutations summary: Look at the overall mutation burden, and the tumor mutational burden, defined as # coding mutations per MB.

The following plot lists tumors in increasing size

Make plots of:

* overall types of mutations per sample (ranked by size)
* correlation between mutation type and size
* type of mutation?

```{r}
#load("data/wholegenome_mutations/WGS_mutations_coding.RData")

TabSamples=lapply(AllMutWGScoding, function(x) table(factor(x$Variant_Classification, levels=SearchVars)))
TabSamples2=unlist(TabSamples)
namidx=sapply(strsplit(names(TabSamples2), "\\."), function(x) x[1])
namidx2=sapply(strsplit(names(TabSamples2), "\\."), function(x) x[2])
TotTabl=data.frame(val=TabSamples2, nam=namidx, variant=namidx2)

## remove 0 samples
# searchNo=stack(by(TotTabl$val, TotTabl$variant, sum))
# TotTabl=TotTabl[ which(TotTabl$variant %in% searchNo$ind[which(searchNo$values!=0)]), ]

lx1=match(TotTabl$nam, sapply(strsplit(as.character(Cdata$WGS), ".final.bam"), function(x) tryCatch({x[1]}, error=function(e){NA})))
TotTabl$Size=Cdata$Tumor.dia..sac..mm.[lx1]

TotTabl=TotTabl[order(TotTabl$Size, TotTabl$val), ]

levelNam=unique(TotTabl$nam)

TotTabl$nam=factor(TotTabl$nam, levels=levelNam)

##pdf(sprintf("rslt/WGS/coding_mutation_types_%s.pdf", Sys.Date()), height=6, width=9)

ggplot(TotTabl, aes(x=nam, y=val, fill=variant))+geom_bar(stat="identity")+scale_fill_manual(values=c("black", brewer.pal(9, "Set1")))+theme(axis.text.x=element_text(angle=90))+ylab("Number of coding mutations")+ggtitle("sorted by increasing tumor size at sac")

ax1=lapply(sort(SearchVars), function(x) cor.test(TotTabl[TotTabl$variant==x , "val"], TotTabl[TotTabl$variant==x ,  "Size"], use="complete", method="spearman")) 
pvals=sapply(ax1, function(x) x$p.value)
cors=sapply(ax1, function(x) x$estimate)

ann_text2 <- data.frame(lab=paste("cor=", round(cors, 2),"p=", round(pvals,2),sep=""), variant=sort(SearchVars),  val=1, Size=5)

ggplot(TotTabl, aes(x=Size, y=val, col=variant))+geom_point()+facet_wrap(~variant, scale="free")+geom_text(data=ann_text2, aes(label=lab))

#dev.off()
#MeltWGSCoding=melt(AllMutWGScoding, measure.vars=c("Tumor_Sample_Barcode"))

```

### Coding variants & TMB

There are a few ways of figuring out the TMB. We can

* report the number of mutations (missense, insertion/deletion, frameshifts, nonsense)
* normalise the above value to the known length of coding regions in the rat genome (UCSC exon length 43,423,804)
* plot of TMB vs objective response rate: there is no true relationship between final tumor size and mutational burden. Could also be confounded by subclonality

```{r}
searchThese=c("Missense_Mutation", "Nonsense_Mutation", "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation")
NVar2=TotTabl[TotTabl$variant%in%searchThese, ]
Ntot=by(NVar2$val, NVar2$nam, sum)
# check this is unique based on the location
Ntot2=stack(Ntot)
colnames(Ntot2)[1]="NCodingMut"
Ntot2$TMB=Ntot2$NCodingMut/43.423804
TotMut=sapply(AllMutWGS, nrow)
Ntot2$TotalMut=TotMut[match(Ntot2$ind, names(TotMut))]
Ntot2$Tum.size=TotTabl$Size[match(Ntot2$ind, TotTabl$nam)]
Ntot2=Ntot2[order(Ntot2$Tum.size), ]
#Ntot2$normCov=Ntot2$values/43.423804

Ntot2$NsynFreq=Ntot2$NCodingMut/Ntot2$TotalMut
Ntot2melt=melt(Ntot2)

#pdf(sprintf("rslt/WGS/frequency_mutational_types#2_%s.pdf", Sys.Date()), height=10, width=6)
ggplot(Ntot2melt, aes(x=ind, y=value, col=variable))+geom_bar(stat="identity")+facet_grid(variable~., scale="free_y")+
  theme_bw()+theme(axis.text.x=element_text(angle=90))
#dev.off()
## As a metric for TMB, comapre the number of mutations to the covered genome
```



```{r, eval=F}
# To obtain an idea of the coverage:
Using bedtools and samtools
here, counting only "propoet pairs" with maping quality greater than 30
see (https://www.biostars.org/p/11105/)
samtools view -u -q 30 -f 0x2 aln.bam | coverageBed -abam stdin -b exons.bed > exons.bed.proper.q30.coverage
```

## Coding variants

### Sites which are commonly mutated?

Could this be a variant (SD strain "rsSNP") or is it actually a mutation? 

Variants were annotated with snpeff. Raw data from this was obtained from https://www.biorxiv.org/content/10.1101/412924v1.full

```{r mod-vcfs, eval=F}

harlanRats=read.vcfR("~/Desktop/carlos_study_files/allChr.allSamps.90DR2.maf01.hweE7.noIBD.HarlanOnly.vcf.gz")
harlanRats@fix[ ,1]=paste("chr", harlanRats@fix[ ,1], sep="")
harlanRats@fix[ ,3]=paste("H", harlanRats@fix[ ,3], sep=".")
harlanRats@meta=harlanRats@meta[-grep("##contig",harlanRats@meta )]

# figure out the genotype distribution
GT=sapply(1:nrow(harlanRats@gt), function(x) 
  table(factor(harlanRats@gt[x, -1],levels=c("0/0","0/1","1/1"))))
GT2=paste(GT[1, ], GT[2, ], GT[3, ], sep=",")
GT3=paste(GT[1, ]/2281, GT[2, ]/2281, GT[3, ]/2281, sep=",")

GenotypeS=cbind(FORMAT="GT", Annot=c("0/0,0/1,1/1"), GT2, GT3 )
harlanRats@gt=GenotypeS
## save this to file or something
write.vcf(harlanRats, file="~/Desktop/dbSNP_info/harlan_snps_mod_1-5-2020.vcf.gz")

# loading the charles river rat snp sites
CRRats=read.vcfR("~/Desktop/dbSNP_info/charles_river_200Ksnps.gz")
CRRats@fix[ ,1]=paste("chr", CRRats@fix[ ,1], sep="")
CRRats@fix[ ,3]=paste("CR", CRRats@fix[ ,3], sep=".")
CRRats@meta=CRRats@meta[-grep("##contig",CRRats@meta )]

crGT=sapply(1:nrow(CRRats@gt), function(x) 
  table(factor(CRRats@gt[x, -1],levels=c("0/0","0/1","1/1"))))
crGT2=paste(crGT[1, ], crGT[2, ], crGT[3, ], sep=",")
crGT3=paste(crGT[1, ]/1780, crGT[2, ]/1780, crGT[3, ]/1780, sep=",")
GenotypeS=cbind(FORMAT="GT", Annot=c("0/0,0/1,1/1"), crGT2, crGT3 )
CRRats@gt=GenotypeS
write.vcf(CRRats, file="~/Desktop/dbSNP_info/charlesRiver_snps_mod_1-5-2020.vcf.gz")
```

Note that the nihRats package may not be required here. We probably just want the harlan snps

```{r, load-snps-database, cache=T, message=F, warning=F, results='hide'}
# loading known list of rat snp sites
nihRats=read.vcfR("../anntotations/dbSNP/rat_10116_00-All.wchr.SDsort.vcf.gz")
#nihRats@fix[ ,1]=paste("chr", nihRats@fix[ ,1], sep="")
r=regexpr("[a-z]+_[a-z]+",nihRats@fix[ ,8]) #ANN=[A-Z]\\|
ModType=rep(NA, length(nihRats@fix[ ,8]))
ModType[r!=-1]=regmatches(nihRats@fix[ ,8], r)
#ModType=substr(ModType, 7, 25)
# Harlan samples
harlanRats=read.vcfR("../anntotations/dbSNP/harlan_snps_mod_1-5-2020.SDsort.vcf.gz")

GT3=crGT3=1-as.numeric(sapply(strsplit(harlanRats@gt[ ,4], ","), function(x) x[1]))

r=regexpr("ANN=[A-Z]\\|[a-z]+_[a-z]+", harlanRats@fix[ ,8])
HarType=rep(NA, length(harlanRats@fix[ ,8]))
HarType[r!=-1]=regmatches(harlanRats@fix[ ,8], r)
HarType=substr(HarType, 7, 25)
# charles river samples
CRRats=read.vcfR("../anntotations/dbSNP/charlesRiver_snps_mod_1-5-2020.SDsort.vcf.gz")
crGT3=1-as.numeric(sapply(strsplit(CRRats@gt[ ,4], ","), function(x) x[1]))

r=regexpr("ANN=[A-Z]\\|[a-z]+_[a-z]+", CRRats@fix[ ,8])
CRType=rep(NA, length(CRRats@fix[ ,8]))
CRType[r!=-1]=regmatches(CRRats@fix[ ,8], r)

CRType=substr(CRType, 7, 25)
```



```{r}
# This is just a plot that compares the different databases.
## Look at the overlap between all the databases:
NIHr=paste(nihRats@fix[ ,1], nihRats@fix[ ,2])
harr=paste(harlanRats@fix[ ,1], harlanRats@fix[ ,2])
crr=paste(CRRats@fix[ ,1], CRRats@fix[ ,2])

# overview of the overlaps
venn(list(NIH=NIHr, harlan=harr, CR=crr))

## Annotate the above variants for protein coding regions first, then narrow down to known 
AllLevels=unique(c(HarType, CRType, ModType))
allTypes=rbind(table(factor(ModType, levels=AllLevels)), table(factor(HarType, levels=AllLevels)),
               table(factor(CRType, levels = AllLevels)))
rownames(allTypes)=c("NIH", "harlan", "CR")
allTypesNorm=allTypes/rowSums(allTypes)

t2=melt(allTypesNorm)
ggplot(t2[which(t2$value<0.04),  ], aes(x=Var1, y=value, fill=Var2))+geom_bar(stat = "identity")+ylab("frequency snp type")+xlab("dataset")
```


```{r}
SearchVars=c("missense_variant","stop_lost", "stop_gained", "initiator_codon", "start_lost", "frameshift_variant")
NIHr2=NIHr[which(ModType%in%SearchVars)]
harr2=harr[which(HarType%in%SearchVars)]
crr2=crr[which(CRType%in%SearchVars)]

venn(list(NIH=NIHr2, harlan=harr2, CR=crr2))
mtext("any coding variant", side=3)

## Genes affected
r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", harlanRats@fix[which(HarType%in%SearchVars),8])
codhrgrp=rep(NA, length(which(HarType%in%SearchVars)))
codhrgrp[r!=-1]=regmatches(harlanRats@fix[which(HarType%in%SearchVars),8], r)
codhrgrp=substr(codhrgrp, 1, nchar(codhrgrp)-8)

r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", CRRats@fix[which(CRType%in%SearchVars),8])
codcrgrp=rep(NA, length(which(CRType%in%SearchVars)))
codcrgrp[r!=-1]=regmatches(CRRats@fix[which(CRType%in%SearchVars),8], r)
codcrgrp=substr(codhrgrp, 1, nchar(codcrgrp)-8)

r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", nihRats@fix[which(ModType%in%SearchVars),8])
codnihgrp=rep(NA, length(which(ModType%in%SearchVars)))
codnihgrp[r!=-1]=regmatches(nihRats@fix[which(ModType%in%SearchVars),8], r)
codnihgrp=substr(codnihgrp, 1, nchar(codnihgrp)-8)

venn(list(NIH=codnihgrp, harlan=codhrgrp, CR=codcrgrp))
mtext("any cosmic coding variant", side=3)

## Look for Cosmic specific genes
codcrgrp2=codcrgrp[codcrgrp%in%RatCosmic]
codhrgrp2=codhrgrp[codhrgrp%in%RatCosmic]
codnihgrp2=codnihgrp[codnihgrp%in%RatCosmic] #c(RatBreastCosmic, codhrgrp2, "Tert", "Atm")]
```

Look at the distribution of mutations:

Whole genome

* 1188 genes in more than 2 animals (1435 in at least 2)
* 59 variants were identified as population variant in Harlan 
* 47 in charles river (6 are novel in this cohort only)

Cosmic genes:

* 42 sites which have mutations in more than 2 animals
* 50 sites in more than 1 animal
* 5 sites which have been identified in GWAS studies of harlan rats. On average, the variant is found at a frequency of ~15%. The CR set, these variants appear in 50\% of the population 
* 4 of the 5 rats from above were identified in 
* 0 sites in the nih dbSNP database for rats


```{r, eval=F}
# Check TGFBr polymorphisms:

r=grep("Tgfb", harlanRats@fix[,8])
harlanRatsTgfb=harlanRats[r]
write.vcf(harlanRatsTgfb, file="~/Desktop/harlanRats_Tgfb.vcf.gz")

r=grep("Tgfb", CRRats@fix[,8])
CRRatsTgfb=CRRats[r]
write.vcf(CRRatsTgfb, file="~/Desktop/CRRats_Tgfb.vcf.gz")

r=grep("Tgfb", nihRats@fix[,8])
nihRatsTgfb=nihRats[r]
write.vcf(nihRatsTgfb, file="~/Desktop/nih_Tgfb.vcf.gz")

```

Here, compare the frequencies of the most common mutations in our population with those reported in the harlan and charles river data-bases:

* filter out mutatations occuring in 2+ samples

```{r, pop-gen-plot}
Nsamp=1
## Firstly whole genome
lx1=table(paste(MeltWGSCoding$Chromosome, MeltWGSCoding$Start_Position))
lx1=sort(lx1, decreasing=T)
hist(lx1)
length(which(lx1>Nsamp))
WGSList=names(lx1)[which(lx1>Nsamp)]
WGSList=strsplit(WGSList, " ")
WGSList=data.frame(chr=sapply(WGSList, function(x) x[1]), pos=sapply(WGSList, function(x) x[2]), freq=lx1[which(lx1>Nsamp)])
WGSList$gene=as.character(MeltWGSCoding$Gene_Symbol[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$AA=as.character(MeltWGSCoding$HGVSp_Short[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$VariantClass=as.character(MeltWGSCoding$Variant_Classification[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$Cosmic=ifelse(WGSList$gene%in%RatCosmic, 1, 0)

## Secondly, cosmic specific genes

## WGSList
midx=match(WGSList$freq.Var1, paste(harlanRats@fix[ ,1], harlanRats@fix[ ,2], sep=" "))
WGSList$HarlanFreq=GT3[midx]
midx=match(WGSList$freq.Var1, paste(nihRats@fix[ ,1], nihRats@fix[ ,2], sep=" "))
WGSList$rsID=nihRats@fix[midx, 3]
## CR
midx=match(WGSList$freq.Var1, paste(CRRats@fix[ ,1], CRRats@fix[ ,2], sep=" "))
WGSList$CRFreq=crGT3[midx]

WGSplot=melt(WGSList[ ,c("freq.Freq", "gene", "VariantClass", "HarlanFreq", "CRFreq", "Cosmic")], measure.vars = c("HarlanFreq", "CRFreq"))
WGSplot=WGSplot[-which(is.na(WGSplot$value)), ]

ggplot(WGSplot, aes(x=freq.Freq/16, y=value, col=VariantClass, label=WGSplot$gene))+facet_grid(~variable)+geom_point()+
  geom_text(size=(WGSplot$Cosmic+3), col="black", nudge_y=0.01)+xlab("Cohort frequency")+ylab("Database frequency")+theme_bw()+theme(legend.position="bottom")+ggtitle("all genes compared to Harlan Frequencies")

 kable(WGSplot[WGSplot$Cosmic==1, ])

```


## Overview of the mutations 

### All mutations

SNPs are removed from this analysis: based on frequencies in the harlan cohort

Color codes:

* black:
* pink: 
* green:
* blue:

```{r}
Nmut=92

rmHarlanSNP=WGSList[which(!is.na(WGSList$HarlanFreq)), ]
x1a=which(MeltWGSCoding$Gene_Symbol%in%rmHarlanSNP$gene &  MeltWGSCoding$Start_Position%in%rmHarlanSNP$pos)
MeltWGSCodingB=MeltWGSCoding[-x1a, ]

rGeneOut=acast(MeltWGSCodingB[ ,c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))

mxl=unique(as.vector(rGeneOut))
rGeneOut2=rGeneOut
rGeneOut2[grep("Nonsense",rGeneOut2)]=3
rGeneOut2[grep("Frame_Shift",rGeneOut2)]=2
rGeneOut2[grep("Missense_", rGeneOut2)]=1
rGeneOut2[grep("Splice_", rGeneOut2)]=4
rGeneOut2[which(rGeneOut2=="")]=0

rGeneOut2=apply(rGeneOut2, 2, as.numeric)
rownames(rGeneOut2)=rownames(rGeneOut)

#get rid of genes which are associated with Olfactory receptors, AABR etc mutations
rmThese=c("^AABR", "^Olr", "^LOC", "^AC[0-9]+", "^RGD", "^Rpl", "^1700", "^RT1", "^ENSRNOG", "^Vom2")
rmList=unlist(sapply(rmThese, function(x) grep(x, colnames(rGeneOut2))))
rGeneOut2=rGeneOut2[ ,-rmList]

GeneList=colSums(sign(rGeneOut2), na.rm=T)
samp2=rowSums(sign(rGeneOut2), na.rm=T)
rGeneOut2=rGeneOut2[ order(samp2, decreasing=T),]

topN=names(sort(GeneList, decreasing=T)[1:Nmut])

# do a plot of the top 30 most common mutations
tempx=rGeneOut2[ ,topN]
a2=heatmap(tempx, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
RowSC=ifelse(colnames(tempx)%in% c(RatCosmic, as.character(AllCancerPathwayGenes)), "black", "white")

heatmap.2(tempx, Rowv = NA, Colv = NA,scale="none", trace="none", col=c("white", 1:4), ColSideColors=RowSC)
# check if any of these are hotspot mutations
Hotspots=MeltCosmic[which(!is.na(MeltCosmic$HumSequence)==T), ]
#head(Hotspots)

hotspotLocExtract=function(amat){
HList=sapply(1:nrow(Hotspots), function(i) ifelse(amat[match(Hotspots$L1[i], rownames(amat)),match(Hotspots$Gene_Symbol[i], colnames(amat))]>0, 
                                                 paste(match(Hotspots$L1[i], rownames(amat)),match(Hotspots$Gene_Symbol[i], colnames(amat))), "0 0"))
List2=strsplit(as.character(HList), " ")
Xcord=na.omit(as.numeric(sapply(List2, function(x) x[1])))
Ycord=na.omit(as.numeric(sapply(List2, function(x) x[2])))
return(list(X=Xcord, Y=Ycord))
}

## top 90 mutations
a2=heatmap.2(sign(tempx), trace="none", col=c("white", "grey"))
tempxb=tempx[a2$rowInd, a2$colInd]
hotspot1b=hotspotLocExtract(tempxb)
GeneList=unique(Hotspots$Gene_Symbol)
tempy=rGeneOut2[ ,match(GeneList, colnames(rGeneOut2))]
a2=heatmap.2(sign(tempy), trace="none", col=c("white", "grey"))
tempyb=tempy[a2$rowInd, a2$colInd]
hotspot2=hotspotLocExtract(tempyb)

##cosmic genes
x1=which(colnames(rGeneOut2)%in%RatCosmic)
tempz=rGeneOut2[ ,x1]
a2=heatmap.2(sign(tempz), trace="none", col=c("white", 1:4))
tempzb=tempz[a2$rowInd, a2$colInd]
hotspotzb=hotspotLocExtract(tempzb)

x2=which(colSums(sign(tempzb))==1)
tempz2=tempzb[ , -x2]

topCOSMIC=colnames(tempz2)

save(topN, topCOSMIC, file="outputs/genes-selected-common-WGX-mutations.RData")

x3=table(colSums(rGeneOut2))
```

Note that in this table, the distribution of samples with mutations is as follows:

`r table(colSums(rGeneOut2))`

The number of genes which have shared mutations in 10 or more samples is:

`r sum(x3[10:length(x3)])`, which is why we have use these values here.

The number of genes which are cosmic associated are:

`r length(x1)` and the number which appear in more than 1 sample is `r length(x1)-length(x2)`.

These genes are tabulated below:


```{r}
### keep these values
top90genes=colnames(rGeneOut2)

#pdf(sprintf("rslt/WGS/summary_mutations_top90_human_homology_%s.pdf", Sys.Date()), width=14, height=7)

# 
# par(mar = c(4, 8, 4, 2),  xpd = TRUE)
# image(t(tempx), col=c("white", 1:3), xaxt='n', yaxt='n')
# axis(1, at=seq(0, 1, length=ncol(tempx)), colnames(tempx), las=2, cex=0.5)
# axis(2, at=seq(0, 1, length=nrow(tempx)), rownames(tempx), las=2, cex=0.5)
# text(na.omit(hotspot1$Y-1)/(ncol(tempx)-1), na.omit(hotspot1$X-1)/(nrow(tempx)-1) , "*")
# legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:3, "black"), horiz = T)
# 

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempxb), col=c("white", 1:3), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempxb)), colnames(tempxb), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tempxb)), rownames(tempxb), las=2, cex.axis=0.7)
text(na.omit(hotspot1b$Y-1)/(ncol(tempxb)-1), na.omit(hotspot1b$X-1)/(nrow(tempxb)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("top 90 mutations", side=3, line=-1, outer=T)


par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempyb), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempyb)), colnames(tempyb), las=2, cex=0.5)
axis(2, at=seq(0, 1, length=nrow(tempyb)), rownames(tempyb), las=2, cex=0.5)
text(na.omit(hotspot2$Y-1)/(ncol(tempyb)-1), na.omit(hotspot2$X-1)/(nrow(tempyb)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext(" 'Hotspot' mutations only", side=3, line=-1, outer=T)

## Plot by picking out cancer related genes

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempzb), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempzb)), colnames(tempzb), las=2, cex=0.5, cex.lab=0.7)
axis(2, at=seq(0, 1, length=nrow(tempzb)), rownames(tempzb), las=2, cex=0.5)
text(na.omit(hotspotzb$Y-1)/(ncol(tempzb)-1), na.omit(hotspotzb$X-1)/(nrow(tempzb)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("Cancer related genes", side=3, line=-1, outer=T)



hotspotzb2=hotspotLocExtract(tempz2)

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempz2), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempz2)), colnames(tempz2), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(tempz2)), rownames(tempz2), las=2, cex=0.7)
text(na.omit(hotspotzb2$Y-1)/(ncol(tempz2)-1), na.omit(hotspotzb2$X-1)/(nrow(tempz2)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)

#dev.off()
```

## Metacore analysis of commonly mutated pathways

Save these lists for metacore

```{r}
allMut=unique(MeltWGSCodingB$Gene_Symbol)
write.csv(allMut, file=sprintf("outputs/all_mut_rat_WGS_coding_metacore_%s.csv", Sys.Date()), row.names = F, quote=F)

allMut=unique(MeltCosmic$Gene_Symbol)
write.csv(allMut, file=sprintf("outputs/all_mut_rat_WES_cosmic_metacore_%s.csv", Sys.Date()), row.names = F, quote=F)

```

Load the metacore results:

```{r}
Process_Networks=readxl::read_excel("../data/wholegenome_mutations/all rat WES process networks coding-cosmic.xls", 1, skip=2)
Pathway_Maps=readxl::read_excel("../data/wholegenome_mutations/all rat WES pathway maps coding-cosmic.xls", 1, skip = 2)

Terms_PN=strsplit(Process_Networks$Networks, "_")
TermsPN1=sapply(Terms_PN, function(x) x[1])
TermsPN2=sapply(Terms_PN, function(x) x[2])

Terms_PW=strsplit(Pathway_Maps$Maps, "_")
TermsPW1=sapply(Terms_PW, function(x) x[1])
TermsPW2=sapply(Terms_PW, function(x) x[2])


load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData")
n2=which(Process_Networks$FDR...7<0.05)
m1=match(Process_Networks$Networks[n2], names(PathwayMapSet))
#figure out which is significant


N2=lapply(m1, function(x) which(MeltWGSCodingB$Hum_Gene %in% PathwayMapSet[[x]]))
GList2=lapply(N2, function(x) MeltWGSCodingB[x, c("Hum_Gene", "L1")])
SumTable2=sapply(GList2, function(x) summary(factor(x[ ,"L1"], levels=unique(MeltWGSCodingB$L1))))
colnames(SumTable2)=Process_Networks$Networks[n2]
#listGenes=strsplit(Process_Networks$Network.Objects.from.Active.Data[1:15], ",")
head(SumTable2)

load("../anntotations/Metacore_extracted_pathway_maps_nov2020.RData")
n2=which(Pathway_Maps$FDR...7<0.001)
m1=match(Pathway_Maps$Maps[n2], names(PathwayMapSet))


N2=lapply(m1, function(x) which(MeltWGSCodingB$Hum_Gene %in% PathwayMapSet[[x]]))
GList2=lapply(N2, function(x) MeltWGSCodingB[x, c("Hum_Gene", "L1")])
SumTable3=sapply(GList2, function(x) summary(factor(x[ ,"L1"], levels=unique(MeltWGSCodingB$L1))))
colnames(SumTable3)=Pathway_Maps$Maps[n2]
#listGenes=strsplit(Process_Networks$Network.Objects.from.Active.Data[1:15], ",")
head(SumTable3)

#pdf("rslt/WGS/Metacore_analysis_coding_mutations.pdf", height=13, width=13)

par(mfrow=c(1,2), mar=c(2,2, 2,2))
n2=order(Process_Networks$`FDR...7`)
barplot(-log10(as.numeric(Process_Networks$FDR...7[n2[1:15]])), names.arg = Process_Networks$Networks[n2[1:15]], las=2, main="Process networks all coding", horiz = T, cex.names = 0.5)
n2=order(Process_Networks$FDR...11)
# barplot(-log10(as.numeric(Process_Networks$FDR...11[n2[1:15]])), names.arg = Process_Networks$Networks[n2[1:15]], las=2, main="Process networks cosmic only", horiz = T, cex.names = 0.5)
# barplot(-log10(as.numeric(Pathway_Maps$FDR[1:15])), names.arg = Pathway_Maps$Maps[1:15], las=2, main="Pathway Maps", horiz = T, cex.names = 0.5)
# 
par(oma=c(2, 0,0,3))
rNames=strsplit(colnames(SumTable2), "_")
rNames2=sapply(rNames, function(x) x[1])
cCols=brewer.pal(12,"Set3")[factor(rNames2)]
lx=order(cCols)
heatmap.2(SumTable2[, lx], scale="col", trace="none", col=brewer.pal(11, "Blues"), main="Process Networks: scaled No mutations affecting each pathway",
          ColSideColors = cCols[lx], Colv = NA)

# par(oma=c(2, 0,0,3))
# # rNames=strsplit(colnames(SumTable3), "_")
# # rNames2=sapply(rNames, function(x) x[1])
# # cCols=brewer.pal(12,"Set3")[factor(rNames2)]
# # lx=order(cCols)
# heatmap.2(SumTable3, scale="col", trace="none", col=brewer.pal(9, "Blues"), main="Pathway Maps")
# write.csv(SumTable3, file="outputs/no mutations pathway maps all coding.csv")
# write.csv(SumTable2, file="outputs/no mutations process networks all coding.csv")
#dev.off()
```


<!--chapter:end:10-mutations.Rmd-->

# Mutations in RNA

In this section, we will check RNA data for the common mutations identified in the previous section. Some of these mutations could be uncharacterised polymoprphisms, and if this is the case, we will see in both CD45 and Epithelial fractions

## Haplotype caller

Mutational calling from RNA data was performed using haplotype caller. The key steps are:

1. run haplotype caller
2. run snpeff to annotate
3. from snpsift to convert to a text file that can be read

Note that a dbSNP file is needed to filter for polymorphisms. We have used the [harlan variants](https://www.biorxiv.org/content/10.1101/412924v1.full) to perform filtering due to similarity in population frequencies in the previous section

An example of the code is shown here:

```{r, eval=F}
 # pipeline

# 1. run haplotyper
# A. Assemble BAM files
Inputs: 
  $1 fastq file (if paired end, $2 will be the other)
  $2 aligned bam
# fastq to unaligned BAM
java -jar $PICARD/picard-2.8.0.jar FastqToSam F1=$1 O=$uBAM\
## for paired end:
# java -jar $PICARD/picard-2.8.0.jar FastqToSam F1=$1 F2=$2 O=$uBAM \

# change read groups in aligned BAM file to ensure uniqueness
java -jar $PICARD/picard-2.8.0.jar AddOrReplaceReadGroups \
     I= $2 \
     O= "${2/.bam/ARG.bam}" \
     ID=$baseName2 \
     LB=library \
     PL=illumina \
     PU=hiseq2000 \
     SM=$baseName2 \
     CN=MFBC \
     DT=2018-08-20T00:00:00-0400
# merge files
gatk MergeBamAlignment \
--REFERENCE_SEQUENCE ../Alignment/rn6.fa \
--UNMAPPED_BAM $uBAM \
--ALIGNED_BAM "${2/.bam/ARG.bam}" \
--OUTPUT $mBAM \
--INCLUDE_SECONDARY_ALIGNMENTS false \
--PAIRED_RUN true \
--VALIDATION_STRINGENCY SILENT

#B. Mark duplicates
gatk MarkDuplicates \
        --INPUT $mBAM \
        --OUTPUT $dBAM \
        --CREATE_INDEX true \
        --VALIDATION_STRINGENCY SILENT \
        --METRICS_FILE ${outName}.metrics
#C. Split sigar reads
gatk SplitNCigarReads \
     -R ../Alignment/rn6.fa \
     -I $dBAM \
     -O $cBAM \

#D. Base recalibration
gatk BaseRecalibrator \
             -R ../Alignment/rn6.fa \
             -I $cBAM \
             -O ${outName}_recalibration \
             -known-sites harlan_snps_mod_1-5-2020.SDsort.vcf.gz 

gatk ApplyBQSR \
             --add-output-sam-program-record \
             -R ../Alignment/rn6.fa \
             -I $cBAM \
             --use-original-qualities \
             -O $bBAM \
             --bqsr-recal-file ${outName}_recalibration

#E. Haplotype calling
gatk HaplotypeCaller \
 -R ../Alignment/rn6.fa \
 -I $bBAM \
 -L ../Alignment/rn6_refGene_intervals.bed \
 -O ${outName}HCR.vcf.gz  \
 --dont-use-soft-clipped-bases true \
 --standard-min-confidence-threshold-for-calling 20 \
 --dbsnp all_rat_snps_0504.SD.vcf.gz

# F. Filtering
gatk VariantFiltration \
 --R ../Alignment/rn6.fa \
 --V ${outName}HCR.vcf.gz \
 --window 35 \
 --cluster 3 \
 --filter-name "FS" \
 --filter "FS > 30.0" \
 --filter-name "QD" \
 --filter "QD < 2.0" \
 -O ${outName}_filt_HCR

# 2. run SnpEff to annotate
java -jar $SNPEFF/snpEff.jar -v Rnor_6.0.86 /n/scratch2/at268/carlos_data/20191030_Ep_NMU1_CGDA7428_S1_R1_001_filt > /n/scratch2/at268/carlos_data/20191030_Ep_NMU1_CGDA7428_S1_R1_001_filt_ann

# 3. run SnpSift to save as a .txt file that can be easily read
cat $f | $SNPEFF/scripts/vcfEffOnePerLine.pl | java -jar $SNPEFF/SnpSift.jar extractFields -e "" - CHROM POS ID REF ALT QUAL FILTER AF AC DP MQ  "ANN[*].ANNOTATION" "ANN[*].GENE" "ANN[*].GENEID" "ANN[*].BIOTYPE" "ANN[*].HGVS_C" "ANN[*].HGVS_P" "ANN[*].CDNA_POS" "ANN[*].CDNA_LEN" "ANN[*].CDS_POS" "ANN[*].CDS_LEN" "ANN[*].AA_POS" "ANN[*].AA_LEN" "NMD[*].NUMTR" "NMD[*].PERC" "GEN[*]" > $ofile
```


From processing the mutational information:

Header information - Genotypes:
GT: genotype
AD: Allelic depths for the ref and alt alleles in the order listed
DP: Approximate read depth (reads with MQ=255 or with bad mates are filtered)
GQ: Genotype Quality
PL: Normalized, Phred-scaled likelihoods for genotypes

Header info: Info
AC: Allele count in genotypes, for each ALT allele, in the same order as listed
AF: Allele Frequency, for each ALT allele, in the same order as listed
AN: Total number of alleles in called genotypes
DB: dbSNP Membership
DP: Approximate read depth; some reads may have been filtered
ExcessHet: Phred-scaled p-value for exact test of excess heterozygosity
FS: Phred-scaled p-value using Fisher's exact test to detect strand bias
MLEAC: Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC)
MLEAF: Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF)
MQ: RMS Mapping Quality
QD:Variant Confidence/Quality by Depth
SOR: Symmetric Odds Ratio of 2x2 contingency table to detect strand bias

SnpEff Annotations:
Allele : C
Annotation: missense_variant
Annotation_Impact MODERATE
Gene_Name Raet1l
Gene_ID ENSRNOG00000040300 
Feature_Type transcript 
Feature_ID ENSRNOT00000062027.4
Transcript_BioType protein_coding 
HGVS.c c.1017C>G 
HGVS.p p.Cys339Trp 
cDNA.pos / cDNA.length 1017/1185 
CDS.pos / CDS.length 1017/1185 
AA.pos / AA.length 339/394 

missense_variant|MODERATE|Raet1l|ENSRNOG00000040300|transcript|ENSRNOT00000062027.4|protein_coding|6/7|c.1017C>G|p.Cys339Trp|1017/1185|1017/1185|339/394||

AC=2;AF=1.00;AN=2;DP=49;ExcessHet=3.0103;FS=0.000;MLEAC=2;MLEAF=1.00;MQ=60.00;QD=34.99;SOR=0.874;ANN=GC|frameshift_variant&splice_region_variant|HIGH|Reps1|ENSRNOG00000059224|transcript|ENSRNOT00000089607.1|protein_coding|8/29|c.119dupC|p.Gln41fs|142/2608|120/1842|40/613||INFO_REALIGN_3_PRIME;LOF=(Reps1|ENSRNOG00000059224|2|0.50)

AC=2;AF=1.00;AN=2;BaseQRankSum=1.593;ClippingRankSum=0.000;DP=9;ExcessHet=3.0103;FS=0.000;MLEAC=2;MLEAF=1.00;MQ=60.00;MQRankSum=0.000;QD=33.20;ReadPosRankSum=0.765;SOR=1.609;ANN=AT|frameshift_variant&stop_gained|HIGH|Pacs1|ENSRNOG00000020350|transcript|ENSRNOT00000027632.5|protein_coding|3/24|c.464dupA|p.Tyr155fs|464/2886|464/2886|155/961||;LOF=(Pacs1|ENSRNOG00000020350|1|1.00);NMD=(Pacs1|ENSRNOG00000020350|1|1.00)

## Load files

```{r, cache=T}
hfiles=dir("../data/haplotypeCaller/output_HaplotypeCaller_May/characterisation/",
           pattern=".txt", full.names = T)

allHfiles=list()
allCodingHaplo=list()
allCosmicHaplo=list()

for (i in 1:length(hfiles)){
A1=read.delim(hfiles[i], sep="\t", stringsAsFactors = F)
A1[which(A1==(-1), arr.ind=T)]=""

cNames=sapply(strsplit(colnames(A1)[12:27], "\\.\\.\\.\\."), function(x) x[2])
cNames[13:16]=paste(c("LOF", "LOF", "NMD", "NMD"), cNames[13:16], sep=".")
colnames(A1)[12:28]=c(cNames, "GEN")

GEN2=sapply(strsplit(A1$GEN, ":"), function(x) x[2])
gRef=sapply(strsplit(GEN2, ","), function(x) x[1])
gAlt=sapply(strsplit(GEN2, ","), function(x) x[length(x)])

A1$n_ref=as.numeric(gRef)
A1$n_alt=as.numeric(gAlt)
A1$VAF=A1$n_alt/(A1$n_alt+A1$n_ref)

allHfiles[[i]]=A1[which(A1$n_ref+A1$n_alt>10), ]
allCodingHaplo[[i]]=A1[which(A1$HGVS_P!="" & A1$n_ref+A1$n_alt>10), ]
allCosmicHaplo[[i]]=A1[which(A1$GENE%in%RatCosmic & A1$n_ref+A1$n_alt>10), ]
}

## names of the files

fNam=unlist(strsplit(hfiles, "_filt_HCR_ann_siftB.txt")) #remove HCR where not needed
fNam=unlist(strsplit(fNam, ".vcf.g"))
fNam2=paste(fNam, ".fastq.gz", sep="")
fNam2=sapply(strsplit(fNam2, "/"), function(x) x[length(x)])
idx1=infoTableFinal$SampleID[match(fNam2, infoTableFinal$FqFile)]
idx1[which(is.na(idx1))]=fNam2[which(is.na(idx1))]
idx1[grep("CD45plus", idx1)]=substr(idx1[grep("CD45plus", idx1)],10, 21) 
# sNames=paste(tempAnnot$Rat_ID[idx1],tempAnnot$Location[idx1],  tempAnnot$Fraction[idx1], sep="_")

names(allHfiles)=idx1
names(allCodingHaplo)=idx1
names(allCosmicHaplo)=idx1
# remove the samples which do not pass QC
idx2rm=setdiff(grep("fastq.gz", idx1), grep("CD45plus", idx1))

## write all these lists to file
allHfiles=allHfiles[-idx2rm]
allCodingHaplo=allCodingHaplo[-idx2rm]
allCosmicHaplo=allCosmicHaplo[-idx2rm]

save(allHfiles,allCodingHaplo, allCodingHaplo,  file=sprintf("outputs/HaplotypeVariants_characterisation_all_%s.Rdata", Sys.Date()))
```

## Identifying polymorphisms: compare frequencies in CD45 and Ep data

Search for whether mutations in the cosmic set is present in the RNA data. We will firstly look at the 90 most common genes, and then repeat the same for the top cosmic genes.

```{r}
# replace topN with topCOSMIC
# templace tempxb with tempz2

MeltWGSCoding$mutPos=paste(MeltWGSCoding$Gene_Symbol, MeltWGSCoding$Start_Position)
MeltWGSCodingB$mutPos=paste(MeltWGSCodingB$Gene_Symbol, MeltWGSCodingB$Start_Position)
MallCodingHaplo=melt(allCodingHaplo,  measure.var="POS")
MallCodingHaplo$mutPos=paste(MallCodingHaplo$GENE, MallCodingHaplo$value)
```


```{r}
xb=sort(table(MeltWGSCodingB$mutPos[MeltWGSCodingB$Gene_Symbol%in%topCOSMIC]), decreasing = T)

allCoding_top90=lapply(allCodingHaplo, function(x) x[which(paste(x$GENE, x$POS)%in%names(xb)), ])

mallCoding90=melt(allCoding_top90, measure.var="POS")
mallCoding90$mutUnique=paste(mallCoding90$GENE, mallCoding90$value)

x1=table(mallCoding90$mutUnique)

tabN=acast(mallCoding90[ , c("L1", "GENE")],L1~GENE)
#heatmap.2(tabN, Colv = NA, trace="none", scale="none", col=c("white", brewer.pal(5, "Blues")))
cNamesMatch=match(colnames(tabN), colnames(tempz2))

tabN2=matrix(0, nrow=nrow(tabN), ncol=ncol(tempz2))
tabN2[ ,cNamesMatch]=tabN
colnames(tabN2)=colnames(tempz2)
rownames(tabN2)=rownames(tabN)
id2=grep("Ep", rownames(tabN))
id3=grep("CD45$", rownames(tabN))
id4=grep("CD45plus", rownames(tabN))
tabN2[id2, ]=sign(tabN2[id2, ])
tabN2[id3, ]=sign(tabN2[id3, ])*2
tabN2[id4, ]=sign(tabN2[id4, ])*3
tabN2=tabN2[c(id2, id3, id4), ]


#heatmap.2(tabN2, Colv = NA, Rowv = NA, trace="none", scale="none", col=c("white", brewer.pal(5, "Blues")))

image(t((tabN2)), col=c("white", 1:3), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempz2)), colnames(tempz2), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tabN2)), rownames(tabN2), las=2, cex.axis=0.7)

lx2=sapply(allCoding_top90, nrow)

barplot(lx2, ylab="no# mutations in top 90 genes", las=2)

```

## Find coding mutations which are specific to ep cells

Here, look for mutations from RNA which are present in the epithelial cells specific

```{r}
VarTypes=c("frameshift", "missense", "start_lost", "stop_gained", "nonsense", "stop_retained")
n2=unique(unlist(sapply(VarTypes, function(x) grep(x, MallCodingHaplo$ANNOTATION))))
MallCodingHaploFunc=MallCodingHaplo[ n2, ]
## Look at epithealial samples

xa=grep("Ep", MallCodingHaploFunc$L1)
MallEpi=MallCodingHaploFunc[xa, ]
EpVarList=table(MallCodingHaploFunc$GENE[xa])
EpVarNames=names(EpVarList)
EpVarN2=names(EpVarList[which(EpVarList>1)])
EpVarListB=table(MallCodingHaploFunc$mutPos[xa])
EpLoc=names(EpVarListB)[which(EpVarListB>1)]

## Look at CD45 samples
xa=grep("CD45$", MallCodingHaploFunc$L1)
CDVarList=table(MallCodingHaploFunc$GENE[xa])
CDVarNames=names(CDVarList)
CDVarN2=names(CDVarList[which(CDVarList>=1)])
CDVarListB=table(MallCodingHaploFunc$mutPos[xa])
CDLoc=names(CDVarListB)[which(CDVarListB>=1)]


## Look at CD45 normal
xa=grep("CD45plus", MallCodingHaploFunc$L1)
nCD45VarList=table(MallCodingHaploFunc$GENE[xa])
nCD45VarNames=names(nCD45VarList)
nCD45VarN2=names(nCD45VarList[which(nCD45VarList>=1)])
nCD45VarListB=table(MallCodingHaploFunc$mutPos[xa])
nCDLoc=names(nCD45VarListB)[which(nCD45VarListB>=1)]

## List of ep-spec variants
eplist1=setdiff(setdiff(EpVarN2, CDVarN2), nCD45VarN2)
## Obtain the list of Ep-specific variants and cross-reference with genomic data
WGSListgenes=table(MeltWGSCodingB$Gene_Symbol)
WGSListgenes=names(WGSListgenes)[which(WGSListgenes>1)]

RList=MallEpi[which(MallEpi$GENE%in%eplist1), ]
Rlist2=table(RList$mutPos)
Rlist2=names(Rlist2)[which(Rlist2>1)]

WGSList=paste(MeltWGSCodingB$Gene_Symbol, MeltWGSCodingB$Start_Position)
t2=table(WGSList)
WGSList=names(t2)[which(t2>1)]
mutlist=intersect(Rlist2, WGSList)

pdf("~/Desktop/RNA-specific-mutations-gene-level.pdf", height=6, width=6)

venn(list(Ep=EpVarNames, CD45=CDVarNames, nCD45=nCD45VarNames))
mtext("no genes w mutations overlapping in different fractions")

venn(list(Ep=EpVarN2, CD45=CDVarN2, nCD45=nCD45VarN2))
mtext("no genes with overlapping variants in 2+ samples")

venn(list(Ep_RNA=eplist1, Ep_WGS=WGSListgenes))
mtext("No genes with overlaps in 2+ samples")
dev.off()
```

Location specific mutations:

```{r}
#pdf("~/Desktop/RNA-specific-mutations-location-level.pdf", height=7, width=10)

venn(list(Ep=EpLoc, CD45=CDLoc, nCD45=nCDLoc))
mtext("no locations with overlapping variants in 2+ samples")

venn(list(Ep_RNA=Rlist2, Ep_WGS=WGSList))
mtext("No ep. specifc locations with overlaps in 2+ samples")

# plots of mutational frequencies of the locations in A1
Ttemp=acast(MallCodingHaploFunc[which(MallCodingHaploFunc$mutPos%in%mutlist), c("L1", "mutPos")], mutPos~L1)
Ttemp=cbind(Ttemp, 0)
colnames(Ttemp)[ncol(Ttemp)]="NMU13_LAU_Ep"

ax2=setdiff(unique(MallEpi$L1), colnames(Ttemp))

Wtemp=acast(MeltWGSCoding[which(MeltWGSCodingB$mutPos%in%mutlist), c("L1", "mutPos", "Start_Position")],mutPos~L1)
Wtemp[which(is.na(Wtemp), arr.ind = T)]=0

par(oma=c(5, 5, 1, 1))
image(sign((Ttemp)), col=c("white","darkblue"), xaxt="none", yaxt="none")
axis(1, at=seq(0, 1, length=nrow(Ttemp)),rownames(Ttemp), las=2)
axis(2, at=seq(0, 1, length=ncol(Ttemp)),colnames(Ttemp), las=2)
mtext("Mutations in RNA & in WGS data")

par(oma=c(5, 5, 1, 1))
image(sign(Wtemp), col=c("white","darkblue"), xaxt="none", yaxt="none")
axis(1, at=seq(0, 1, length=nrow(Wtemp)),rownames(Wtemp), las=2)
axis(2, at=seq(0, 1, length=ncol(Wtemp)),colnames(Wtemp), las=2)

# mtext("Mutations in WGS data")
# par(oma=c(2,2,2,5))
# heatmap.2(t(ExprVSD), trace="none", scale="none", Rowv = NA, Colv = NA, col=RdBu[11:1],
#           main="gene expression, vst transformed")
# heatmap.2(t(ExprVSD), trace="none", scale="col", Rowv = NA, Colv = NA, col=RdBu[11:1],
#           main="gene expression, col scaled")
# 
# # calculate the correlation between mutation and expression
# 
# mvals=rep(NA, nrow(ExprVSD))
# names(mvals)=rownames(ExprVSD)
# mvalsP=mvals
# 
# x1=match(colnames(ExprVSD), colnames(Ttemp))
# for (i in 1:length(mvals)){
#   ax1=glm(sign(Ttemp[i, x1])~ExprVSD[i, ], family =binomial(link="logit"))
#   mvals[i]=coefficients(ax1)[2]
#   mvalsP[i]=summary(ax1)$coefficients[2,4]
# }
# 
# barplot(mvalsP,las=2, ylab = "P value of association bw mutation and expression")

#dev.off()
```

There are `r length(ax1)` mutations which are found in both the RNA and WGS data (2+ samples, not found in RNAseq)

## Filtering WGS data based on CD45 data

* Use the entire list for WGS
* Find mutations in CD45 (either) and remove

```{r}
#head(MeltWGSCoding)
#head(MallCodingHaploFunc)

lx1=grep("CD45", MallCodingHaploFunc$L1)

mutDiff=setdiff(MeltWGSCodingB$mutPos, MallCodingHaploFunc$mutPos[lx1])

NUnique=table(MeltWGSCodingB$mutPos[MeltWGSCodingB$mutPos%in%mutDiff])
NUniqueB=table(MeltWGSCodingB$Gene_Symbol[MeltWGSCodingB$mutPos%in%mutDiff])


rGeneOut=acast(MeltWGSCodingB[ MeltWGSCodingB$mutPos%in%names(NUnique),c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))

mxl=unique(as.vector(rGeneOut))
rGeneOut2b=rGeneOut
rGeneOut2b[grep("Nonsense",rGeneOut2b)]=3
rGeneOut2b[grep("Frame_Shift",rGeneOut2b)]=2
rGeneOut2b[grep("Missense_", rGeneOut2b)]=1
rGeneOut2b[grep("Splice_", rGeneOut2b)]=4
rGeneOut2b[which(rGeneOut2b=="")]=0

rGeneOut2b=apply(rGeneOut2b, 2, as.numeric)
rownames(rGeneOut2b)=rownames(rGeneOut)

rmThese=c("^AABR", "^Olr", "^LOC", "^AC[0-9]+", "^RGD", "^Rpl", "^1700", "^RT1", "^ENSRNOG", "^Vom2")
rmList=unlist(sapply(rmThese, function(x) grep(x, colnames(rGeneOut2b))))
rGeneOut2b=rGeneOut2b[ ,-rmList]


NtopA=names(NUnique)[which(NUnique>6)]
NtopAb=unique(sapply(strsplit(NtopA, " "), function(x) x[1]))
tempAnew=rGeneOut2b[, na.omit(match(NtopAb, colnames(rGeneOut2b)))]

tempA=heatmap.2(sign(tempAnew))
tempA=tempAnew[tempA$rowInd, tempA$colInd]

HSAnew=hotspotLocExtract(tempA)


## NtopB=which(NUnique>10)
NtopB=names(NUniqueB)[which(NUniqueB>1)]
NtopB2=NtopB[NtopB%in%RatCosmic]

tempBnew=rGeneOut2b[, na.omit(match(NtopB2, colnames(rGeneOut2b)))]

tempB=heatmap.2(sign(tempBnew))
tempB=tempBnew[tempB$rowInd, tempB$colInd]

HSBnew=hotspotLocExtract(tempB)

pdf("~/Desktop/WGS-coding-mutations-not-in-CD45-RNA.pdf", height=7, width=13)
## Commonly mutated Genes:
par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempA), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempA)), colnames(tempA), las=2, cex.axis=0.5)
axis(2, at=seq(0, 1, length=nrow(tempA)), rownames(tempA), las=2, cex.axis=0.5)
text(na.omit(HSAnew$Y-1)/(ncol(tempA)-1), na.omit(HSAnew$X-1)/(nrow(tempA)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("top 118 mutations", side=3, line=-1, outer=T)
dev.off()

pdf("~/Desktop/WGS-COSMIC-mutations-not-in-CD45-RNA.pdf", height=7, width=13)
## Commonly mutated Genes:
par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempB), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempB)), colnames(tempB), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tempB)), rownames(tempB), las=2, cex.axis=0.7)
text(na.omit(HSBnew$Y-1)/(ncol(tempB)-1), na.omit(HSBnew$X-1)/(nrow(tempB)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("Common COSMIC mutations", side=3, line=-1, outer=T)
dev.off()
```

<!--chapter:end:10b-mutations-RNA.Rmd-->

# Associating expression with Mutations

Also plot the expression of the corresponding genes here, if the epithelial RNA data is present. Note, with this early batch, the DN population was not sorted by FACS nor sequenced.


```{r}
# Filter out the sample names and find their RNA-sample ID
Xnames=unique(MeltCosmic$L1)
midx=Cdata$TumorID[match(Xnames, sapply(strsplit(Cdata$WGS, ".final.bam"), function(x) x[1]))]
# Filter out all gene expression data which is in the characterisation cohort
allTPMchar=allTPMFinal[ , which(infoTableFinal$Cohort!="Progression")]
infoTableFinalchar=infoTableFinal[ which(infoTableFinal$Cohort!="Progression"),]
nVSDchar=normalizedTableVSD[ , which(infoTableFinal$Cohort!="Progression")]

cnames2=gsub("_CD45","", colnames(allTPMchar))
cnames2=gsub("_Ep", "", cnames2)

lxMatch=which(cnames2 %in% midx)
lxMatch2=which(midx %in% cnames2)
```

The following samples have matching WGX data: `r colnames(allTPMchar)[lxMatch]` from samples `r midx[lxMatch2]`

## Expression of genes in common

```{r}
RNames=c("Ccn2", sapply(strsplit(rownames(Wtemp), " "), function(x) x[1]))

TtempNames=sapply(strsplit(colnames(Ttemp), " "), function(x) x[1])

ExprVSD=nVSDchar[na.omit(match(RNames, rownames(nVSDchar))), na.omit(match(TtempNames, colnames(nVSDchar)))]

par(oma=c(2,2,2,5))
heatmap.2(t(ExprVSD), trace="none", scale="none", Rowv = NA, Colv = NA, col=RdBu[11:1],
          main="gene expression, vst transformed")
heatmap.2(t(ExprVSD), trace="none", scale="col", Rowv = NA, Colv = NA, col=RdBu[11:1],
          main="gene expression, col scaled")

```

Compare RNA mut freq & expression values

```{r}
par(oma=c(2,2,2,2))
heatmap.2(t(ExprVSD), trace="none", scale="none", Rowv = NA, Colv = NA, col=RdBu[11:1],
          main="gene expression, vst transformed")
heatmap.2(t(ExprVSD), trace="none", scale="col", Rowv = NA, Colv = NA, col=RdBu[11:1],
          main="gene expression, col scaled")

# calculate the correlation between mutation and expression

mvals=rep(NA, nrow(ExprVSD))
names(mvals)=rownames(ExprVSD)
mvalsP=mvals

head(Ttemp)

# x1=match(colnames(ExprVSD), TtempNames)
# for (i in 1:length(mvals)){
#   ax1=glm(sign(Ttemp[i, x1])~ExprVSD[i, ], family =binomial(link="logit"))
#   mvals[i]=coefficients(ax1)[2]
#   mvalsP[i]=summary(ax1)$coefficients[2,4]
# }
# 
# barplot(mvalsP,las=2, ylab = "P value of association bw mutation and expression")
```

## Expression of genes with key mutations

We can still look at expression of genes of interest.
Eg. C2N may be enriched in kalikrein systen, connective tissue degradation
NMU12_LA in endothelium_leukocyte interactions, IL6 signalling
NMU12 RL in NOTCH signalling?

```{r}
# calculate z-scores for the process network pathways
PNzscore=scale(SumTable2)
PNsub=which(abs(PNzscore[Xnames[lxMatch2], ])>2, arr.ind=T)
pways=colnames(SumTable2)[unique(PNsub[ ,2])]

library(GSVA)
load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData")

# perform GSVA for process networks based on epithelial samples first
# Convert teh Gene symbols to Human
mxd=SymHum2Rat$HGNC.symbol[match(rownames(nVSDchar), SymHum2Rat$RGD.symbol)]
mxd[which(is.na(mxd))]=toupper(rownames(nVSDchar)[which(is.na(mxd))])

tVar=nVSDchar[ ,grep("Ep", colnames(allTPMchar))]
rownames(tVar)=mxd

GSVAoutput1=gsva(tVar, gset.idx.list=PathwayMapAllComp, method="ssgsea", kcdf="Poisson", ssgsea.norm=T, verbose=F, min.sz=1)
# match the rownames
msets=match(gsub(" ", "", colnames(SumTable2)), gsub(" ", "", rownames(GSVAoutput1)))

gsvaVal=GSVAoutput1[msets, ]

par(oma=c(3, 1,1,3))
heatmap.2(t(gsvaVal[ lx, ]), scale="none", trace="none", col=RdBu[11:1], main="Process Networks: CD45 population", ColSideColors = cCols[lx], Colv = NA)


## plot heatmaps for the above pathways
pdf("outputs/1M_Char_cohort_pways_of_interest-Ep.pdf", height=7, width=6)
par(oma=c(3, 1,1,3))
for (i in pways){
  a1=PathwayMapAllComp[[i]]
  t2=nVSDchar[ na.omit(match(a1, mxd)) ,grep("Ep", colnames(allTPMchar))]
  rm=rowSds(t2)
  heatmap.2(t2[which(rm>1),], scale = "row", col=RdBu[11:1], trace="none", main=paste(i, "Epi"))
}
dev.off()


pdf("outputs/1M_Char_cohort_pways_of_interest-CD45.pdf", height=7, width=6)
par(oma=c(3, 1,1,3))
for (i in pways){
  a1=PathwayMapAllComp[[i]]
  t2=nVSDchar[ na.omit(match(a1, mxd)) ,grep("CD45", colnames(allTPMchar))]
   rm=rowSds(t2)
  heatmap.2(t2[which(rm>1), ], scale = "row", col=RdBu[11:1], trace="none", main=paste(i, "CD"))
}
dev.off()
```

## Expression of common mutations?

Run the following to plot this for both the cd45 fraction as well as the epithelial fraction:


```{r}

fgenes=colnames(tempz2)
#pdf("outputs/1Ja_gene-expression-common-mutations.pdf", height=8, width=5.6)

t2=nVSDchar[ na.omit(match(fgenes,rownames(nVSDchar))) ,grep("CD45", colnames(nVSDchar))]
OutputplotFun(t2, "row", "Scaled CD", "wgs")
OutputplotFun(t2, "none", "non-Scaled CD", "wgs")
  
t2=nVSDchar[ na.omit(match(fgenes,rownames(nVSDchar))) ,grep("Ep", colnames(nVSDchar))]
OutputplotFun(t2, "row", "Scaled Ep", "wgs")
OutputplotFun(t2, "none", "non-Scaled Ep", "wgs")

#dev.off()

```

### Look at cancer specific pathways


```{r}

colCols=rep("red", ncol(nVSDchar))
colCols[grep("CD45", colnames(nVSDchar))]="green"
colCols[match(names(which(km4$cluster==2)), colnames(nVSDchar))]="blue"

Cancer_pways=gsva(nVSDchar, PathwayListRat,
                    method="ssgsea", kcdf="Poisson", ssgsea.norm=T, verbose=F, min.sz=1)

pdf("outputs/1N_enriched_Cancer_signalling_pathways.pdf", width=6, height=6)
heatmap.2(Cancer_pways[-5, ], scale = "none", col=RdBu[11:1], trace="none", main="ssGSEA enrichment scores unscaled",
          ColSideColors = colCols)
x2=grep("CD45", colnames(nVSDchar))
heatmap.2(Cancer_pways[-5, -x2], scale = "none", col=RdBu[11:1], trace="none", main="ssGSEA enrichment scores unscaled",
          ColSideColors = colCols[-x2])
dev.off()

```


## Expression of immune related genes in the CD45 population

Initially do a search for the mutations shown before, also can do immune specific mutations

```{r, eval=F}
xa=colnames(nVSDchar)[grep("CD45", colnames(nVSDchar))]
lx2=ColC
names(lx2)=gsub("Ep", "CD45", names(ColC))
m1=match(xa, names(lx2))
CD45PAM=lx2[m1]
CD45PAMcol=ifelse(CD45PAM=="Lum", "blue", ifelse(CD45PAM=="Basal", "red", "grey"))
# correlation plots based on all genes

pdf("~/Dropbox (Partners HealthCare)/Carlos' leukocyte project/Manuscript/figure_panels_generated_R/Figure1/test.pdf", height=6, width=6)

Ax1=cor(nVSDchar[, xa])
heatmap.2(Ax1, ColSideColors = CD45PAMcol, trace="none", scale="none", col=RdBu[11:1],
          main="All genes")

# correlation based on RatCosmic genes
Ax2=cor(nVSDchar[na.omit(match(RatCosmic, rownames(nVSDchar))), xa])
heatmap.2(Ax2, ColSideColors = CD45PAMcol, trace="none", scale="none", col=RdBu[11:1],
          main="immune related genes")

plotPCA(vsd[, which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort!="Progression")],
        "Treatment")+geom_label(aes(label = name)) 

dev.off()

# correlation plot based on immune related genes


# x1=which(colnames(rGeneOut2)%in%RatAllImm)
# 
# temp=rGeneOut2[ ,x1]
# #a1=heatmap(temp, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
# a2=temp[a1$rowInd, a1$colInd]
# hotspotC=hotspotLocExtract(a2)

MatchSampleCD45=paste(RNADNAsamples$Rat_ID[Midx], RNADNAsamples$Location.x[Midx],"CD45",  sep="_")

mCDsamples=match(MatchSampleCD45, colnames(assay(vsd)))

#tempVSDcd45=matrix(NA, nrow=nrow(a2), ncol=ncol(a2))

idx1=match(colnames(a2),rownames(assay(vsd)))
tempVSDcd45=t(assay(vsd)[ na.omit(idx1),na.omit(mCDsamples)])
rownames(tempVSDcd45)=rownames(a2)[which(!is.na(mCDsamples))]
a1=setdiff(colnames(a2), colnames(tempVSDcd45))
mat2=matrix(NA, ncol=length(a1), nrow=nrow(tempVSDcd45))
colnames(mat2)=a1
tempVSDcd45=cbind(tempVSDcd45, mat2)
mat3=matrix(NA, nrow=length(which(is.na(mCDsamples))), ncol=ncol(tempVSDcd45))
rownames(mat3)=rownames(a2)[which(is.na(mCDsamples))]
tempVSDcd45=rbind(tempVSDcd45, mat3)
tempVSDcd45=tempVSDcd45[match(rownames(a2), rownames(tempVSDcd45)), match(colnames(a2), colnames(tempVSDcd45))]
#tempVSDb=matrix(NA, ncol=ncol(a2), nrow=nrow(a2))
#tempVSDb[match(rownames(tempVSD), rownames(a2)), ]

#tempVSD=scale(tempVSD)
rownames(tempVSDcd45)=paste(rownames(a2), "CD45", sep="-")
#colnames(tempVSDcd45)=colnames(a2)
tempVSDcd45scale=scale(tempVSDcd45)


par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempVSDcd45scale), col=RdBu[11:1], xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(a2)), colnames(a2), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(a2)), rownames(a2), las=2, cex=0.7)
text(na.omit(hotspot1$Y-1)/(ncol(a2)-1), na.omit(hotspot1$X-1)/(nrow(a2)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("Nonsense","frameshift", "missense","splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)

## rm the non expressing samples

tempVSD3b=tempVSDcd45[-which(is.na(mCDsamples)), ]
MutB=a2[-which(is.na(mCDsamples)), ]

List2=which(MutB>0, arr.ind=T)
hotspotB=hotspotLocExtract(MutB)

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempVSD3b), col=RdBu[11:1], xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempVSD3b)), colnames(tempVSD3b), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(tempVSD3b)), rownames(tempVSD3b), las=2, cex=0.7)
text(na.omit(List2[ ,2]-1)/(ncol(tempVSD3b)-1), na.omit(List2[ ,1]-1)/(nrow(tempVSD3b)-1) , "*")

image(t(MutB), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(MutB)), colnames(MutB), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(MutB)), rownames(MutB), las=2, cex=0.7)
text(na.omit(hotspotB$Y-1)/(ncol(MutB)-1), na.omit(hotspotB$X-1)/(nrow(MutB)-1) , "*")
```

Immune specific mutations

```{r, eval=F}
# x1=which(colnames(rGeneOut2)%in%RatAllImm)
# 
# temp=rGeneOut2[ ,x1]
# #a1=heatmap(temp, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
# a2=temp[a1$rowInd, a1$colInd]
# hotspotC=hotspotLocExtract(a2)
# load("WGS_mutations_coding.RData")
# MeltWGSCoding=melt(AllMutWGScoding)
idx1=which(MeltWGSCodingB$Gene_Symbol%in%unique(unlist(Exp2RatImm[c(10:14)]))) # change this to RatAllImm
#sigNames=unlist(Exp2RatImm[c(1:5, 8:9, 15:17)])
sigNames=unlist(Exp2RatImm[c(10:14)])

rGeneOutImm=acast(MeltWGSCodingB[ idx1,c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))

#mxl=unique(as.vector(rGeneOut))
rGeneOut2I=rGeneOutImm
rGeneOut2I[grep("Nonsense",rGeneOut2I)]=3
rGeneOut2I[grep("Frame_Shift",rGeneOut2I)]=2
rGeneOut2I[grep("Missense_", rGeneOut2I)]=1
rGeneOut2I[grep("Splice_", rGeneOut2I)]=4
rGeneOut2I[which(rGeneOut2I=="")]=0

rGeneOut2I=apply(rGeneOut2I, 2, as.numeric)
rownames(rGeneOut2I)=rownames(rGeneOutImm)

GeneList=colSums(sign(rGeneOut2I), na.rm=T)

top30=names(sort(GeneList, decreasing=T)[1:length(GeneList)])
# do a plot of the top 30 most common mutations
temp=rGeneOut2I[ ,top30]
tempx=temp[grep("^N|C", rownames(temp)), ]
a1a=heatmap(tempx, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
tempy=temp[grep("D", rownames(temp)), ]
a1b=heatmap(tempy, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
a2=rbind(tempx[a1a$rowInd, a1a$colInd], tempy[a1b$rowInd, a1a$colInd])

l1=as.numeric(RNADNAsamples$Treatment[match(rownames(a2), sapply(strsplit(as.character(RNADNAsamples$WGS), ".final.bam"), function(x) x[1]))])
colSC=palette()[l1+4]

x1=order(l1)

RowSC=sigNames[match(colnames(a2), sigNames)]
RowSC=substr(names(RowSC), 1, 4)

a2=a2[x1, order(RowSC) ]

#hotspot1=hotspotLocExtract(a2)


par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(a2), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(a2)), colnames(a2), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(a2)), rownames(a2), las=2, cex=0.7)
#text(na.omit(hotspot1$Y-1)/(ncol(a2)-1), na.omit(hotspot1$X-1)/(nrow(a2)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift","Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)



# use specifically the cases where GeneList > 3

idx2=names(GeneList)[which(GeneList>2)]


MatchSampleCD45=paste(RNADNAsamples$Rat_ID[Midx],  RNADNAsamples$Location.x[Midx], "CD45",sep="_")

mCDsamples=match(MatchSampleCD45, colnames(assay(vsd)))

#tempVSDcd45=matrix(NA, nrow=nrow(a2), ncol=ncol(a2))

idx1=match(idx2,rownames(assay(vsd)))
tempVSDcd45b=t(assay(vsd)[ na.omit(idx1),na.omit(mCDsamples)])
rownames(tempVSDcd45b)=rownames(a2)[which(!is.na(mCDsamples))]
a1=setdiff(rownames(a2), rownames(tempVSDcd45b))
mat2=matrix(NA, nrow=length(a1), ncol=ncol(tempVSDcd45b))
rownames(mat2)=a1
tempVSDcd45b=rbind(tempVSDcd45b, mat2)

tempVSDcd45b=tempVSDcd45b[match(rownames(a2), rownames(tempVSDcd45b)), ]

#tempVSD=scale(tempVSD)
#rownames(tempVSDcd45b)=paste(rownames(a2), "CD45", sep="-")
#colnames(tempVSDcd45)=colnames(a2)
tempVSDcd45scaleb=scale(tempVSDcd45b)

l2=rGeneOut2I[ match(rownames(tempVSDcd45b), rownames(rGeneOut2I)), match(colnames(tempVSDcd45b), colnames(rGeneOut2I))]

hotspot2=which(l2>0, arr.ind = T)

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempVSDcd45scaleb), col=RdBu[11:1], xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempVSDcd45scaleb)), colnames(tempVSDcd45scaleb), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(tempVSDcd45scaleb)), rownames(tempVSDcd45scaleb), las=2, cex=0.7)
text(na.omit(hotspot2[ ,2]-1)/(ncol(tempVSDcd45scaleb)-1), na.omit(hotspot2[ ,1]-1)/(nrow(tempVSDcd45scaleb)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("Nonsense","frameshift", "missense","splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)



```

#### Combine the two fractions together

```{r, eval=F}
# getidx=rbind(mEpsamples, mCDsamples)
# colnames(getidx)=rownames(a2)
tempV2=rbind(tempVSD, tempVSDcd45)
tempV2scale=scale((tempV2))

index=rep(c(1:16), each=2)
index[seq(2, length(index), by=2)]=index[seq(2, length(index), by=2)]+16

tempV2N=tempV2scale[index, ]


cases=rep(rownames(a2), each=2)

MutB=a2[match(cases, rownames(a2)) ,]
hotspotB=hotspotLocExtract(MutB)
List2=which(MutB>0, arr.ind=T)


par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempV2N), col=RdBu[11:1], xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempV2scale)), colnames(tempV2N), las=2, cex=0.7)
axis(2, at=seq(0, 1, length=nrow(tempV2scale)), rownames(tempV2N), las=2, cex=0.7)
text(na.omit(List2[ ,2]-1)/(ncol(tempV2scale)-1), na.omit(List2[ ,1]-1)/(nrow(tempV2scale)-1) , "*")


```

## Cancer Specific Pathways

```{r, eval=F}
CancerMeltCoding=MeltWGSCoding[which(MeltWGSCoding$Gene_Symbol%in%AllCancerPathwayGenes & MeltWGSCoding$Variant_Classification%in%searchThese), ]


rGeneOut=acast(CancerMeltCoding[ ,c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))
rGeneOut[grep( "Missense",rGeneOut) ]="1"
rGeneOut[grep( "Nonsense",rGeneOut) ]="2"
rGeneOut[grep( "Frame",rGeneOut) ]="3"
rGeneOut[grep( "Nonstop",rGeneOut) ]="4"
rGeneOut[which( rGeneOut=="", arr.ind=T) ]="0"
rGeneOut2=apply(rGeneOut, 2, as.numeric)
rownames(rGeneOut2)=rownames(rGeneOut)

GenePathway=names(AllCancerPathwayGenes)[match(colnames(rGeneOut2), AllCancerPathwayGenes)]
GenePathway=substr(GenePathway, 1, 3)

rowSC=palette()[factor(GenePathway)]
rowSC2=rep(NA, length(rowSC))
rowSC2[which(colnames(rGeneOut2)%in%unlist(AllCancerPathwayTS))]="red"
rowSC2[which(colnames(rGeneOut2)%in%unlist(AllCancerPathwayOG))]="green"

l1=as.numeric(RNADNAsamples$Treatment[match(rownames(rGeneOut2), sapply(strsplit(as.character(RNADNAsamples$WGS), ".final.bam"), function(x) x[1]))])
colSC=palette()[l1+4]

x1=order(rowSC, rowSC2)
x2=order(l1)


#a1=heatmap.2(rGeneOut2[-grep("CD45", rownames(rGeneOut2)), x1], Colv = NA, scale="none", trace="none", col=c("white", 1:4), ColSideColors = rowSC[x1])

a2=rGeneOut2[, x1]
a2=a2[x2, ]

# rsMatrix=acast(CancerMeltCoding[ ,c("GENE", "L1", "ID")], L1~GENE,value.var="ID", fun.aggregate = function(x) length(which(x!=""))) #grep("H", x)
# rsMatrixSearch=rsMatrix[match(rownames(a2), rownames(rsMatrix)), match( colnames(a2), colnames(rsMatrix)) ]
# 
# Listout=which(rsMatrixSearch>0, arr.ind = T)

heatmap.plus(a2, Colv = NA, Rowv=NA, scale="none", trace="none", col=c("white", 1:4), ColSideColors = cbind(rowSC[x1],rowSC2[x1]), RowSideColors=cbind(colSC[x2],colSC[x2]))

SSumm1=sapply(1:nrow(rGeneOut2), function(x) stack(by(sign(rGeneOut2[x, ]), GenePathway, sum, na.rm=T))$values)
colnames(SSumm1)=rownames(rGeneOut2)
rownames(SSumm1)=levels(factor(GenePathway))

Nlist=sapply(PathwayListRat, length)

AllMat3=(SSumm1)/Nlist[c(11, 2:4, 6, 8:10)]
AllMat3[which(AllMat3>0, arr.ind = T)]=AllMat3[which(AllMat3>0, arr.ind = T)]+0.1

heatmap.2(t(AllMat3[ ,x2]), col=brewer.pal(9, "Blues"), trace="none", scale="none", RowSideColors =colSC[x2], Rowv = NA)
```

Also separate out the TS and OG: change the first two lines of this to list this informaiton

```{r, eval=F}
names(AllCancerPathwayOG)=c(names(PathwayListRat), "Breast")
AllCancerPathwayTSlist=unlist(AllCancerPathwayOG)

CancerMeltCoding=MeltWGSCoding[which(MeltWGSCoding$Gene_Symbol%in%AllCancerPathwayTSlist & MeltWGSCoding$Variant_Classification%in%searchThese), ]

rGeneOut=acast(CancerMeltCoding[ ,c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))
rGeneOut[grep( "Missense",rGeneOut) ]="1"
rGeneOut[grep( "Nonsense",rGeneOut) ]="2"
rGeneOut[grep( "Frame",rGeneOut) ]="3"
rGeneOut[grep( "Nonstop",rGeneOut) ]="4"
rGeneOut[which( rGeneOut=="", arr.ind=T) ]="0"
rGeneOut2=apply(rGeneOut, 2, as.numeric)
rownames(rGeneOut2)=rownames(rGeneOut)

GenePathway=names(AllCancerPathwayTSlist)[match(colnames(rGeneOut2), AllCancerPathwayTSlist)]
GenePathway=substr(GenePathway, 1, 3)

rowSC=palette()[factor(GenePathway)]
l1=as.numeric(RNADNAsamples$Treatment[match(rownames(rGeneOut2), 
                                                         sapply(strsplit(as.character(RNADNAsamples$WGS), ".final.bam"), function(x) x[1]))])
colSC=palette()[l1+4]

x1=order(rowSC)
x2=order(l1)
#a1=heatmap.2(rGeneOut2[-grep("CD45", rownames(rGeneOut2)), x1], Colv = NA, scale="none", trace="none", col=c("white", 1:4), ColSideColors = rowSC[x1])

a2=rGeneOut2[, x1]
a2=a2[x2, ]

# rsMatrix=acast(CancerMeltCoding[ ,c("GENE", "L1", "ID")], L1~GENE,value.var="ID", fun.aggregate = function(x) length(which(x!=""))) #grep("H", x)
# rsMatrixSearch=rsMatrix[match(rownames(a2), rownames(rsMatrix)), match( colnames(a2), colnames(rsMatrix)) ]
# 
# Listout=which(rsMatrixSearch>0, arr.ind = T)

heatmap.plus(a2, Colv = NA, Rowv=NA, scale="none", trace="none", col=c("white", 1:3), ColSideColors = cbind(rowSC[x1],rowSC[x1]), RowSideColors=cbind(colSC[x2],colSC[x2]))
```


### Compute co-occurence matrices

Use all genes in WGS coding

Firstly by genomic location: pull out the top mutations occurring in at least 5 samples: this gives approximately 7000 loci.


```{r, eval=F}

## run the analysis

x1a=table(MeltWGSCodingB$Start_Position)
checkThese=names(x1a)[which(x1a>5)]
matrixSumP=matrix(NA, ncol=length(checkThese), nrow=length(checkThese))
matrixSumOR=matrix(NA, ncol=length(checkThese), nrow=length(checkThese))

allSamp=unique(MeltWGSCodingB$L1)

for (i in 662:length(checkThese)){
  xa=which(MeltWGSCodingB$Start_Position==checkThese[i])
  T1=MeltWGSCodingB$L1[xa]
  tt1=allSamp%in%T1
  if (sum(tt1)<length(allSamp)){
    for (j in 1:length(checkThese)){
    xb=which(MeltWGSCodingB$Start_Position==checkThese[j])
    T2=MeltWGSCodingB$L1[xb]
    tt2=allSamp%in%T2
      if (sum(tt2)<length(allSamp)){
        xn=fisher.test(table(tt1, tt2))
        matrixSumP[i,j]=xn$p.value
        matrixSumOR[i,j]=xn$estimate
  }}
  }
}

matrixSumP_padj=matrix(p.adjust(matrixSumP, "fdr"), nrow=nrow(matrixSumP)) 
rownames(matrixSumP_padj)=paste(MeltWGSCodingB$Gene_Symbol[match(checkThese, MeltWGSCodingB$Start_Position)], checkThese)
colnames(matrixSumP_padj)=rownames(matrixSumP_padj)
rownames(matrixSumOR)=rownames(matrixSumP_padj)
colnames(matrixSumOR)=colnames(matrixSumP_padj)

save(matrixSumOR, matrixSumP_padj, file="rslt/WXS_co-occurrence_rslt.RData")
```


```{r, eval=F}
load("rslt/WXS_co-occurrence_rslt.RData")

# image the data
# figure out the rows and columns which ahve p<0.1 off the diagonal
olfidx=c(grep("Olr", colnames(matrixSumP_padj)), grep("Vom", colnames(matrixSumP_padj)), grep("AABR", colnames(matrixSumP_padj)), grep("RT1", colnames(matrixSumP_padj))) 

matrixP_rm=matrixSumP_padj[-olfidx, -olfidx ]
keepTheseCols=which(matrixP_rm<0.05, arr.ind=T)
mx1Sum=table(keepTheseCols[ ,2])
length(which(mx1Sum>1))
colidx=names(mx1Sum)[which(mx1Sum>1)]


# Note: most of these are olfactory receptors
matP2=matrixP_rm[as.numeric(colidx), as.numeric(colidx)]
matP2=-log10(matP2)
hmres=heatmap.2(matP2, trace="none", col=brewer.pal(9, "Blues"))

Idx2=cutree(as.hclust(hmres$rowDendrogram), k=10)

# Figure out the oncogenes in this list
checkGenes=MeltWGSCodingB$Gene_Symbol[match(checkThese, MeltWGSCodingB$Start_Position)]
mx1=unique(checkGenes[which(checkGenes%in% c(RatCosmic, AllCancerPathwayGenes))])

midxN=lapply(mx1, function(x) grep(x, colnames(matrixP_rm)))
matNew=matrixP_rm[ , unlist(midxN)]
Idx4=which(matNew<0.05, arr.ind=T)
matNew2=matNew[unique(Idx4[ ,1]), ]
matP2=-log10(matNew2)
matP2[which(matP2<1, arr.ind = T)]=0
par(mar=c(10,2,1,10))
hmres=heatmap.2(matP2, trace="none", col=brewer.pal(9, "Blues"), scale="none")

# 
getThese=c("Tcf", "Ros1", "Notch4", "Cebpa", "Prf1", "Ptprb")
x1=lapply(getThese, function(x) grep(x, colnames(matP2)))
matP3=matP2[, unlist(x1)]
matP3=matP3[-which(rowSums(matP3)==0), ]
hmres=heatmap.2(matP3, trace="none", col=brewer.pal(9, "Blues"), scale="none")

matP4=matrixSumOR[ rownames(matP3),colnames(matP3)]
matP4[which(matP4=="Inf", arr.ind = T)]=100
matP4[which(matP4>100, arr.ind = T)]=100
matP4[which(matP3==0, arr.ind=T)]=1
matP4[which(matP4==0, arr.ind=T)]=0.01
hmres=heatmap.2(log2(matP4), trace="none", col=brewer.pal(9, "RdBu"), scale="none")

```

<!--chapter:end:11-mutation-expression.Rmd-->

# haplotype caller

<!--chapter:end:12-haplotypecaller.Rmd-->

# Trichrome staining

Quantification of trichrome staining was performed in Qupath using the following steps:

* image is loaded as a "DAB" image
* using "gold standard" trichrome-stained images with good stroma and epithelial content, estimate the stain vectors
* The output matrix was: XXX
* Perform color deconvolution
* A pixel classifier was used to estimate trichrome content
* A pixel classifier was used to estimate tumor content

A snippet of the qupath script is shown below:

```{r, eval=F, echo=F}
# insert some text here

```

## Associations with cellular fraction (wsi)

```{r, height=6, eval=F}
# load the data
TrichromeData=read.csv("../data/quantification_trichrome_staining_2020-10-28.csv")
midx=match(TrichromeData$X, gsub("_", "", Cdata$TumorID))

Cdata$Trichrome=NA
Cdata$Trichrome[na.omit(midx)]=TrichromeData$Frac[which(!is.na(midx))]

t2=WSIvalFracs[, match(rownames(df.Spatial), colnames(WSIvalFracs))]

df.Spatial=cbind(df.Spatial, t(t2))

#head(df.Spatial)

df.Spatial$Trichrome=NA
midx=match(TrichromeData$X, rownames(df.Spatial))
df.Spatial$Trichrome[na.omit(midx)]=TrichromeData$Frac[-which(is.na(midx))]
# plot associations

n2=c("CD8", "EpCAM", "SMA", "Unclass", "EpCAM: SMA")

par(mfrow=c(2,3))
for (i in n2){
  a1=cor.test(df.Spatial$Trichrome, df.Spatial[ ,match(i, colnames(df.Spatial))], use="complete")
  n1=paste(i, "cor:", round(a1$estimate,1), "p:", round(a1$p.value,2))
  plot(df.Spatial$Trichrome, df.Spatial[ ,match(i, colnames(df.Spatial))], main=n1, xlab="Trichrome", ylab=i)
}
```

## Associations with growth and spatial patterns

```{r, fig.height=6, eval=F}
# plot associations with growth
n2=c("GrowthRate", "MH.EpCAM", "IF.EpCAM", "knn.EpCAM")

par(mfrow=c(2,2))
for (i in n2){
  a1=cor.test(df.Spatial$Trichrome, df.Spatial[ ,i], use="complete")
  n1=paste(i, "cor:", round(a1$estimate,1), "p:", round(a1$p.value,2))
  plot(df.Spatial$Trichrome, df.Spatial[ ,i], main=n1, xlab="Trichrome", ylab=i)
}
```

<!--chapter:end:13-trichrome-staining.Rmd-->

