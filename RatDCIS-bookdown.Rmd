--- 
title: "NMU-induced rat tumor models for I/O"
author: "Anne Trinh"
date: "`r Sys.Date()`"
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
colorlinks: yes
lot: yes
lof: yes
site: bookdown::bookdown_site
github-repo: polyak-lab/RatDCISbookdown
url: 'https://polyak-lab.github.io/RatDCISbookdown/'
description: "This is a summary of the code required in the study: 'NMU-induced rat tumor models for I/O' "
graphics: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache.lazy = F, fig.height =5, fig.width = 7, cache = T, 
                      warning=F, message=F, collapse = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 100px;
}
```


# Preface {-}

This is a summary of the tools and code required in the study: 'NMU-induced sprague dawley rat model of breast cancer treated with immunotherapy to prevent tumor progression' by Gil del Alcazar et al.

The GEO accession code for RNA-data is GSE167102. WGS will one day be available at SUB6887244.

Figures generated in the manuscript will be listed in the appendix and it can be cross-referenced to the relevant sections in this document

# Prerequisites

## Packages and Software

The following packages are required to conduct the analyses described below.

In house scripts are deposited in the rscript folder.

```{r, warning=F, message=F, echo=T, results='hide'}
library(AnnotationHub)
library(beeswarm)
library(biomaRt)
library(Biostrings)
library(colorspace)
library(DESeq2)
library(dplyr)
library(DT)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(forestplot)
library(GenVisR)
library(GenomicFeatures)
library(ggplot2)
library(ggrepel)
library(gplots)
library(GSEABase)
library(GSVA)
library(heatmap.plus)
library(HTSanalyzeR2)
library(kableExtra)
library(knitr)
library(limma)
library(matrixStats)
library(pamr)
library(reshape2)
library(rmarkdown)
library(RColorBrewer)
library(scales)
library(spatstat)
library(tcR)
library(vcfR)
library(xlsx)
library(writexl)

DiffCols=hue_pal()(8)
palette(brewer.pal(9, "Set1"))
RdBu=brewer.pal(11, "RdBu")
SetCols=brewer.pal(12, "Set3")


source("../rscript/cnFreq_fn.R") #modified version of GenVisR
source("../rscript/merge_contig.R")
source("../rscript/gseaCode.R")
source("../rscript/ContingencyTable.R")
source("../rscript/PvalueHeatMap.R")
source("../rscript/BootstrapShannonIdx.R")
source("../rscript/CreateRnor87db.R")
source("../rscript/FindRatAAHomolog.R")
source("../rscript/FindTriNucleotideContext.R")

firstup <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}

ColMerge=matrix(c("#FFC82F", "#FFEDBC", "#73FDFE","#D2FFFF", "#FF41FF", "#FECAFF", "#5D5D5D", "#BEBEBE"), ncol=2, byrow = T)
rownames(ColMerge)=c("LY","PDL1", "PDL1+LY","Vehicle")
ColSize=c("#008E00", "#FF9300")
names(ColSize)=c("small", "big")
ColSizeb=ColSize[2:1]
ColSizec=c(ColSize[2], "purple", ColSize[1])
hclust.ave <- function(x) hclust(x, method="average")

Hsedb<-EnsDb.Hsapiens.v86
```

## External software

The following external software was utilised:  

|Software| Function |
|--------|-----------------------------------------------------------------------|
|[bwa](http://bio-bwa.sourceforge.net/)| Alignment of WGS data to reference|
|[GATK4](https://software.broadinstitute.org/gatk/)| Mutation calling, done by NYGC. Mutation calling from RNA (Haplotype caller) |
|[strelka](https://github.com/Illumina/strelka)| Mutation calling, done by NYGC |
|[BICseq](http://compbio.med.harvard.edu/BIC-seq/) | CNV calling |
|[GEM3](https://sourceforge.net/projects/gemlibrary/files/gem-library/)| create mappability files for CNV calling|
|[STAR](https://github.com/alexdobin/STAR) | Alignment of RNAseq data|
|[RSEM](https://github.com/deweylab/RSEM)|Calculate RSEM, TPM, FPKM from RNAseq data|
|[TRUST4](https://github.com/liulab-dfci/TRUST4) | assignment of T and B cell clonotypes from RNA-seq data |
|[Oncotator](https://gatkforums.broadinstitute.org/gatk/discussion/4154/howto-install-and-run-oncotator-for-the-first-time) | Annotation of genetic variants|
|[QuPath](https://qupath.github.io/)| Tool for cell segmentation and extraction of features from IF images |
|[samtools, bcftools](http://www.htslib.org/)| querying and dispalying information from bam files, extracting allelic depth at specific genomic locations |
|[CIBERSORT](https://cibersort.stanford.edu/) | inferring immune composition from RNA|
|[lumpy](https://github.com/arq5x/lumpy-sv) | structural variants|
|[PAM50](https://genome.unc.edu/pubsup/breastGEO/PAM50.zip) | code from parker et al 2009 to infer PAM50 subtypes|


## Annotations

### Genomic properties

Information on chromosome sizes, cytobands and centromere locations were obtained from the [UCSC genome browser](http://hgdownload.soe.ucsc.edu/goldenPath/rn6/database/).

The following annotation data for the rn6 genome is required:

|Data Type| Download link|
|--------|-----------------|
|ref. genome| http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/rn6.fa.gz|
|refSeq annot|http://hgdownload.soe.ucsc.edu/goldenPath/rn6/bigZips/genes/rn6.refGene.gtf.gz|
|gff3 file| for TRUST4 (ftp://ftp.ensembl.org/pub/release-100/gff3/rattus_norvegicus/Rattus_norvegicus.Rnor_6.0.100.gff3.gz)|
|rn6cytoBand | [ucsc server](http://hgdownload.cse.ucsc.edu/goldenPath/rn6/database/cytoBand.txt.gz) of all cytoband locations  |
|rn6chrInfo | [ucsc server](http://hgdownload.cse.ucsc.edu/goldenPath/rn6/database/chromInfo.txt.gz) of all chromosome sizes  |
|[biomart](https://bioconductor.org/packages/release/bioc/html/biomaRt.html)| conversion between gene symbol, ensbl and entrez was faciliated using biomart package |

Below is the summary of chromosome sizes and centromere locations:

```{r}
chrInfo=read.delim("../anntotations/chromInfo_rat.txt", header=T)
cytoInfo=read.delim("../anntotations/cytoBand_Rat2.txt", header=F, stringsAsFactors = F)
colnames(cytoInfo)=c("chrom", "chromStart", "chromEnd", "name", "gieStain")
GRcytoInfo=GRanges(seqnames=cytoInfo$chrom, ranges=IRanges(start = cytoInfo$chromStart, end=cytoInfo$chromEnd), cytoband=cytoInfo$name)
head(GRcytoInfo)
```

Below is an example of the gene annotation files

```{r, eval=F}
txRn6=makeTxDbFromGFF("../anntotations/rn6_refGene.gtf", format="gtf")
txRn6=genes(txRn6)
txRn6=sort(txRn6)
txRn6$gene_width=width(txRn6)
save(txRn6, file="../anntotations/txRn6_refGene.RData")
```

```{r}
load("../anntotations/txRn6_refGene.RData")
head(txRn6)
```

### Gene name homologs between organisms

Biomart was used to convert between rat, mouse and human gene symbols and ensembl ids. Below is an example of the human gene names mapped to the rat homolog

```{r, eval=F}
## save here:
## human to rat mapping of genes
## rat ENSEMBL vs symbol conversion

library(biomaRt)
#library(refGenome)
TS=read.delim("../anntotations//hg38_allsymbols.txt")
TS=as.character(TS[ ,1])
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
rat = useMart("ensembl", dataset = "rnorvegicus_gene_ensembl")

SymHum2Rat = getLDS(attributes = c("hgnc_symbol"), filters = "hgnc_symbol", values = TS , mart = human, attributesL = c("rgd_symbol", "ensembl_gene_id"), martL = rat, uniqueRows=T)

Rat2Mouse= getLDS(attributes = c("rgd_symbol"), filters = "rgd_symbol", values = rownames(allrsemFinal) , mart = rat, attributesL = c("mgi_symbol"), martL = mouse, uniqueRows=T)

Mouse2Hum = getLDS(attributes = c("mgi_symbol"), filters = "mgi_symbol", values = rownames(allrsemFinal) , mart = mouse, attributesL = c("hgnc_symbol"), martL = human, uniqueRows=T)

save(SymHum2Rat, Rat2Hum,Mouse2Hum,Rat2Mouse,  file="../anntotations/Rat_biomart_gene_annotations.RData")
```

```{r}
load("../anntotations/Rat_biomart_gene_annotations.RData")
head(SymHum2Rat)
```

### Gene signatures and data-bases

Gene sets/signatures were obtained from the following sources:

|Source | Description      |
|-------|------------------------|
|[IEDB](https://www.iedb.org/)| database of immune epitopes |
|[MsigDB](http://software.broadinstitute.org/gsea/msigdb/index.jsp) | c2, c5, hallmark set of curated pathway gene sets |
|[Metacore](https://portal.genego.com/)| Process Networks and Pathway Maps data bases |
|[COSMIC](https://cancer.sanger.ac.uk/census) |database of concensus oncogenes|
|[ImmPort](https://www.immport.org/home)| List of immune related genes |
|[InnateDB](https://www.innatedb.com/) | List of genes associated with innate immune system|
|[Rosenthal 2019](https://dx.doi.org/10.1038/s41586-019-1032-7) | genes associated with MHC-I presentation |
|[Thorsson 2018](http://dx.doi.org/10.1016/j.immuni.2018.03.023) | Immune gene signatures curated from studies by Wolf, Calabro, Teschendorff, Beck, Chang |
|[Pardoll](https://www.ncbi.nlm.nih.gov/pubmed/22437870), [Wykes](https://www.ncbi.nlm.nih.gov/pubmed/28990586) | Immune checkpoint genes| 
|[Gil del Alcazar 2017](https://cancerdiscovery.aacrjournals.org/content/early/2017/09/19/2159-8290.CD-17-0222) | Supplementary table 5: list of activation, dysfunction gene signatures |
|[Bailey 2018](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6029450/)| List of 10 most comon tumor pathways |
|[Chang 2018](https://pubmed.ncbi.nlm.nih.gov/29247016/)| Common mutation locations in cancer |

```{r}
# These gene signatures are saved in the annotations folder and loaded below:
#########################
## cell specific markers
#######################
GeneList=read.csv("../anntotations/cell_type_markers.csv")
cn=colnames(GeneList)
GeneList=lapply(1:ncol(GeneList), function(x) setdiff(unique(GeneList[ ,x]), ""))
names(GeneList)=cn
## map all the names to rat names
GeneListRat=lapply(GeneList, function(x) SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%x])

######################
## cancer genes
######################

## cosmic cancer genes
AllCosmic=read.csv("../anntotations/Census_COSMIC_Feb2020.csv")
RatCosmic=SymHum2Rat$RGD.symbol[match(AllCosmic$Gene.Symbol, SymHum2Rat$HGNC.symbol)]
tx=AllCosmic$Gene.Symbol[which(is.na(RatCosmic)|RatCosmic=="")]
tx=tolower(tx)
tx=firstup(tx)
RatCosmic[which(is.na(RatCosmic)|RatCosmic=="")]=tx
RatBreastCosmic=RatCosmic[grep("breast", AllCosmic$Tumour.Types.Somatic.)]

## Bailey List of 10 most common tumor pathways
PathwayList=read.csv("../anntotations/cancer_pathways_annot_Bailey_cell2018_modified.csv")
cn=colnames(PathwayList)
PathwayListA=lapply(seq(1, length(cn), by=2), function(x) setdiff(unique(PathwayList[ ,x]), ""))
names(PathwayListA)=cn[seq(1, length(cn), by=2)]
PathwaySign=lapply(seq(2, length(cn), by=2), function(x) PathwayList[ which(PathwayList[ ,x]!=""),x])
names(PathwaySign)=cn[seq(1, length(cn), by=2)]

PathwayListRata=lapply(PathwayListA, function(x) SymHum2Rat$RGD.symbol[match(x, SymHum2Rat$HGNC.symbol)])
PathwayListRatb=lapply(PathwayListA, function(x) Rat2Hum$RGD.symbol[match(x, Rat2Hum$HGNC.symbol)])
PathwayListRat=lapply(1:length(PathwayListRata), function(x) ifelse(is.na(PathwayListRata[[x]]),
                        PathwayListRatb[[x]], PathwayListRata[[x]]))
names(PathwayListRat)=names(PathwayListA)

AllCancerPathwayGenes=na.omit(unlist(PathwayListRat))

############################
## List of immunesignatures
############################
## read in all the files
Exp2=read.csv("../anntotations/Supplementary Table 5.csv")
Exp2List=lapply(1:ncol(Exp2), function(x) setdiff(unique(Exp2[ ,x]), ""))
names(Exp2List)=colnames(Exp2)

List2=read.csv("../anntotations/Thorsson_signatures.csv")
List2b=lapply(1:ncol(List2), function(x) setdiff(unique(List2[ ,x]), ""))
names(List2b)=colnames(List2)
Exp2List=c(Exp2List, List2b)

ImmSuppAPC=read.delim("../anntotations/immune_Suppression.csv", header=T, stringsAsFactors = F, sep=",")
ImmSuppAPC=lapply(1:ncol(ImmSuppAPC), function(x) setdiff(unique(ImmSuppAPC[ ,x]), ""))
names(ImmSuppAPC)=c("Inh", "Act", "Both")
Exp2List=c(Exp2List, ImmSuppAPC)

MHCPres=read.delim("../anntotations/MHCloss.csv", header=F, stringsAsFactors = F, sep=",")
MHCPres=as.character(MHCPres[ ,1])
MHCPres2Rat=unique(SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%MHCPres])

## change the names to Rat-specific 
Exp2RatImm=lapply(Exp2List, function(x) unique(SymHum2Rat$RGD.symbol[SymHum2Rat$HGNC.symbol%in%x]))

## All immune genes
AllImmGenes1=read.csv("../anntotations/ImmPort_Set.csv")
AllImmGenes2=read.csv("../anntotations/innatedb_curated_genes.csv")
AllImmGenes=unique(c(as.character(AllImmGenes1$Symbol), as.character(AllImmGenes2$Gene.Symbol[which(AllImmGenes2$Species==9606)])))
RatAllImm=na.omit(unique(c(SymHum2Rat$RGD.symbol[match(AllImmGenes, SymHum2Rat$HGNC.symbol)], as.character(AllImmGenes2$Gene.Symbol[which(AllImmGenes2$Species!=9606)]))))

## CIBERSORT specific rat genes
#lm22rat=read.delim("../anntotations/LM22_to_rnorvegicus_1.txt", sep="\t")
```

#### Human gene homologs

Below, lists of common mutations in cancer are loaded and the "homolog" in rat is determined using an in-house script. The steps involved are:

* determine the amino acid context in human (find 5 a.a. prior and after)
* find the region with most amino acid homology in rat (2 or less differences)
* check whether the amino acid of interest is present in rat

An example of the output is shown

```{r mut-hum2rat}
######################
## Annotation for Mutation Locations
######################
BaileyList=read.csv("../anntotations/list_mutations_bailey.csv", stringsAsFactors = F)
BList=FindRatAAHomolog(BaileyList$Gene, substr(BaileyList$Mutation, 3, 3),  substr(BaileyList$Mutation, 4, nchar(as.character(BaileyList$Mutation))-1), substr(BaileyList$Mutation, nchar(as.character(BaileyList$Mutation)), nchar(as.character(BaileyList$Mutation))))

ChangList=read.delim("../anntotations/hotspots_chang_et_al_2017_cancer_discovery.txt", sep="\t", stringsAsFactors = F)
ChangList=ChangList[which(ChangList$Type=="single residue"), ]
ChangList$AA1=substr(ChangList$Residue, 1, 1)
ChangList$Loc=substr(ChangList$Residue,2, nchar(ChangList$Residue))
AA2list=sapply(ChangList$Variants, function(x) strsplit(x, ":[0-9]+[\\|]*"))
AAun=unlist(AA2list)
C2List=tibble(ChangList[ ,c("Gene", "AA1", "Loc")])
C2List=C2List %>% slice(rep(1:n(), times=sapply(AA2list, length)))
C2List$AA2=AAun
C2List=C2List[-which(C2List$AA2=="sp"| C2List$AA1=="*"), ]
#C2ListB=C2List[-which(is.na(C2List$Loc)), ]

ChangList2=FindRatAAHomolog(C2List$Gene, C2List$AA1,  C2List$Loc, C2List$AA2)

head(ChangList2)
```

#### GSEA compendiums

For pathway analysis, the c2 (pathway), Hallmark and c5 (Gene Ontology). In addition, metacore pathways (pathway maps and process networks) were obtained and loaded below. This gives a list of 7 different data-sets to interrogate.

Below is example code to load the hallmark and c2 compendiums.

```{r gsea-load}
PathInc2=getGmt(con="../anntotations/c2.cp.v7.0.symbols.gmt", geneIdType=SymbolIdentifier(),
                collectionType=BroadCollection(category="c2"))

c2entrez=mapIdentifiers(PathInc2, EntrezIdentifier('org.Hs.eg.db'))
c2ListHs=geneIds(c2entrez)

PathInH=getGmt(con="../anntotations/h.all.v7.1.symbols.gmt", geneIdType=SymbolIdentifier(),
                collectionType=BroadCollection(category="h"))

cHentrez=mapIdentifiers(PathInH, EntrezIdentifier('org.Hs.eg.db'))
cHListHs=geneIds(cHentrez)

#####################################################
# also load in the process networks and pathway maps 
#################

load("../anntotations/ListofGeneSets2.RData")
```

<!--chapter:end:index.Rmd-->

# Cohort characteristics

Below we assess summary statistics on clinico-pathological features of this data set. This includes information on:

* treatment
* tumor size
* growth rates (mm/week)
* number of tumors per rat 

```{r}
Cdata=xlsx::read.xlsx("../metadata/Extended Data Table1.xlsx", sheetIndex=1)

Cdata$NewID[which(duplicated(Cdata$NewID)==T)]

DT::datatable(Cdata[ ,1:20],rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```

## Size information

We have two cohorts, the characterisation and progression cohorts. Below is a plot of the size distribution in these two cohorts:

```{r}
par(mfrow=c(1,2))
X1a=median(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Characterisation")], na.rm = T)
hist(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort!="Characterisation")], breaks=15,
     main=sprintf("characterisation sizes Median %s", X1a), 
     xlab="size at sac")

X2a=median(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Progression")], na.rm=T)
hist(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Progression")], breaks=15,
     main=sprintf("progression sizes Median %s", X2a),
     xlab="size at sac")
```

Note that in the characterisation cohort, samples are selected for SAC at different time points:

```{r Ext1c, fig.cap="growth of tumors over time"}

#pdf("~/Desktop/S1B_size_oveR_time.pdf", width=6, height=5)

am1=lm(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Characterisation")]~
         Cdata$Time.NMU2Sac[which(Cdata$Cohort=="Characterisation")])

plot(jitter(Cdata$Time.NMU2Sac[which(Cdata$Cohort=="Characterisation")]),
     jitter(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Characterisation")]),
     xlab="Time from NMU to sac (days)", ylab="Tumor diameter (mm)", 
     col=factor(Cdata$Char.Cohort.Batch[which(Cdata$Cohort=="Characterisation")]), pch=19, main="characterisation: size over time")
text(jitter(Cdata$Time.NMU2Sac[which(Cdata$Cohort=="Characterisation")])+5,
     jitter(Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Characterisation")])+1,
     Cdata$NewID[which(Cdata$Cohort=="Characterisation")], cex=0.7)
abline(am1)
legend("topright", levels(factor(Cdata$Char.Cohort.Batch)), col=c(1:4), lwd=2)
#dev.off()

DT::datatable(cbind(Cdata$Time.NMU2Sac[which(Cdata$Cohort=="Characterisation")], 
                Cdata$Tumor.diameter.sac.mm[which(Cdata$Cohort=="Characterisation")],
                Cdata$Char.Cohort.Batch[which(Cdata$Cohort=="Characterisation")]), rownames=F, class='cell-border stripe', extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'))) 
```

Plot of number of tumors per rat

```{r Ext1b, fig.cap="Number of tumors per rat in each cohort"}
Nx1=table(Cdata$Rat_ID[which(Cdata$Cohort=="Characterisation")])
X2=Cdata$Char.Cohort.Batch[match(names(Nx1), Cdata$Rat_ID)]
t2temp=data.frame(count=as.numeric(Nx1), cohort=X2)
beeswarm(jitter(as.vector(Nx1))~X2, col=c(1:4), pch=19)
DT::datatable(t2temp, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```

## Calculating growth rates

In this section, we estimate the growth rates of the samples: Below is a plot of the tumor size per week for each recorded tumor, color-coded according to treatment. Time is measured at the first time point at which a tumor is palpated. Spontaneous large tumors are assumed to have a tumor size of 0 or 1 one week prior to palpating.

```{r}
GrowthRaw=read.csv("../metadata/growth_rates_0915.csv")
colnames(GrowthRaw)[-1]=substr(colnames(GrowthRaw)[-1], 2, 10)
colnames(GrowthRaw)=gsub("\\.", "-", colnames(GrowthRaw))

CTreat=Cdata$Treatment[match(colnames(GrowthRaw), gsub("_", "", Cdata$TumorID))]
CTreat=ColMerge[match(CTreat, rownames(ColMerge)) ,1]
Cgrowth=Cdata$Tumor.growth.status[match(colnames(GrowthRaw), gsub("_", "", Cdata$TumorID))]

#pdf(sprintf("rslt/Clinicopath/summary_growth_plots_%s.pdf", Sys.Date()), width=8, height=8)

par(xpd=T)
plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main="Tumor size over time")

for (i in 2:ncol(GrowthRaw)){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=CTreat[i])
}
legend("bottom", inset = c(-0.2, -0.2), rownames(ColMerge), col=ColMerge[ ,1], lwd=2, horiz = T)

ax1=colnames(GrowthRaw)[-1][which(CTreat[-1]=="Unknown")]
bx1=Cdata$TumorID[!gsub("_", "", Cdata$TumorID)%in%colnames(GrowthRaw)]
bx1=bx1[which(bx1%in%Cdata$TumorID[Cdata$Tumor.growth.status%in%c("stable", "growing")])]
```

We can also separate the above plot into separate treatments:

```{r}
#Plot the above into quadrants based on different treatments:
par(mfrow=c(2,2))
xn=levels(factor(names(CTreat)))
x2=CTreat[xn]
for (j in 1:4){
  indx=which(CTreat==x2[j])
  indx=setdiff(indx, 1)
  plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main=xn[j])
for (i in indx){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=CTreat[i])
  text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], i], colnames(GrowthRaw)[i], cex=0.6)
}
}

#dev.off()

colnames(GrowthRaw)=Cdata$NewID[match(colnames(GrowthRaw), gsub("_", "", Cdata$TumorID))]
TreatType=Cdata$Treatment[match(colnames(GrowthRaw),Cdata$NewID)]

GrowthRaw2=rbind(TreatType, GrowthRaw)
colnames(GrowthRaw2)[1]="Time(weeks)"

DT::datatable(GrowthRaw2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```

Notably, there are a few samples which grow but then regress. These are plotted below

```{r 5xta, fig.cap="inflammatory growth profiles"}
UturnSamp=c("6RB","11ND", "8LD", "10LD", "3NB" )

tmp=Cdata$NewID[match(UturnSamp, gsub("_","", Cdata$TumorID))]
mx=match(tmp, colnames(GrowthRaw))

#pdf("~/Desktop/S5-inflammatory-samples-growth.pdf", height=5, width = 5)

plot(NA, xlim=c(0, 10), ylim=c(0, 30), ylab="Tumor Size (mm)", xlab="Time (weeks)", main="Inflammatory  samples")
for (i in 1:length(mx)){
    x1=which(!is.na(GrowthRaw[, mx[i]]))
 lines(GrowthRaw[x1, 1], GrowthRaw[x1, mx[i]], col=CTreat[mx[i]])
  text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], mx[i]], 
       colnames(GrowthRaw)[mx[i]], cex=0.6)

}

GrowthRaw3=GrowthRaw2[ ,c(1, mx)]

DT::datatable(GrowthRaw3, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(GrowthRaw3, file="nature-tables/Ext5a.csv")
```


These tumors doesn't have growth rate data: `r bx1`.

We can then compute the growth rate for the above samples by considering the change in size over a given period of time using a linear regression model. Below is the histogram of growth rates, and we see a separation at approximately 2mm/week:

```{r 3d, fig.cap="Histogram of growth rates"}
GR=sapply(2:ncol(GrowthRaw), function(x) lm(GrowthRaw[, x]~GrowthRaw[, 1])$coefficients[2])
names(GR)=colnames(GrowthRaw)[-1]

d1=data.frame(growthrate=GR, treatment=names(CTreat[-1]), growth=Cgrowth[-1], color=CTreat[-1],
              sample=names(GR))

d1$treatment=factor(d1$treatment, levels=c( "PDL1+LY", "PDL1", "LY", "Vehicle"))

Nweeks=sapply(2:ncol(GrowthRaw), function(x) max(which(!is.na(GrowthRaw[ , x]))))
names(Nweeks)=names(GR)

d1$Nweeks=Nweeks[match(d1$sample, names(Nweeks))]
d1$Time.Tum2Sac=Cdata$Time.Tumor2Sac[match(d1$sample, Cdata$NewID)]
d1$Time.NMU2Sac=Cdata$Time.NMU2Sac[match(d1$sample, Cdata$NewID)]
d1$tum.size=Cdata$Tumor.diameter.sac.mm[match(d1$sample, Cdata$NewID)]
d1$growthrate_cutoff2=ifelse(d1$growthrate>=2, "growing", "stable")

#pdf(sprintf("rslt/Clinicopath/summary_growth_rates_%s.pdf", Sys.Date()), width=8, height=6)
ggplot(d1, aes(x=growthrate, fill=treatment))+geom_histogram(colour="black")+theme_bw()+geom_vline(aes(xintercept=2), colour="grey45", linetype="dashed")+scale_fill_manual(values=ColMerge[ ,1])

```

Based on the above distribution, a cut-off of 2mm/week may be an optimal cut-off to separate growing and stable tumors. Below are growth rates of tumors under different treatments:

```{r}
pv1=sapply(levels(d1$treatment)[1:3], function(x)
  wilcox.test(d1$growthrate[which(d1$treatment==x)], d1$growthrate[which(d1$treatment=="Vehicle")])$p.value)

d1$treatment=factor(d1$treatment, levels=c("Vehicle", "PDL1", "LY","PDL1+LY"))
```

```{r 3c, fig.cap="Growth rate with respect to treatment"}
ggplot(d1, aes(x=treatment, y=growthrate, col=treatment))+geom_boxplot()+geom_jitter()+
  scale_color_manual(values=ColMerge[ ,1])+theme_bw()+ggtitle(paste(paste(names(pv1), round(pv1, 2)), collapse=";"))

DT::datatable(d1, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(d1, file="nature-tables/Fig3c-d.csv")
```

We can calculate the p.values below, using a wilcox test. The growth rates comparing the treatment to the controls are:

```{r, results='show'}
print('LY samples')
wilcox.test(d1$growthrate[d1$treatment=="LY"], d1$growthrate[d1$treatment=="Vehicle"])
print('PDL1 samples')
wilcox.test(d1$growthrate[d1$treatment=="PDL1"], d1$growthrate[d1$treatment=="Vehicle"])
print('PDL1+LY samples')
wilcox.test(d1$growthrate[d1$treatment=="PDL1+LY"], d1$growthrate[d1$treatment=="Vehicle"])
```

This shows a smaller growth-rate in PDL1 single and double treated cases compared to the vehicles.

Overall the distribution of growing vs stable tumors is shown below:

```{r}
table(ifelse(d1$growthrate>=2, "grow", "stable"))
head(d1)
```


We can replot the previous graphs according to growth, and color code according to whether it is a fast or slow growing tumor

```{r 3b, fig.height=8, fig.cap="Overview of growth rates of immunotherapy treated tumors with fast and slow growing indicated"}
par(xpd=T)

#Plot the above into quadrants based on different treatments:
par(mfrow=c(2,2))
for (j in 1:length(xn)){
  indx=which(names(CTreat)==xn[j])
  indx=setdiff(indx, 1)
  plot(NA, xlim=c(0, 27), ylim=c(0, 50), ylab="Tumor Size (mm)", xlab="Time (weeks)", main=paste("Redone", xn[j]))
for (i in indx){
  x1=which(!is.na(GrowthRaw[, i]))
  lines(GrowthRaw[x1, 1], GrowthRaw[x1, i], col=ifelse(d1$growthrate_cutoff2[i-1]=="growing", ColMerge[j, 1], ifelse(d1$growthrate_cutoff2[i-1]=="stable", ColMerge[j, 2], "black")), type="o", pch=19)
  text(GrowthRaw[x1[length(x1)], 1], GrowthRaw[x1[length(x1)], i], colnames(GrowthRaw)[i], cex=0.6)
}
  
}
```

As a sanity check, compare these growth rates with differences in tumour size at different time points:

* comparing the growth rate according to classifications (growing, stable)
* tumor size at time of sacrifice
* rate of tumor development from the time of NMU injection

For all comparisons, wilcox rank sum test to assess differences was used

```{r, fig.height=4,warning='hide'}
par(mfrow=c(1,3))
boxplot(d1$growthrate~d1$growthrate_cutoff2, main="growth rate, new growth", las=2,  ylab="tumor growth rate (mm/week)", xlab="")
x1=wilcox.test(d1$growthrate~d1$growthrate_cutoff2)$p.value
text(1.5, 20, paste("wilcox p =", round(x1, 3)))

boxplot(d1$tum.size~d1$growthrate_cutoff2, main="tum size at sac, new growth", las=2, ylab="Tumor diameter (mm)", xlab="")
x1=wilcox.test(d1$tum.size~d1$growthrate_cutoff2)$p.value
text(1.5, 40, paste("wilcox p =", round(x1, 3)))

boxplot(d1$tum.size/d1$Time.NMU2Sac~d1$growthrate_cutoff2, main="rate NMU2SAC", las=2, ylab="growth rate from NMU injection (mm/wk)", xlab="")
x1=wilcox.test(d1$tum.size/d1$Time.NMU2Sac~d1$growthrate_cutoff2)$p.value
text(1.5, 0.6, paste("wilcox p =", round(x1, 3)))
```

Is there an association with treatment? Calculate below using chi-squared test: 

```{r 3e, fig.cap="Contingency tables"}
# print('new data outcome')
 a3=chisq.test(table(factor(d1$treatment), d1$growthrate_cutoff2))
a3
 
 ContTable(table((d1$treatment), d1$growthrate_cutoff2), "new rates", T, "growth", "treatment")
```

We can also compare these values by assessing any I/O vs the control, as well as specific treatment arms

```{r}
par(mfrow=c(2,2))
  
ContTable(table((d1$treatment!="Vehicle"), d1$growthrate_cutoff2), "new rates", T, "growth", "treatment")

for (i in levels(d1$treatment)[2:4]){
  ContTable(table(factor(d1$treatment[d1$treatment%in%c("Vehicle", i)]), 
                  d1$growthrate_cutoff2[d1$treatment%in%c("Vehicle", i)]), "new rates", T, "growth", "treatment")
}
 
```

Overall, it appears that there is an association between growth rate and treatment

```{r}
# Replace the Cdata information with new growth information
Cdata$Growth2=d1$growthrate_cutoff2[match(Cdata$NewID, d1$sample)]
Cdata$GrowthRate=d1$growthrate[match(Cdata$NewID, d1$sample)]
```

## FACS data (DN/CD45/EpCAM)

```{r Ext3c, fig.cap="Ext3c: FACS data"}
Ltab1=Cdata[ ,c("Tumor.Growth", "DN.Frac.FACS", "CD45.Frac.FACS", "EpCAM.Frac.FACS", "Treatment")]
Ltab2=melt(Ltab1, measure.vars = c("DN.Frac.FACS", "CD45.Frac.FACS", "EpCAM.Frac.FACS"))
Ltab2=Ltab2[-which(is.na(Ltab2$value)|is.na(Ltab2$Tumor.Growth)), ]
Ltab2$Tumor.Growth=factor(Ltab2$Tumor.Growth)
Ltab2$Treatment=factor(Ltab2$Treatment)
Ltab2$value=as.numeric(Ltab2$value)

ggplot(Ltab2, aes(x=Tumor.Growth, y=value, col=Tumor.Growth))+geom_boxplot()+geom_point()+facet_grid(~variable)+
  scale_color_manual(values=c(ColSizeb, "black"))+theme_bw()
```

Assess any significance below:

```{r}
wilcox.test(as.numeric(Ltab1$CD45.Frac.FACS)~Ltab1$Tumor.Growth)
wilcox.test(as.numeric(Ltab1$DN.Frac.FACS)~Ltab1$Tumor.Growth)
wilcox.test(as.numeric(Ltab1$EpCAM.Frac.FACS)~Ltab1$Tumor.Growth)
```

We can also plot by treatment:

```{r Ext3c-treat}
ggplot(Ltab2, aes(x=Treatment, y=value, col=Treatment))+geom_boxplot()+geom_point()+facet_grid(~variable)+
  scale_color_manual(values=c(ColMerge[ ,1]))+theme_bw()
DT::datatable(Ltab2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(Ltab2, file="nature-tables/Ext3c.csv")
```

## FACS data

The immune (CD45) fractions from a number of samples were collected, and assessed using FACs. The major cell types detected are:

Leukocytes:

* Tregs 
* CD8 T cells
* Thelper cells
* B cells
* NK T cells
* gamma delta T cells 

Myeloid cells:

* Macrophages M1
* Macrophages M2
* Dendritic cells
* Monocytes
* Neutrophils

We can look at the:

* types of cells
* distributions

Note that in a number of samples the leukocyte population could not be inferred with confidence, and proportions are normalised to the myeloid population

```{r}
Fdata=read.csv("../data/carlos_facs_tumors.csv", stringsAsFactors = F)
Fdata[ ,2:ncol(Fdata)]=Fdata[ ,2:ncol(Fdata)]/100
m1=substr(colnames(Fdata), 2, 5)
colnames(Fdata)=m1
colnames(Fdata)[1]="type"

scroll_box(kable(Fdata, format="html"),
         height="300px", width="100%")

t2=Fdata[-which(Fdata[ ,1]==""),]
#rownames(t2)=Fdata[-which(Fdata[ ,1]=="") ,1]
t2=t2[-c(1:2, 14), ]
t2melt=melt(t2)

ggplot(t2melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('all samples')+theme(axis.text.x = element_text(angle = 90))

```

We can look solely at the myeloid population (and normalise to this total), and color according to growth

```{r}
t3=t2[7:11, ]
t3[, 2:ncol(t3)]=t(t(t3[, 2:ncol(t3)])/colSums(t3[, 2:ncol(t3)]))
t3melt=melt(t3)

t3melt$growth=d1$growthrate_cutoff2[match(t3melt$variable, d1$sample)]

ggplot(t3melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('myeloid specific')+theme(axis.text.x = element_text(angle = 90))
```

Similarly, we can look at the leukocyte population. Note that the Treg population in some of these samples is very high.

```{r}
t3=t2[1:6, ]
t3[, 2:ncol(t3)]=t(t(t3[, 2:ncol(t3)])/colSums(t3[, 2:ncol(t3)]))
t3melt=melt(t3)

t3melt$growth=d1$growthrate_cutoff2[match(t3melt$variable, d1$sample)]

ggplot(t3melt, aes(x=variable, y=value, fill=type))+geom_bar(stat="identity")+xlab("sample")+ylab("proportion")+ggtitle('leukocyte specific')+theme(axis.text.x = element_text(angle = 90))
```

<!--chapter:end:01a-cohort-summary.Rmd-->

# Cohort Summary Table

## Total number of samples

Firstly, look at the total number of samples:

```{r}
#recur variables here
avtum=table(Cdata$Rat_ID)
Cchar=Cdata[Cdata$Cohort!="Progression", ]
Cprog=Cdata[Cdata$Cohort=="Progression", ]
```

Feature | Levels | N
--------|---------|-----
Total No Tumors |All | `r nrow(Cdata)`
- | Characterisation| `r length(which(Cdata$Cohort=="Characterisation"))`
- | Progression | `r length(which(Cdata$Cohort=="Progression"))`
Total No Rats | All| `r length(unique(Cdata$Rat_ID))`
- | Characterisation| `r length(unique(Cdata$Rat_ID[which(Cdata$Cohort=="Characterisation")]))`
- | Progression | `r length(unique(Cdata$Rat_ID[which(Cdata$Cohort=="Progression")]))`
No tumours per rat | | `r round(mean(avtum),2) ` ( `r quantile(avtum, c(0.1, 0.9))`)

## Compare the characterisation vs progression cohort

Feature | Levels | Characterisation | Progression
--------|---------|-------- |------
Total No tumours | | `r nrow(Cchar)` | `r nrow(Cprog)`
Treatments| Vehicle | `r length(which(Cdata$Treatment=="Vehicle"))`| `r length(which(Cprog$Treatment=="Vehicle"))`
-| LY | | `r length(which(Cprog$Treatment=="LY"))`
-| PDL1| | `r length(which(Cprog$Treatment=="PDL1"))`
-| PDL1+LY| | `r length(which(Cprog$Treatment=="PDL1+LY"))`
- | NA | `r length(which(is.na(Cchar$Treatment)))` |`r length(which(is.na(Cprog$Treatment)))`
Histology |  diff. adenocarcinomas | `r length(which(Cchar$Tumor.Histology=="well differentiated mammary solid adenocarcinoma"))`|`r length(which(Cprog$Tumor.Histology=="well differentiated mammary solid adenocarcinoma"))`
- | mucinous carcinoma | `r length(which(Cchar$Tumor.Histology=="mucinous carcinoma"))`|`r length(which(Cprog$Tumor.Histology=="mucinous carcinoma"))`
- | Fibroadenoma | `r length(which(Cchar$Tumor.Histology=="fibroadenoma"))`|`r length(which(Cprog$Tumor.Histology=="fibroadenoma"))`
- | NA |`r length(which(is.na(Cchar$Tumor.Histology)))` | `r length(which(is.na(Cprog$Tumor.Histology)))`
Age Injection | 32-36 | `r length(which(Cchar$Age.at.injection=="32-36")) `|`r length(which(Cprog$Age.at.injection=="32-36")) `
 - | 35 | `r length(which(Cchar$Age.at.injection=="35")) ` | `r length(which(Cprog$Age.at.injection=="35")) `
  - | 49 | `r length(which(Cchar$Age.at.injection=="49")) `|`r length(which(Cprog$Age.at.injection=="49")) `
 - | NA | `r length(which(is.na(Cchar$Age.at.injection))) `|`r length(which(is.na(Cprog$Age.at.injection))) `
Time (days) | NMU 2 Sac| `r round(mean(Cchar$Time.NMU2Sac, na.rm=T),2) ` (`r quantile(Cchar$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`) | `r round(mean(Cprog$Time.NMU2Sac, na.rm=T), 2) ` (`r quantile(Cprog$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.NMU2Sac)))` | `r length(which(is.na(Cprog$Time.NMU2Sac)))` 
 - | NMU 2 Tumor | | `r round(mean(Cprog$Time.NMU2Tumor, na.rm=T), 2)` (`r  quantile(Cprog$Time.NMU2Tumor, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.NMU2Tumor)))` | `r length(which(is.na(Cprog$Time.NMU2Tumor)))` 
 - | Tum Spec Surv|  | `r round(mean(Cprog$Time.Tumor2Sac, na.rm=T),2)` (`r quantile(Cprog$Time.Tumor2Sac, c(0.1, 0.9), na.rm=T)`)
 - | Cases with NA| `r length(which(is.na(Cchar$Time.Tumor2Sac)))` | `r length(which(is.na(Cprog$Time.Tumor2Sac)))`
Growth Rate/Size (mm) | overall size @ sac | `r round(mean(Cchar$Tumor.diameter.sac.mm,na.rm=T), 2)`  (`r quantile(Cchar$Tumor.diameter.sac.mm, c(0.1,  0.9), na.rm=T)`) | `r round(mean(Cprog$Tumor.diameter.sac.mm,na.rm=T), 2)` (`r quantile(Cprog$Tumor.diameter.sac.mm, c(0.1, 0.9), na.rm=T)`)
- | Growing No. | | `r length(grep("growing", Cprog$Tumor.Growth))`
- | Growing size @ sac |  |  `r round(mean(Cprog$Tumor.diameter.sac.mm[grep("growing", Cprog$Tumor.Growth)]),2)` `r quantile(Cprog$Tumor.diameter.sac.mm[grep("growing", Cprog$Tumor.Growth)], c(0.1, 0.5, 0.9), na.rm=T)`
- | Stable ||`r length(grep("stable", Cprog$Tumor.Growth))`
- | Stable size @ sac | | `r round(mean(Cprog$Tumor.diameter.sac.mm[grep("stable", Cprog$Tumor.Growth)]),2)` (`r quantile(Cprog$Tumor.diameter.sac.mm[grep("stable", Cprog$Tumor.Growth)], c(0.1, 0.5, 0.9), na.rm=T)`)
- | NA |`r length(which(is.na(Cchar$Tumor.Growth)))` | `r length(which(is.na(Cprog$Tumor.Growth)))`
Spatial Pattern| | |
- | Infiltrating| `r length(which(Cchar$Pathologist.CD8.Spatial=="Infiltrating"))` |  `r length(which(Cprog$Pathologist.CD8.Spatial=="Infiltrating"))`
- | Restricted |  `r length(which(Cchar$Pathologist.CD8.Spatial=="restricted"))` |  `r length(which(Cprog$Pathologist.CD8.Spatial=="restricted"))`
- | NA| `r length(which(is.na(Cchar$Pathologist.CD8.Spatial)))` |  `r length(which(is.na(Cprog$Pathologist.CD8.Spatial)))`
RNA samples | any fraction | `r length(which(!is.na(Cchar$AnyRdata)))`| `r length(which(!is.na(Cprog$AnyRdata)))`
- | Ep|`r length(which(!is.na(Cchar$FqFile.Ep)))`|`r length(which(!is.na(Cprog$FqFile.Ep)))`
- | DN|`r length(which(!is.na(Cchar$FqFile.DN)))`|`r length(which(!is.na(Cprog$FqFile.DN)))`
- | CD45| `r length(which(!is.na(Cchar$FqFile.CD45)))`| `r length(which(!is.na(Cprog$FqFile.CD45)))`
Imaging Data | No tumors | | `r length(which(!is.na(Cprog$WSI.Image.me)))`
- | No tumors with RNA | |`r length(which(!is.na(Cprog$WSI.Image.me)& !is.na(Cprog$AnyRdataD)))`
Trichrome Data | No tumors | |`r length(which(!is.na(Cprog$Trichrome)))`
- | No tumors with RNA | |`r length(which(!is.na(Cprog$Trichrome)& !is.na(Cprog$AnyRdataD)))`
FACS data | Comprehensive|  | `r length(which(colnames(Fdata)%in%gsub("_", "", Cprog$TumorID)))`
- | EpCAM/CD45 | `r length(which(!is.na(Cchar$CD45.Frac.FACS)))` |  `r length(which(!is.na(Cprog$CD45.Frac.FACS)))` 

## Summary of the RNA data

Below is a table of the samples with RNA information

```{r}
CRchar=Cchar[which(Cchar$AnyRdata=="yes"), ]
CRprog=Cprog[which(Cprog$AnyRdata=="yes"), ]
```

Feature | Levels | Characterisation | Progression
--------|---------|-------- |------
RNA samples | any fraction | `r length(which(!is.na(CRchar$RNA.seqSampleID)))`| `r length(which(!is.na(CRprog$RNA.seqSampleID)))`
- | Ep|`r length(which(!is.na(CRchar$FqFile.Ep)))`|`r length(which(!is.na(CRprog$FqFile.Ep)))`
- | DN|`r length(which(!is.na(CRchar$FqFile.DN)))`|`r length(which(!is.na(CRprog$FqFile.DN)))`
- | CD45| `r length(which(!is.na(CRchar$FqFile.CD45)))`| `r length(which(!is.na(CRprog$FqFile.CD45)))`
Treatments Char/Prev  | Vehicle | `r length(which(CRchar$Treatment=="Vehicle"))`| `r length(which(CRprog$Treatment=="Vehicle"))`
- | Untreat (char) | `r length(which(CRchar$Treatment=="Untreated"))` |
-| LY | | `r length(which(CRprog$Treatment=="LY"))`
-| PDL1| | `r length(which(CRprog$Treatment=="PDL1"))`
-| PDL1+LY| | `r length(which(CRprog$Treatment=="PDL1+LY"))`
- | NA | `r length(which(is.na(CRchar$Treatment) ))` |`r length(which(is.na(CRprog$Treatment)))`
Time | NMU 2 Sac| `r round(mean(CRchar$Time.NMU2Sac, na.rm=T),2) ` (`r quantile(CRchar$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`) | `r round(mean(CRprog$Time.NMU2Sac, na.rm=T), 2) ` (`r quantile(CRprog$Time.NMU2Sac, c(0.1, 0.9), na.rm=T)`)
Growth Rate/Size (mm) | overall size @ sac | `r round(mean(CRchar$Tumor.diameter.sac.mm,na.rm=T), 2)`  (`r quantile(CRchar$Tumor.diameter.sac.mm, c(0.1,  0.9), na.rm=T)`) | `r round(mean(CRprog$Tumor.diameter.sac.mm,na.rm=T), 2)` (`r quantile(CRprog$Tumor.diameter.sac.mm, c(0.1, 0.9), na.rm=T)`)
- | Growing No. | | `r length(grep("growing", CRprog$Tumor.Growth))`
- | Growing size @ sac |  |  `r round(mean(CRprog$Tumor.diameter.sac.mm[grep("growing", CRprog$Tumor.Growth)]),2)` `r quantile(CRprog$Tumor.diameter.sac.mm[grep("growing", CRprog$Tumor.Growth)], c(0.1, 0.5, 0.9), na.rm=T)`
- | Stable ||`r length(grep("stable", CRprog$Tumor.Growth))`
- | Stable size @ sac | | `r round(mean(CRprog$Tumor.diameter.sac.mm[grep("stable", CRprog$Tumor.Growth)]),2)` (`r quantile(CRprog$Tumor.diameter.sac.mm[grep("stable", CRprog$Tumor.Growth)], c(0.1, 0.5, 0.9), na.rm=T)`)
- | NA |`r length(which(is.na(CRchar$Tumor.Growth)))` | `r length(which(is.na(CRprog$Tumor.Growth)))`
Growth and Treatment: comparing small/stable vs large/growing | | 
Vehicle | N s/l |  | `r length(which(CRprog$Treatment=="Vehicle" & CRprog$Tumor.Growth=="stable"))`, `r length(which(CRprog$Treatment=="Vehicle" & CRprog$Tumor.Growth=="growing"))`
LY | N s/l |  | `r length(which(CRprog$Treatment=="LY" & CRprog$Tumor.Growth=="stable"))`, `r length(which(CRprog$Treatment=="LY" & CRprog$Tumor.Growth=="growing"))`
PDL1 and Treatment | N s/l |  | `r length(which(CRprog$Treatment=="PDL1" & CRprog$Tumor.Growth=="stable"))`, `r length(which(CRprog$Treatment=="PDL1" & CRprog$Tumor.Growth=="growing"))`
PDL1+LY | N s/l |  | `r length(which(CRprog$Treatment=="PDL1+LY" & CRprog$Tumor.Growth=="stable"))`, `r length(which(CRprog$Treatment=="PDL1+LY" & CRprog$Tumor.Growth=="growing"))`



<!--chapter:end:01b-cohortSummary.Rmd-->


# Whole-slide imaging

In this section, we will be looking at the composition and spatial distribution of cells in whole slide images. These sections have previously been assessed using an external script: SpatialStatisticsWSI.R 

The following markers have been used:

* EpCAM (tumor cells)
* SMA (fibroblasts or myeopithelial cells)
* CD8 (T cells)

Note that in some images a double positive EpCAM+/SMA+ population exists. Some CD8 cells have Epcam+ or SMA+ staining, however, we consider all of these to be simply CD8+


```{r load-wsi, cache=T}
WSIpath="../data/WSI-data/locationData/"
WSIfiles=dir(WSIpath, "*.csv")
WSIsummary=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIsummary)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

## knn data
WSIpath="../data/WSI-data/knn-values/"
WSIfiles=dir(WSIpath, "*.csv")
WSIknn=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIknn)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

## knn data
WSIpath="../data/WSI-data/interactingFraction/"
WSIfiles=dir(WSIpath, "*.csv")
WSIIF=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
WSIIF=lapply(WSIIF, function(x) {colnames(x)<-c("RN","Grid", "NearestNeighbor", "IF", "Reference"); x})
names(WSIIF)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

# MH data
WSIpath="../data/WSI-data/mh-values/"
WSIfiles=dir(WSIpath, "*.csv")
WSIMH=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIMH)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

# MH set-up summary
WSIpath="../data/WSI-data/MHset-upSummary/"
WSIfiles=dir(WSIpath, "*.csv")
WSIMHsetup=lapply(WSIfiles, function(x) read.csv(paste(WSIpath, x, sep="")))
names(WSIMHsetup)=sapply(strsplit(WSIfiles, "_"), function(x) x[1])

save(WSIsummary, WSIknn, WSIIF, WSIMH, WSIMHsetup, file=sprintf("outputs/WSI_raw_data%s.RData", Sys.Date()))
```

## Associate the frequencies with other data types


<span style="color:red">
UPDATE THE CIBERSORT INFORMATION. </span>

Note there are 47 samples with imaging data. 33 of these samples have FACS data, manual counts and TIMER scores

Correlate the following information:

 * "CD8.WSI": CD8 total counts 
 * "CD8Frac.WSI": CD8 fraction (normalised by cell count)
 * "CD8_EPorSMARatio.WSI": CD8/EP+SMA ratio (any EpCAM or SMA + cell)
 * "CD8_AnySMARatio.WSI": CD8/Any EPcam+ cell
 * "CD8_EPRatio.WSI": CD8 to EpCAM+SMA- ratio
 * "CD8normTumSize": normalised CD8 counts per mm of tumor size at sac
 * "CD8.EpBoundingBox": approx area per CD8 cell (density)

<span style="color:red">
UPDATE THE CIBERSORT INFORMATION. </span>

Below are heatmaps which show the correlation between two variables (red is correlated and blue is anti-correlated), and the p.value is indicated in the middle of the square.

It appears that CD8 whole-slide imaging associates well with:

* FACS data (both CD8 and CD45)
* Manual scoring (Fig 4) of CD8 cells
* Some CD8 gene signature scores (mainly in EPC, TIMER)

```{r assoc-facs}
SummaryData=read.csv("../metadata/summary_final_210330.csv", row.names = 1)

## CD summary
NAidx=sapply(1:ncol(SummaryData), function(x) length(which(!is.na(SummaryData[, x]))))
names(NAidx)=colnames(SummaryData)

colTestCD8=c("CD8.EpBoundingBox", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", "T.cell.CD8._TIMER", "T.cell.CD8._CIBERSORT","T.cell.CD8._CIBERSORT.ABS", "T.cell.CD8._EPIC")

# colTestCD8=c("CD8.EpDomTiles","CD8.EpBoundingBox", "CD8.TumSize", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", )
indx1=c("CD8.WSI", "CD8Frac.WSI", "CD8_EPorSMARatio.WSI","CD8_AnySMARatio.WSI", "CD8_EPRatio.WSI","CD8normTumSize", "CD8.EpBoundingBox") #, "log2CD8_EPorSMARatio.WSI", "log2CD8_EPRatio.WSI")

CDsummary=matrix(NA, nrow=length(indx1), ncol=length(colTestCD8))
rownames(CDsummary)=paste(indx1, " N=", NAidx[match(indx1, names(NAidx))], sep="")
colnames(CDsummary)=paste(colTestCD8, " N=", NAidx[match(colTestCD8, names(NAidx))], sep="")
CDsummaryP=CDsummary
for (i in 1:length(indx1)){
  CDsummary[i, ]=sapply(colTestCD8, function(x) cor(SummaryData[, indx1[i]], SummaryData[,x], use="complete"))
  CDsummaryP[i, ]=sapply(colTestCD8, function(x) cor.test(SummaryData[, indx1[i]], SummaryData[,x], use="complete")$p.value)
}

## Do the same with EPCAM/FACS data

colTestFACS=grep("FACS", colnames(SummaryData), value = T)
colTestWSI=grep("WSI", colnames(SummaryData), value = T)
FACSsummary=matrix(NA, nrow=length(colTestFACS), ncol=length(colTestWSI))
rownames(FACSsummary)=paste(colTestFACS, " N=", NAidx[match(colTestFACS, names(NAidx))], sep="")
colnames(FACSsummary)=paste(colTestWSI, " N=", NAidx[match(colTestWSI, names(NAidx))], sep="")
FACSsummaryP=FACSsummary


for (i in 1:length(colTestFACS)){
  FACSsummary[i, ]=sapply(colTestWSI, function(x) cor(SummaryData[, colTestFACS[i]], SummaryData[,x], use="complete"))
  FACSsummaryP[i, ]=sapply(colTestWSI, function(x) cor.test(SummaryData[, colTestFACS[i]], SummaryData[,x], use="complete")$p.value)
}
```

```{r Ext4b, fig.cap="association with facs"}
PvalHM(CDsummary, round(CDsummaryP,2), "CD8 WSI correlation with Pvalues")
```

```{r}
PvalHM(FACSsummary, round(FACSsummaryP, 2), "WSI vs FACS w Pvalues")
```

## Cellular composition

```{r cellular-composition, cache=T}
WSIvals=sapply(WSIsummary, function(x) table(factor(x$Class2, levels=c("CD8", "EpCAM", "EpCAM: SMA", "SMA", "Unclass"))))
WSIvalFracs=t(t(WSIvals)/colSums(WSIvals))

lxmatch=match(colnames(WSIvalFracs), gsub("_", "", Cdata$TumorID))

Cdata$CD8Fraction=NA
Cdata$CD8Fraction[na.omit(lxmatch)]=WSIvalFracs[1, ]

Cdata$EpCAMFraction=NA
Cdata$EpCAMFraction[na.omit(lxmatch)]=WSIvalFracs[2, ]

Cdata$DPFraction=NA
Cdata$DPFraction[na.omit(lxmatch)]=WSIvalFracs[3, ]

Cdata$SMAFraction=NA
Cdata$SMAFraction[na.omit(lxmatch)]=WSIvalFracs[4, ]

Cdata$UnclassFraction=NA
Cdata$UnclassFraction[na.omit(lxmatch)]=WSIvalFracs[5, ]

#write.csv(WSIvals, file="nature-tables/raw_WSI_values.csv")
#write.csv(WSIvalFracs, file="nature-tables/raw_WSI_values_fractions.csv")

df.Spatial=cbind(t(WSIvals), t(WSIvalFracs))
colnames(df.Spatial)=c("CD8", "EpCAM", "EpCAM:SMA", "SMA", "Unclass", paste(c("CD8", "EpCAM", "EpCAM:SMA", "SMA", "Unclass"), "frac", sep=""))

DT::datatable(df.Spatial, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Here, we look at the raw distributions of the different cell types and see if there are associations with:

* tumor size
* growth rate
* growth rate (categorical)
* treatment
* stromal restricted or infiltrating 

Below are the total cell counts:

```{r, fig.height=4}
WSIvals=WSIvals[ , order(WSIvals[1, ])]
ordV=colnames(WSIvals)

WSIvalFracs=WSIvalFracs[ , order(WSIvalFracs[1, ])]
ordV2=colnames(WSIvalFracs)


## match with meta data# get the sample Names
CdataTID=gsub("_", "", Cdata$TumorID)
l1=match(colnames(WSIvals), CdataTID)
namesA=Cdata$NewID[l1]
###
Treat=Cdata$Treatment[l1]
Growth=Cdata$Growth2[l1]
WSImelt=melt(WSIvals)
#WSImelt$Var2=factor(WSImelt$Var2, levels=ordV)
WSImelt$treatment=Treat[match(WSImelt$Var2, colnames(WSIvals))]
WSImelt$growth=Growth[match(WSImelt$Var2, colnames(WSIvals))]
WSImelt$Name=namesA[match(WSImelt$Var2, colnames(WSIvals))]
WSImelt$Name=factor(WSImelt$Name, levels=namesA)

l2=match(colnames(WSIvalFracs), CdataTID)
namesA=Cdata$NewID[l2]
Treat=factor(Cdata$Treatment[l2])
Growth=Cdata$Growth2[l2]
WSIfracMelt=melt(WSIvalFracs)
#WSIfracMelt$Var2=factor(WSIfracMelt$Var2, levels=ordV2)
WSIfracMelt$treatment=Treat[match(WSIfracMelt$Var2, colnames(WSIvalFracs))]
WSIfracMelt$growth=Growth[match(WSIfracMelt$Var2, colnames(WSIvalFracs))]
WSIfracMelt$Name=namesA[match(WSIfracMelt$Var2, colnames(WSIvalFracs))]
WSIfracMelt$Name=factor(WSIfracMelt$Name, levels = namesA)


#pdf(sprintf("rslt/WSI-analysis/summary_distributions_norm_cell_count_%s.pdf", Sys.Date()), width=9, height=5)
ggplot(WSImelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")
ggplot(WSImelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by treatment")
ggplot(WSImelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by growth")
```

Here, the same data is shown and normalised according to total cell count:

```{r WSI-normalised-all-samples, fig.height=5, fig.cap="WSI-normalised-all-samples"}
pdf("figure-outputs/Fig4_WSI-normalised-all-samples.pdf", width=8, height=5)
ggplot(WSIfracMelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")
dev.off()
```

```{r Ext4c, fig.cap="association with treatment"}
pdf("figure-outputs/Fig4_WSI-normalised-all-samples-treatment.pdf", width=8, height=5)
ggplot(WSIfracMelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by treatment")
dev.off()
```

```{r Ext4c_pt2, fig.cap="association with growth"}
pdf("figure-outputs/Fig4_WSI-normalised-all-samples-growth2.pdf", width=8, height=5)
ggplot(WSIfracMelt, aes(x=Name, y=value, fill=Var1))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free_x")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by growth")
dev.off()

DT::datatable(WSIfracMelt, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(WSIfracMelt, file="nature-tables/Ext4c-d.csv")
```

## Associate composition with other covariates

Make Boxplots of the above data, and index samples according to growth or with treatment

```{r 4b, fig.cap="association of frequency with treatment and growth"}
#pdf("~/Desktop/Fig4B-summary-WSI-growth-treatment.pdf", height=7, width=7)

nx1=levels(WSIfracMelt$Var1)

nOut=sapply(nx1, function(x) wilcox.test(WSIfracMelt$value[WSIfracMelt$growth=="growing" & WSIfracMelt$Var1==x],WSIfracMelt$value[WSIfracMelt$growth=="stable" & WSIfracMelt$Var1==x])$p.value)

ggplot(WSIfracMelt[-which(is.na(WSIfracMelt$growth)), ], aes(x=Var1, y=value, col=factor(growth)))+geom_boxplot()+geom_point(position=position_jitterdodge(),alpha=0.3)+
  scale_color_manual(values=c(ColSize, "black"))+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")+theme_bw()+ggtitle(paste(names(nOut), round(nOut,2), collapse=" ;"))
```

```{r 4b2, fig.cap="association with treatment"}
nOutA=sapply(nx1, function(x) wilcox.test(WSIfracMelt$value[WSIfracMelt$treatment=="Vehicle" & WSIfracMelt$Var1==x],WSIfracMelt$value[WSIfracMelt$treatment=="LY" & WSIfracMelt$Var1==x])$p.value)

nOutB=sapply(nx1, function(x) wilcox.test(WSIfracMelt$value[WSIfracMelt$treatment=="Vehicle" & WSIfracMelt$Var1==x],WSIfracMelt$value[WSIfracMelt$treatment=="PDL1" & WSIfracMelt$Var1==x])$p.value)

nOutC=sapply(nx1, function(x) wilcox.test(WSIfracMelt$value[WSIfracMelt$treatment=="Vehicle" & WSIfracMelt$Var1==x],WSIfracMelt$value[WSIfracMelt$treatment=="PDL1+LY" & WSIfracMelt$Var1==x])$p.value)


ggplot(WSIfracMelt, aes(x=Var1, y=value, col=(treatment)))+geom_boxplot()+geom_point(position=position_jitterdodge(),alpha=0.3)+
  scale_color_manual(values=ColMerge[ ,1])+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("ordered by CD8")+theme_bw()+
  ggtitle(paste(paste(names(nOutA), round(nOutA,2), collapse=" ;"),paste(names(nOutB), round(nOutB,2), collapse=" ;"),paste(names(nOutC), round(nOutC,2), collapse=" ;") ) )

#dev.off()
DT::datatable(WSIfracMelt[-which(is.na(WSIfracMelt$growth)), ], rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(WSIfracMelt[-which(is.na(WSIfracMelt$growth)), ], file="nature-tables/4b.csv")
```

P values when comparing to the vehicle for each comparison:

Treatment | values
----------|---------
LY | `r nOutA`
PDL1 | `r nOutB`
PDL1+LY | `r nOutC`

## Estimate tumor size

Using WSI data, we can estimate a tumor size for each tissue sample and compare to the final tumor sizes. This will be based on the distribution of EpCAM+ cells.
This estimate is can be used to normalise CD8 counts.

```{r}
#estimate the tumor areas
Tarea=lapply(WSIsummary, function(x) ripras(x$Centroid.X.µm[x$Class2=="EpCAM"], x$Centroid.Y.µm[x$Class2=="EpCAM"], "convex"))
TareaSum=sapply(Tarea, area)

# Tumor diameter
Tdiameter=Cdata$Tumor.diameter.sac.mm[match(colnames(WSIvals), gsub("_", "", Cdata$TumorID))]

plot(TareaSum, Tdiameter, ylab="Tumor Diameter", xlab="Epcam cells bounding area")

cor.test(TareaSum, Tdiameter, use="complete")

## append to Cdata
Cdata$TumorAreaWSI=NA
lxmatch=match(colnames(WSIvalFracs), gsub("_", "", Cdata$TumorID)) # probably don't need this
Cdata$TumorAreaWSI[(lxmatch)]=TareaSum #[-which(is.na(lxmatch))]
```

## Correlations between different subpopulations

Look for correlates between different subpopulations: Naturally, we would expect a negative correlation since this should sum to 1. Below are heatmaps showing correlations between different cell types, and significant associations are linearly shown.

Note the following negative correlations:

* epcam and SMA
* SMA+ and Unclass 

```{r}
Ax1=cor(t(WSIvalFracs))

#pdf(sprintf("rslt/WSI-analysis/summary-associations-between-subgroups_%s.pdf", Sys.Date()), height=8, width=8)
par(oma=c(4, 0,0, 4))
heatmap.2(Ax1, col=brewer.pal(9, "RdBu"), trace="none",scale="none")

par(mfrow=c(2,2))

a1=cor.test(WSIvalFracs[2, ], WSIvalFracs[4, ])
plot(WSIvalFracs[2, ], WSIvalFracs[4, ], xlab="Epcam+", ylab="SMA+", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[4, ], WSIvalFracs[5, ])
plot(WSIvalFracs[4, ], WSIvalFracs[5, ], xlab="SMA+", ylab="Unclass", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[3, ], WSIvalFracs[4, ])
plot(WSIvalFracs[3, ], WSIvalFracs[4, ], xlab="Epcam+SMA+", ylab="SMA", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

a1=cor.test(WSIvalFracs[2, ], WSIvalFracs[5, ])
plot(WSIvalFracs[2, ], WSIvalFracs[5, ], xlab="Epcam+", ylab="nclass", main=sprintf("rho=%s,p=%s", round(a1$estimate, 2), round(a1$p.value, 2)))

#devoff()

# correlations

ctest=matrix(NA, nrow=5, ncol=5)
for (i in 1:5){
  ctest[i, ]=sapply(1:5, function(x) cor.test(WSIvalFracs[i, ], WSIvalFracs[x, ])$p.value)
}
```

All associations determined using a correlation test

## Associations between CD8 counts with other clinical variables

Below we assess whether any of the CD8-variables described in section 3.1 is associated with 

* treatment
* growth
* spatial pattern

```{r}
indx1=c(indx1, "log2CD8_EPorSMARatio.WSI", "log2CD8_EPRatio.WSI")

a1=matrix(NA, ncol=length(indx1), nrow=5)

for (i in 1:length(indx1)){
a1[1, i]=wilcox.test(SummaryData[SummaryData$Growth%in%c("stable", "growing") ,indx1[i] ]~ SummaryData$Growth[SummaryData$Growth%in%c("stable", "growing")])$p.value 
a1[2, i]=wilcox.test(SummaryData[SummaryData$SpatialManual%in%c("Infiltrating", "restricted") ,indx1[i] ]~ SummaryData$SpatialManual[SummaryData$SpatialManual%in%c("Infiltrating", "restricted")])$p.value
a1[3, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("PDL1", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("PDL1", "Vehicle")])$p.value
a1[4, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("PDL1+LY", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("PDL1+LY", "Vehicle")])$p.value
a1[5, i]=wilcox.test(SummaryData[SummaryData$Treatment%in%c("LY", "Vehicle") ,indx1[i] ]~ SummaryData$Treatment[SummaryData$Treatment%in%c("LY", "Vehicle")])$p.value
}

colnames(a1)=indx1
rownames(a1)=c("growth", "spatial", "pdl1", "pdl1+ly", "ly")

par(oma=c(5, 0,0,4))
heatmap.2(-log10(a1), col=brewer.pal(9, "Blues"), trace="none", scale="none")
```

Note that CD8 normalised by tumor size is associated with growth (but this could a reflection of the size of the tumor), and there is a borderline difference once normalised by epithelial content. In addition the CD8 total count is associated with pdl1+ly treatment.

Note that p=0.05 is designated by a value of 1.3


<!--chapter:end:02-wsi.Rmd-->

# Spatial statistics

Below, we use three different metrics to compare spatial distributions:

* k-nearest neighbour distances
* the interacting fraction
* morisita-horn distances

These are compared to manual inspection of the result

## knn-Distances:

The k-nearest neighbour distances looks at the average distance from a given cell type of class A to a cell type of class B. In this section, the reference class A is the CD8 T cell, and we will look at the mean distance to SMA, Epcam, double positive and unclassified cells in each image.

To account for potential fluctuations due to misclassified cells, or isolated single cells, k values of 1, 3, 5 will be used. I.e. for each cell, we will compute the mean distance from each Cd8Tcell to its 1, 3, and 5 nearest neighbours.

### Comparison to manual classification

Overall, we see that the differences in infiltrating vs restricted are similar. We see statistical differences (using anova followed by Tukey's test) between: 

* epcam and SMA-epcam in both cases (higher distances to EpCAM on average)
* SMA-Epcam to SMA (CD8s are closer to SMA+)
* Unclass to Epcam-SMA (CD8s closer to unclass)

In the infiltrating case: 

* Unclass to Epcam (CD8s closer to unclass, borderline significant)

In the restricted cases, we see:

* Unclass to SMA (higher distance to unclass in the restricted case)
* SMA to epcam (CD8s are closer to the SMA)

This last result is consistent with what we expect for a CD8+ cell which is stroma-restricted.

```{r, fig.height=5}
knnMelt=melt(WSIknn, measure.vars=c("KS.pval"))

knnTemp1=knnMelt[knnMelt$CellType=="CD8" & knnMelt$NearestCellType%in%c("EpCAM", "SMA", "EpCAM: SMA", "Unclass"), ]
knnTemp1$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

# compute p values?
ptest=sapply(levels(knnTemp1$knn), function(x) wilcox.test(knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="EpCAM" & knnTemp1$SpatialManual=="Infiltrating")], knnTemp1$MeanDistance[which(knnTemp1$knn==x & knnTemp1$NearestCellType=="SMA" & knnTemp1$SpatialManual=="Infiltrating")])$p.value)

fit1=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
fit2=aov(MeanDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])


fit1b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="Infiltrating", ])
fit2b=aov(MedianDistance~NearestCellType+knn, data=knnTemp1[knnTemp1$SpatialManual=="restricted", ])

#pdf(sprintf("rslt/WSI-analysis/knn_distances_vs_manualspatial_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(knnTemp1, aes(x=NearestCellType, y=MeanDistance, fill=SpatialManual))+geom_boxplot(outlier.shape=NA)+facet_grid(~knn+SpatialManual)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c("#e41a1c", "#377eb8"),na.value="black")+ggtitle("CD8-CelltypeX spatial distributions: mean values")

print(p)
par(mfrow=c(1,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1, "NearestCellType"), las=2)
title("Infiltrating Mean Distance from CD8", line=3.3)
plot(TukeyHSD(fit2, "NearestCellType"), las=2)
title("Restricted Mean Distance from CD8", line=3.3)

```

Note above the infiltrating samples have shorter distances to EpCAM cells relative to SMA cells compared to restricted samples. (Tukey's test shows that SMA-EPCAM distances for inf. are large but small in resis.)

### Associations with outcome to treatment

We can also see if there is an association between these distances with growth and treatment

Treatment:

* CD8 cells in PDL1 sample are further away to SMA+ cells and EpCAM+   (compared to vehicle or double agent)
* CD8 cells in LY treated samples are further away from unclassified cells  (compared to any of the other treatments)

```{r Fig4c, fig.cap="knn Distances"}

#pdf("~/Desktop/4C-knn-summary-treatment.pdf", height=5, width=7)

knnTemp1$Treatment=Cdata$Treatment[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1=aov(MedianDistance~Treatment, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM" & knnTemp1$knn=="knn3", ])
fit2=aov(MedianDistance~Treatment, data=knnTemp1[knnTemp1$NearestCellType=="SMA"& knnTemp1$knn=="knn3", ])
fit3=aov(MedianDistance~Treatment, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA"& knnTemp1$knn=="knn3", ])
fit4=aov(MedianDistance~Treatment, data=knnTemp1[knnTemp1$NearestCellType=="Unclass"& knnTemp1$knn=="knn3", ])

knnTemp1$Growth=Cdata$Tumor.Growth[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]

fit1b=aov(MeanDistance~Growth, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM"& knnTemp1$knn=="knn3", ])
fit2b=aov(MeanDistance~Growth, data=knnTemp1[knnTemp1$NearestCellType=="SMA"& knnTemp1$knn=="knn3", ])
fit3b=aov(MeanDistance~Growth, data=knnTemp1[knnTemp1$NearestCellType=="EpCAM: SMA"& knnTemp1$knn=="knn3", ])
fit4b=aov(MeanDistance~Growth, data=knnTemp1[knnTemp1$NearestCellType=="Unclass"& knnTemp1$knn=="knn3", ])

#pdf(sprintf("rslt/WSI-analysis/knn_distances_vs_treatment_growth_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(knnTemp1, aes(col=Treatment, y=MedianDistance, x=Treatment))+geom_boxplot(outlier.shape=NA)+geom_point(position=position_jitterdodge(),alpha=0.3)+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = ColMerge[ ,1],na.value="black")+theme_bw()
print(p)
```

Below, check whether any of the above are significant using Tukey's ad-hoc test. Note that not many values cross 0 here, except for the LY samples for stromal cells

```{r knn-tukey}
par(mfrow=c(2,2), oma=c(0, 0, 2, 0))
tukey.test <- TukeyHSD(fit1)
plot(TukeyHSD(fit1, "Treatment"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2, "Treatment"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3, "Treatment"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit4, "Treatment"), las=2)
title("Unclass Distance", line=3.3)
#dev.off()

summary(fit1)
summary(fit2)
summary(fit3)
summary(fit4)

knnTemp1b=knnTemp1[which(knnTemp1$knn=="knn3"), ]

# save data to file
knnTemp1$sample=Cdata$NewID[match(knnTemp1$L1, gsub("_", "", Cdata$TumorID))]
DT::datatable(knnTemp1[which(knnTemp1$knn=="knn3"), c(2:5, 10:13)], rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))
#write.csv(knnTemp1[which(knnTemp1$knn=="knn3"), c(2:5, 10:13)], file="nature-tables/Fig4c_Ext4e.csv")
```

We can refine this comaprison to just knn3. We compare to the vehicle using a wilcox.test below:

```{r knnTemp}
knnTemp1b=knnTemp1[which(knnTemp1$knn=="knn3"), ]
ctypes=unique(knnTemp1b$NearestCellType)
t2=knnTemp1b[which(knnTemp1b$CellType=="CD8" & knnTemp1b$knn=="knn3") , ]

pval2=sapply(ctypes, function(x) wilcox.test(t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="Vehicle" ], t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="LY"])$p.value)

pval3=sapply(ctypes, function(x) wilcox.test(t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="Vehicle" ], t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="PDL1"])$p.value)

pval4=sapply(ctypes, function(x) wilcox.test(t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="Vehicle" ], t2$MeanDistance[t2$NearestCellType==x & t2$Treatment=="PDL1+LY"])$p.value)

pmelt=melt(cbind(LY=pval2, PDL1=pval3, 'PDL1+LY'=pval4))
colnames(pmelt)=c("NearestCellType","Treatment","label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8
pmelt$Treatment[which(pmelt$Treatment=="pval4")]="PDL1+LY"

p=ggplot(knnTemp1b[knnTemp1b$CellType=="CD8" , ], aes(x=Treatment, y=MeanDistance, col=Treatment))+facet_grid(~NearestCellType)+geom_boxplot()+ylab("knn3")+xlab("Distance in microns")+ggtitle("knn3 mean distance to cd8 cell ")+theme_bw()+geom_point(position=position_jitterdodge(),alpha=0.3)+scale_color_manual(values=c(ColMerge[ ,1], "black"))+scale_y_continuous(trans='log10')
p+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.8, label=label))

```


### Growth

All 95% confidence lines cross 0, but it appears that stable cases have a closer unclass-CD8 interaction distance compared to growing.

```{r}

p<-ggplot(knnTemp1, aes(col=Growth, y=MeanDistance, x=Growth))+geom_boxplot(outlier.shape=NA)+geom_point(position=position_jitterdodge(),alpha=0.3)+facet_grid(~knn+NearestCellType)+scale_y_continuous(trans='log10')+theme(axis.text.x = element_text(angle = 90, hjust = 1))+scale_color_manual(values = c(ColSizeb, "black"),na.value="black")+theme_bw()
print(p)
par(mfrow=c(2,2), oma=c(0, 0, 2, 0))
plot(TukeyHSD(fit1b, "Growth"), las=2)
title("EpCAM Mean Distance", line=3.3)
plot(TukeyHSD(fit2b, "Growth"), las=2)
title("SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit3b, "Growth"), las=2)
title("EpCAM:SMA Mean Distance", line=3.3)
plot(TukeyHSD(fit4b, "Growth"), las=2)
title("Unclass Distance", line=3.3)

#dev.off()

summary(fit1b)
summary(fit2b)
summary(fit3b)
summary(fit4b)

```

Can also plot the single result for knn=3

```{r}
knnTemp1b=knnTemp1[which(knnTemp1$knn=="knn3"), ]
ctypes=unique(knnTemp1b$NearestCellType)
t2=knnTemp1b[which(knnTemp1b$CellType=="CD8" & knnTemp1b$knn=="knn3") , ]

pval2=sapply(ctypes, function(x) wilcox.test(t2$MeanDistance[t2$NearestCellType==x & t2$Growth=="growing" ], t2$MeanDistance[t2$NearestCellType==x & t2$Growth=="stable" ])$p.value)

ann_text=data.frame(Glabel=round(pval2,2), NearestCellType=(ctypes ), Growth="stable", value=0.7)

p=ggplot(knnTemp1b[knnTemp1b$CellType=="CD8" , ], aes(x=Growth, y=MeanDistance, col=Growth))+facet_grid(~NearestCellType)+geom_boxplot()+ylab("knn3")+xlab("Distance in microns")+ggtitle("kkn3 nearest neighbor distance to cd8 cell")+theme_bw()+geom_point(position=position_jitterdodge(),alpha=0.3)+scale_color_manual(values=c(ColSizeb, "black"))+scale_y_continuous(trans='log10')
p+geom_text(data=ann_text, mapping=aes(x=2, y=0.75, label=Glabel))
```

Is there a plot showing the different knn values? If there is, delete this section

```{r, eval=F}

Combine the Epithelial samples, and SMA/unclassified samples together: Is there a difference here?

knnTemp1b=knnTemp1[which(knnTemp1$knn=="knn1"), ]
knnTemp1b$CD8=WSIvalFracs[1, match(knnTemp1b$L1, colnames(WSIvalFracs))]
knnTemp1b$CD8frac=ifelse(knnTemp1b$CD8>0.1, "high", "low")
knnTemp1b$Ep=WSIvalFracs[2, match(knnTemp1b$L1, colnames(WSIvalFracs))]
knnTemp1b$Epfrac=ifelse(knnTemp1b$CD8>0.1, "high", "low")


knnTemp1c=knnTemp1b[knnTemp1b$NearestCellType%in%c("EpCAM"),  ]
knnTemp1d=knnTemp1b[knnTemp1b$NearestCellType%in%c("EpCAM: SMA"),  ]

knnEpMerge=merge(knnTemp1c, knnTemp1d[ ,c("MeanDistance", "MedianDistance", "variable", 
                                          "value","L1")], by.x="L1", by.y="L1", all=T)
knnEpMerge$EpDist2=ifelse(knnEpMerge$MedianDistance.x<knnEpMerge$MedianDistance.y, 
                          knnEpMerge$MedianDistance.x, knnEpMerge$MedianDistance.y)
knnEpMerge$EpDist2[which(is.na(knnEpMerge$EpDist2))]=knnEpMerge$MedianDistance.x[which(is.na(knnEpMerge$EpDist2))]

ggplot(knnEpMerge, aes(x=Growth , y=EpDist2, col=Growth))+geom_boxplot()+geom_point(position=position_jitterdodge(),alpha=0.3)+ylim(c(0, 200))+facet_grid(~CD8frac)

ggplot(knnEpMerge, aes(x=Treatment, y=EpDist2, col=Treatment))+facet_grid(~CD8frac)+geom_boxplot()+geom_point(position=position_jitterdodge(),alpha=0.3)+ylim(c(0, 200))

plot(knnEpMerge$CD8, knnEpMerge$EpDist2, col=factor(knnEpMerge$Growth))
text(knnEpMerge$CD8, knnEpMerge$EpDist2, knnEpMerge$L1)
plot(knnEpMerge$Ep, knnEpMerge$EpDist2, col=factor(knnEpMerge$Growth))
text(knnEpMerge$Ep, knnEpMerge$EpDist2, knnEpMerge$L1)

```


```{r}
## what is this used for?
knnTempSumm=knnTemp1[which(knnTemp1$knn=="knn3"), ]
knnreshape=acast(knnTempSumm[ ,c("NearestCellType", "MeanDistance", "L1")], L1~NearestCellType, value.var="MeanDistance" )
knnreshape=data.frame(knnreshape)
knnreshape$EpMIN=ifelse(knnreshape$EpCAM..SMA<knnreshape$EpCAM, knnreshape$EpCAM..SMA, knnreshape$EpCAM)
knnreshape$EpMIN[which(is.na(knnreshape$EpMIN))]=knnreshape$EpCAM[which(is.na(knnreshape$EpMIN))]
knnreshape$EpStrRatio1=knnreshape$EpCAM/rowSums(knnreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
knnreshape$EpStrRatio2=knnreshape$EpCAM/(knnreshape$SMA)
knnreshape$EpStrRatio3=rowSums(knnreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(knnreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
knnreshape$EpStrRatio4=rowSums(knnreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(knnreshape$SMA)
```

## The interacting fraction

The interacting fraction uses the knn-distances and determines the proportion of CD8 cells which are within a proximity of r um from celltype B.

### Comparison to manual & select optimal r

Below are plots of the proportion of CD8 cells within an "interacting distance" as we increase r. This looks at both the interacting fraction of CD8 cells with Epcam+ and SMA+ cells. Lines are color coded according to the manual spatial-infiltration annotation. 

We notice from the line plots for each single sample that the restricted samples generally have low interacting fractins with EpCAM and SMA compared to the infiltrating samples. In addition, there is a statistical difference in EpCAM measurements compared to SMA.

```{r, fig.height=4}
IFmelt=melt(WSIIF, measure.vars=c("IF"))

IFmelt$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
IFmelt$Treatment=Cdata$Treatment[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
IFmelt$Growth=Cdata$Tumor.Growth[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]
#IFmelt$Growth=IFmelt$Growth
#IFmelt$Growth[grep("no data", IFmelt$Growth)]="no data"

IFmelt$Dist=(substr(IFmelt$Grid, 6, 7))
IFmelt$knn=substr(IFmelt$Grid, 1, 4)
IFmelt$sample=Cdata$NewID[match(IFmelt$L1, gsub("_", "", Cdata$TumorID))]

IFTempSumm=IFmelt[IFmelt$Grid=="knn3-15" & IFmelt$Reference=="CD8", ]
IFreshape=acast(IFTempSumm[ ,c("NearestNeighbor", "value", "L1")], L1~NearestNeighbor, value.var="value" )
IFreshape=data.frame(IFreshape)

IFreshape$EpMIN=ifelse(IFreshape$EpCAM..SMA<IFreshape$EpCAM, IFreshape$EpCAM..SMA, IFreshape$EpCAM)
IFreshape$EpMIN[which(is.na(IFreshape$EpMIN))]=IFreshape$EpCAM[which(is.na(IFreshape$EpMIN))]
IFreshape$EpStrRatio1=IFreshape$EpCAM/rowSums(IFreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
IFreshape$EpStrRatio2=IFreshape$EpCAM/(IFreshape$SMA)
IFreshape$EpStrRatio3=rowSums(IFreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(IFreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
IFreshape$EpStrRatio4=rowSums(IFreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(IFreshape$SMA)


IFreshape$Treatment=factor(IFTempSumm$Treatment[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$Growth=factor(IFTempSumm$Growth[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$Infil=factor(IFTempSumm$SpatialManual[match(rownames(IFreshape), IFTempSumm$L1)])
IFreshape$CD8frac=SummaryData$CD8Frac.WSI[match(rownames(IFreshape), rownames(SummaryData))]
IFreshape$TumSize=SummaryData$TumSize[match(rownames(IFreshape), rownames(SummaryData))]

####
# line plots to see the best separation between infiltrating and restricted
###

#pdf(sprintf("rslt/WSI-analysis/interacting_fraction_compared_manual_%s.pdf", Sys.Date()), height=8, width=14)

IFmelt2=IFmelt[IFmelt$NearestNeighbor=="EpCAM" & IFmelt$Reference=="CD8" , ]
IFmelt2$label=IFmelt2$L1
IFmelt2$label[which(IFmelt2$Dist!=30)]=NA
p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, group=L1, label=label))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-EpCAM interacting fraction: spatial manual")+geom_label()
print(p)

#IFmelt2$Dist=as.numeric(IFmelt2$Dist)

p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-EpCAM knn3")+stat_smooth()
print(p)

IFmelt2=IFmelt[IFmelt$NearestNeighbor=="SMA" & IFmelt$Reference=="CD8" , ]
IFmelt2$label=IFmelt2$L1
IFmelt2$label[which(IFmelt2$Dist!=30)]=NA

p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, group=L1, label=label))+facet_grid(~knn)+geom_line(aes(group=L1))+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("CD8-SMA interacting fraction: spatial manual")+geom_label()
print(p)


p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-SMA knn3 ")
print(p)

# ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, linetype=SpatialManual))+geom_point()+stat_smooth()+ggtitle("CD8-EpCAM interacting fraction: spatial manual")+ylab("Interacting Fraction")

# ## Do a dot plot
 # p<-ggplot(IFmelt2, aes(x=Dist, y=value, col=SpatialManual, label=label))+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+facet_grid(~knn)+ggtitle("CD8-SMA knn3 ")
 # print(p)
```


Using the boxplots as a guide, we can determine optimal "interacting distances" at which to perform downstream analysis. The best separation between restricted and infiltrating for EpCAM appears at:

* 1-nn: 10-15 um
* 3-nn: 15 um
* 5-nn: 20 um

The interacting fraction does not distinguish SMA fractions (all restricted boxplots overlap with the infiltrating boxplots)


```{r, fig.height=6, eval=F}

#The following plots use 3NN analysis with an interacting distance of 15um. We can firstly check if there is an association between different "interacting fraction" types and manual scoring, similar to what was performed for knn-analysis. Only CD8-EpCAM interacting distances is associated with manual scoring. All other metrics are not significant.


## reshape and do a correlation plot like for the knn analysis
par(mfrow=c(3,3))
for (i in 1:9){
  a1=wilcox.test(IFreshape[ ,i]~IFreshape$Infil)
  boxplot(IFreshape[ ,i]~IFreshape$Infil, main=paste(colnames(IFreshape)[i]," p=", round(a1$p.value,2), sep="" ), xlab="IF: knn3, 15um")
}
```


```{r, fig.height=4}

# Again, association between CD8 content and interacting fraction was observed ONLY in the growing samples or restricted cases. 
par(mfrow=c(1,2))
a1x=cor.test(IFreshape$CD8frac[IFreshape$Infil=="Infiltrating"], IFreshape$EpCAM[IFreshape$Infil=="Infiltrating"])
a1y=cor.test(IFreshape$CD8frac[IFreshape$Infil=="restricted"], IFreshape$EpCAM[IFreshape$Infil=="restricted"])
plot(IFreshape$CD8frac, IFreshape$EpCAM, col=IFreshape$Infil, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM IF (knn3-15um)", main="spatial scoring")
legend("topright", c(paste("infil p=", round(a1x$p.value,2)), paste("restrict p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))

a1x=cor.test(IFreshape$CD8frac[IFreshape$Growth=="growing"], IFreshape$EpCAM[IFreshape$Growth=="growing"])
a1y=cor.test(IFreshape$CD8frac[IFreshape$Growth=="stable"], IFreshape$EpCAM[IFreshape$Growth=="stable"])

plot(IFreshape$CD8frac, IFreshape$EpCAM, col=IFreshape$Growth, pch=19, xlab="CD8 fraction", ylab="CD8-EpCAM IF (knn3-15um)", main="tumor growth")
legend("topright", c(paste("growing p=", round(a1x$p.value,2)), paste("stable p=", round(a1y$p.value,2))), lwd=2, col=c(1,2))
```

### Growth

Here, we check if there is an association between the spatial pattern and tumor growth. P value by wilcox test shown

```{r if-growth, fig.cap="interacting fraction"}

######
# compare these metrics with growth
####
#pdf("~/Desktop/4D-IF-summary-growth.pdf", height=5, width=7)

#pdf(sprintf("rslt/WSI-analysis/interacting_fraction_vs_treatment_growth_%s.pdf", Sys.Date()), height=7, width=12)
ctypes=unique(IFmelt$NearestNeighbor)
t2=IFmelt[which(IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15) , ]

pval2=sapply(ctypes, function(x) wilcox.test(t2$value[t2$NearestNeighbor==x & t2$Growth=="growing" ], t2$value[t2$NearestNeighbor==x & t2$Growth=="stable" ])$p.value)

ann_text=data.frame(Glabel=round(pval2,3), NearestNeighbor=(ctypes ), Growth="stable", value=0.7)

p=ggplot(IFmelt[IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15 , ], aes(x=Growth, y=value, col=Growth))+facet_grid(~NearestNeighbor)+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("Interacting fraction, knn3, dist=15")+theme_bw()+geom_point(position=position_jitterdodge(),alpha=0.3)+scale_color_manual(values=c(ColSizeb, "black"))
p+geom_text(data=ann_text, mapping=aes(x=2, y=0.75, label=Glabel))

DT::datatable(IFmelt[IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15 , c(2:4, 6, 8:9, 12)], rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))
pval2
```



### Treatment

Similarly, compare the distances with treatment: 

```{r}
#pdf("~/Desktop/4D-IF-summary-treatment.pdf", height=5, width=7)

ctypes=unique(IFmelt$NearestNeighbor)
t2=IFmelt[which(IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15) , ]
TreatV=sort(unique(IFmelt$Treatment))

pval2=matrix(NA, nrow=3, ncol=5)
colnames(pval2)=ctypes
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(ctypes, function(x) wilcox.test(t2$value[t2$NearestNeighbor==x & t2$Treatment==TreatV[i]], t2$value[t2$NearestNeighbor==x & t2$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "NearestNeighbor", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(IFmelt[IFmelt$Reference=="CD8" & IFmelt$knn=="knn3" & IFmelt$Dist==15 , ], aes(x=Treatment, y=value, col=Treatment))+facet_grid(~NearestNeighbor)+geom_boxplot()+ylab("Interacting Fraction")+xlab("Distance in microns")+ggtitle("Interacting fraction, knn3, dist=15")+geom_point(position=position_jitterdodge(),alpha=0.3)+scale_color_manual(values=c(ColMerge[,1]))
p+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.75, label=label, col=Treatment))

fit1=aov(value~Treatment, data=IFmelt[IFmelt$NearestNeighbor=="EpCAM" & IFmelt$Reference=="CD8", ])
fit2=aov(value~Treatment, data=IFmelt[IFmelt$NearestNeighbor=="SMA"& IFmelt$Reference=="CD8", ])
fit3=aov(value~Treatment, data=IFmelt[IFmelt$NearestNeighbor=="EpCAM: SMA"& IFmelt$Reference=="CD8", ])
fit4=aov(value~Treatment, data=IFmelt[IFmelt$NearestNeighbor=="Unclass"& IFmelt$Reference=="CD8", ])

```

There appears to be a difference in CD8-unclass interactions in LY treated samples (LY, PDL1+LY), but not in the other cases

## M-H distances

The M-H distance (or Morisita Horn index) can be considered as a correlation coefficient in spatial distribution between cell type A and cell type B. To calculate this metric, the whole slide image is divided into grids of size 50 to 500um. Within each grid, the total number of cells A and B are determined. 

The M-H index is thus determined as:

$$ \frac{2\sum_{i=1}^n a_ib_i}{(D_a+D_b)AB} $$
where $a_i$ and $b_i$ are the number of cells in grid $i$, $A$ and $B$ the total number of cells, and $D_x$ is the Simpson's index.

### Comparison to Manual Scoring

Similar to the interacting fraction, we plot the MH index for increasing values of gridsize to determine an optimal metric to compare spatial patterns. Ideally, we would pick a metric has the following properties:

* good separation of the different values
* a reasonable number of cells within each grid (avoid too small grids which give counts of 0)
* avoid plateauing of MH values because the grid size is too large

```{r, fig.height=4}
MHgridsize=150

MHmeltsumm=melt(WSIMHsetup, id.vars=c("gridsize", "Ntiles"))

MHmelt=melt(WSIMH, measure.vars="MH.mean")
MHmelt$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
MHmeltsumm$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(MHmeltsumm$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Treatment=factor(Cdata$Treatment[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))])
MHmelt$Growth=factor(Cdata$Tumor.Growth[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))])
MHmelt$Growth=MHmelt$Growth
#MHmelt$Growth[grep("no data", MHmelt$Growth)]="no data"

A1=MHmelt[MHmelt$Var2=="CD8", ]
A1$label=A1$L1
A1$label[which(A1$gridsize!=500)]=NA

A2=MHmelt[MHmelt$Var2=="CD8" & MHmelt$gridsize==MHgridsize & MHmelt$Var1%in%c("EpCAM", "SMA"), ]
A3=MHmelt[MHmelt$Var2=="CD8" & MHmelt$gridsize==MHgridsize, ]
A3$CD8frac=WSIvalFracs[ 1, match(A3$L1, colnames(WSIvals))]

MHTempSumm=A3 #MHmelt[which(MHmelt$gridsize==300 & MHmelt$Var2=="CD8"), ]
MHreshape=acast(A3[ ,c("Var1", "value", "L1")], L1~Var1, value.var="value" )
MHreshape=data.frame(MHreshape)
MHreshape$EpMIN=ifelse(MHreshape$EpCAM..SMA<MHreshape$EpCAM, MHreshape$EpCAM..SMA, MHreshape$EpCAM)
MHreshape$EpMIN[which(is.na(MHreshape$EpMIN))]=MHreshape$EpCAM[which(is.na(MHreshape$EpMIN))]
MHreshape$EpStrRatio1=MHreshape$EpCAM/rowSums(MHreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)

MHreshape$EpStrRatio2=MHreshape$EpCAM/(MHreshape$SMA)
MHreshape$EpStrRatio3=rowSums(MHreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/rowSums(MHreshape[ ,c("EpCAM..SMA", "SMA")], na.rm=T)
MHreshape$EpStrRatio4=rowSums(MHreshape[ ,c("EpCAM..SMA", "EpCAM")], na.rm=T)/(MHreshape$SMA)
MHreshape$Treatment=factor(A3$Treatment[match(rownames(MHreshape), A3$L1)])
MHreshape$Growth=factor(A3$Growth[match(rownames(MHreshape), A3$L1)])
MHreshape$Infil=factor(A3$SpatialManual[match(rownames(MHreshape), A3$L1)])

#pdf(sprintf("rslt/WSI-analysis/MHplots_compare_spatial_manual_%s.pdf", Sys.Date()), height=7, width=12)

p<-ggplot(A1, aes(x=gridsize, y=value, col=SpatialManual, label=label))+facet_grid(~Var1)+geom_line(aes(group=L1))+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: spatial manual")+geom_label()
print(p)

ggplot(A1, aes(x=factor(gridsize), y=value, col=SpatialManual, label=label))+facet_grid(~Var1)+geom_boxplot()+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: spatial manual")

ggplot(MHmeltsumm, aes(x=factor(gridsize), y=value, col=SpatialManual))+facet_wrap(~variable, scale="free_y")+geom_boxplot()+xlab("grid size")+ylab("Morisita Horn index")+ggtitle("expected number of cells in each grid size")+scale_y_log10()
```


With increasing grid size, optimal differences between infiltrating and restricted appear at the following sizes:

* epCAML 100um+
* epcam:SMA most significant at 350+
* SMA: 150+
* Unclass:200+

We probably want to use a metric/gridsize of 250 um as the expected/mean number of cells in each grid is 10 here.
Other notes:

* double positive cells (EpCAM+SMA+) appear in predominantly the restricted cases?
* higher SMA- stromal cells in restricted

### Growth

Below are the MH indices with increasing grid-size for individual samples. In general, there is a subset of stable samples which have very high intermixing

```{r 4e, fig.cap="Fig4e MH index with CD8 growth"}

p<-ggplot(A1, aes(x=gridsize, y=value, col=Growth))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: growth")+geom_point(position=position_jitterdodge(),alpha=0.3)
print(p)

```

We can condense these values based on growing vs stable cases:

```{r 4E-MH-summary}
#pdf("figure-outputs/4E-MH-summary-growth.pdf", height=5, width=7)

pvals=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Growth=="growing"], 
                                                      A3$value[A3$Var1==x & A3$Growth=="stable"])$p.value)

ann_text=data.frame(label=round(pvals,2), Var1=unique(A3$Var1), Growth="growing")

ggplot(A3, aes(x=Growth, y=value, col=Growth))+facet_grid(~Var1)+geom_boxplot()+geom_point()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: growth")+geom_text(data=ann_text, mapping = aes(x=2, y=0.75, label=label))+scale_color_manual(values=c(ColSizeb, "black"))
#dev.off()

DT::datatable(A3, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

#write.csv(A3, file="nature-tables/Fig4e-Ext4h.csv")
```

Although the MH values for growing vs stable are not different, we can compare the mixing in epcam vs stroma in matched samples:

```{r}
#pdf("~/Desktop/4E-MH-summary-matched-samples-growing-stable.pdf", height=5, width=7)


A2t=A2[-which(A2$L1%in%c("15RD", "5LB")), ]

 a1=t.test(A2t$value[A2t$Growth=="stable" & A2t$Var1=="EpCAM"], A2t$value[A2t$Growth=="stable" & A2t$Var1=="SMA"], paired=T)
 a2=t.test(A2t$value[A2t$Growth=="growing" & A2t$Var1=="EpCAM"], A2t$value[A2t$Growth=="growing" & A2t$Var1=="SMA"], paired=T)
# 
ggplot(A2, aes(x=Var1, y=value, col=Growth))+facet_grid(~Growth)+geom_line(aes(group=L1))+ylab("grid size")+ylab(sprintf("Morisita Horn index @ %s", MHgridsize))+ggtitle(sprintf("MH index with CD8: stable p=%s, growing p=%s", round(a1$p.value, 2), round(a2$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
```

In the growing cases, there is a difference in the MH index in epacam and stroma, but the stable cases do not support this.

### Treatment

```{r}

#pdf("~/Desktop/4E-MH-summary-treatment.pdf", height=5, width=7)


pval2=matrix(NA, nrow=3, ncol=4)
colnames(pval2)=unique(A3$Var1)
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Treatment==TreatV[i]], A3$value[A3$Var1==x & A3$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "Var1", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(A1, aes(x=gridsize, y=value, col=Treatment))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")+geom_point(position=position_jitterdodge(),alpha=0.3)
print(p)
```

```{r Ext4h, fig.cap="MH values with Treatment"}
ggplot(A3, aes(x=Treatment, y=value, col=Treatment))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle("MH index with CD8: Treatment")+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.8, label=label))+geom_point(position=position_jitterdodge(),alpha=0.3)+theme_bw()+scale_color_manual(values=ColMerge[ ,1])


#dev.off()
```

There is no difference between the different spatial metrics compared to the vehicle, however, we can compare for a given treatment if there is a difference between the epcam and the stromal interaction scores. It appears that there is a difference only in the control, where SMA mixing is higher than EPcam mixing:

```{r}
## pairwise comparison: Epcam vs stroma
## calculate the pairwise p values here
A2t=A2[-which(A2$L1%in%c("15RD", "5LB")), ]

a1=t.test(A2t$value[A2t$Treatment=="Vehicle" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="Vehicle"& A2t$Var1=="SMA"], paired=T)
a2=t.test(A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1" & A2t$Var1=="SMA"], paired=T)
a3=t.test(A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="PDL1+LY" & A2t$Var1=="SMA"], paired=T)
a4=t.test(A2t$value[A2t$Treatment=="LY" & A2t$Var1=="EpCAM"], A2t$value[A2t$Treatment=="LY" & A2t$Var1=="SMA"], paired=T)

p<-ggplot(A2, aes(x=Var1, y=value, col=Treatment))+facet_grid(~Treatment)+geom_line(aes(group=L1))+ylab("grid size")+ylab(sprintf("Morisita Horn index @ %s", MHgridsize))+ggtitle(sprintf("MH index with CD8: Cntl p=%s, PDL1 p=%s LY p=%s P+L p=%s", round(a1$p.value, 2), round(a2$p.value, 2), round(a3$p.value,2), round(a4$p.value, 2)))+geom_errorbar(aes(ymin=MH.lower, ymax=MH.upper), width=.2)+geom_point()
print(p)
```

## Comparison between metrics

After assessing optimal parameters for each metric, in this section we assess which metric could be the best for spatial analysis.

Below is a table of the different metrics and their values for each sample

```{r}
#write.table(SummaryData, file="../metadata/WSI_compared_other_metrics.csv")

##
# Combine the data from above into one file
#
df.temp=cbind(knnreshape[ , 1:9], IFreshape[ ,1:10], MHreshape[ , 1:9] )
colnames(df.temp)=paste(rep(c("knn", "IF", "MH"), times=c(9, 10, 9)), colnames(df.temp),sep=".")
#colnames(df.Spatial)=paste()
df.Spatial=cbind(df.Spatial, df.temp)
#df.Spatial=cbind(df.Spatial,IFreshape[ ,11:14])
df.Spatial$GrowthRate=Cdata$GrowthRate[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$TumSize=Cdata$Tumor.diameter.sac.mm[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$knn.EpCAMcut=cut(df.Spatial$knn.EpCAM, c(-1, median(df.Spatial$knn.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$MH.EpCAMcut=cut(df.Spatial$MH.EpCAM, c(-1, median(df.Spatial$MH.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$IF.EpCAMcut=cut(df.Spatial$IF.EpCAM, c(-1, median(df.Spatial$IF.EpCAM, na.rm = T), 1.2), c("low", "high"))
df.Spatial$CD8Fraccut=cut(df.Spatial$CD8frac, c(-1, median(df.Spatial$CD8frac, na.rm = T), 1.2), c("low", "high"))

#t2=WSIvalFracs[, match(rownames(df.Spatial), colnames(WSIvalFracs))]
#rownames(t2)=paste(rownames(t2), "Frac.WSI", sep="")
#t3=WSIvals[, match(rownames(df.Spatial), colnames(WSIvalFracs))]
#rownames(t2)=paste(rownames(t2), ".WSI", sep="")

#df.Spatial=cbind(df.Spatial, t(t2), t(t3))

scroll_box(kable(df.Spatial, format="html"),
         height="300px", width="100%")
```

Firstly, we can compare the different metrics to determine how similar or different they are: They generally associate very well, with knn and IF being the best (they are directly related metrics)

```{r, fig.height=6}
par(mfrow=c(2,2))
a1=cor.test(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM)
plot(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM, xlab="knn", ylab="MH",
     main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))
a1=cor.test(df.Spatial$IF.EpCAM, df.Spatial$MH.EpCAM)
plot(df.Spatial$MH.EpCAM, df.Spatial$IF.EpCAM,  xlab="MH", ylab="IF",
      main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))
a1=cor.test(df.Spatial$knn.EpCAM, df.Spatial$MH.EpCAM)
plot( df.Spatial$IF.EpCAM,df.Spatial$knn.EpCAM,  xlab="IF", ylab="knn",
       main=sprintf("cor:%s, p:%s", round(a1$estimate,2), round(a1$p.value, 2)))
```

We can also make comparisons directly against growth rate and tumor size

```{r}
par(mfrow=c(2,3))

cNames=c("knn.EpCAM", "IF.EpCAM", "MH.EpCAM")

for (i in cNames){
t1=cor.test(df.Spatial[, i],df.Spatial$GrowthRate, use="complete")
plot(df.Spatial[, i]~df.Spatial$GrowthRate, ylab=i, xlab="Growth Rate", main=sprintf("cor:%s p:%s", round(t1$estimate, 2), round(t1$p.value,2)))

t1=cor.test(df.Spatial[ ,i],df.Spatial$TumSize, use="complete")
plot(df.Spatial[, i]~as.numeric(as.character(df.Spatial$TumSize)), ylab=i, xlab="Tumor size", main=sprintf("cor:%s p:%s", round(t1$estimate, 2), round(t1$p.value, 2)))
}

```


## Distances to "unclassified cells"

We noted that the proportion of Unclassified cells seemed to be different between the treatments. Assess here whether the MH index for this cell type is associated with growth or treatment here:


```{r}
varsearch="Unclass"

#MHmeltsumm=melt(WSIMHsetup, id.vars=c("gridsize", "Ntiles"))

MHmelt=melt(WSIMH, measure.vars="MH.mean")
MHmelt$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmeltsumm$SpatialManual=Cdata$Pathologist.CD8.Spatial[match(MHmeltsumm$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Treatment=Cdata$Treatment[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
MHmelt$Growth=Cdata$Tumor.Growth[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmelt$Growth=Cdata$Tumor.growth.status[match(MHmelt$L1, gsub("_", "", Cdata$TumorID))]
#MHmelt$Growth[grep("no data", MHmelt$Growth)]="no data"

A1=MHmelt[MHmelt$Var2==varsearch| MHmelt$Var1==varsearch, ]
A1$label=A1$L1
A1$label[which(A1$gridsize!=500)]=NA
A1$Var1=ifelse(A1$Var1==varsearch, as.character(A1$Var2), as.character(A1$Var1))

A2=MHmelt[(MHmelt$Var2==varsearch|MHmelt$Var1==varsearch) & MHmelt$gridsize==250 & MHmelt$Var1%in%c("EpCAM", "SMA"), ]
A3=MHmelt[(MHmelt$Var2==varsearch|MHmelt$Var1==varsearch) & MHmelt$gridsize==250, ]
A3$CD8frac=WSIvalFracs[ 1, match(A3$L1, colnames(WSIvals))]

A3$Var1=ifelse(A3$Var1==varsearch, as.character(A3$Var2), as.character(A3$Var1))

MHTempSumm=A3 #MHmelt[which(MHmelt$gridsize==300 & MHmelt$Var2==varsearch), ]
MHreshape=acast(A3[ ,c("Var1", "value", "L1")], L1~Var1, value.var="value" )
MHreshape=data.frame(MHreshape)

MHreshape$Treatment=A3$Treatment[match(rownames(MHreshape), A3$L1)]
MHreshape$Growth=A3$Growth[match(rownames(MHreshape), A3$L1)]
MHreshape$Infil=A3$SpatialManual[match(rownames(MHreshape), A3$L1)]

colnames(MHreshape)=paste(varsearch, colnames(MHreshape), sep=".")
DT::datatable(MHreshape, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))
#write.csv(MHreshape, file=sprintf("outputs/%s_MH_comparisons_gridsize250.csv", varsearch))

# pdf(sprintf("rslt/WSI-analysis/MHplots_spatial_growth_treatment_%s_celltype_%s.pdf", varsearch, Sys.Date()), height=7, width=12)
# 
 p<-ggplot(A1, aes(x=gridsize, y=value, col=Growth))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))
 print(p)
 
pvals=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Growth=="growing"],A3$value[A3$Var1==x & A3$Growth=="stable"])$p.value)

ann_text=data.frame(Growth="stable", y=0.8, label=round(pvals,2), Var1=unique(A3$Var1))
 
ggplot(A3, aes(x=Growth, y=value, col=Growth))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))+
  geom_text(data=ann_text, mapping = aes(x=Growth , y=0.75, label=label))
 

pval2=matrix(NA, nrow=3, ncol=4)
colnames(pval2)=unique(A3$Var1)
rownames(pval2)=TreatV[1:3]

for (i in 1:3){
pval2[i, ]=sapply(unique(A3$Var1), function(x) wilcox.test(A3$value[A3$Var1==x & A3$Treatment==TreatV[i]], A3$value[A3$Var1==x & A3$Treatment=="Vehicle"])$p.value)
}

pmelt=melt(pval2)
colnames(pmelt)=c("Treatment", "Var1", "label")
pmelt$label=round(pmelt$label, 2)
pmelt$value=0.8

p<-ggplot(A1, aes(x=gridsize, y=value, col=Treatment))+facet_grid(~Var1)+geom_line(aes(group=L1))+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))
print(p)

ggplot(A3, aes(x=Treatment, y=value, col=Treatment))+facet_grid(~Var1)+geom_boxplot()+ylab("grid size")+ylab("Morisita Horn index")+ggtitle(sprintf("MH index with %s: growth", varsearch))+geom_text(data=pmelt, mapping=aes(x=Treatment, y=0.8, label=label))

```

We see here that epcam-unclass mixing could also be associated with tumor growth - this could be attributed to a hight number of other immune related cells in this fraction.

Note that we can change the entry cell type to obtain the same plots for other reference cells of interest.

<!--chapter:end:02b-wsi.Rmd-->

# Expression data

This file looks at loading and pre-processing data for:

* differential gene expression analysis
* uploading into CIBERSORT/TIMER

## Running alignment

Samples were mapped in star using the following parameters. Note that the first two batches of samples run had shorter read lengths (~75 bp) whereas batch 3 had lengths of ~150bp

```{r, eval=F, echo=T}
## Not run here
STAR \
     --readFilesCommand zcat \
     --genomeDir /n/scratch2/at268/rn6_v2 \
     --sjdbGTFfile /n/scratch2/at268/rn6_v2/rn6.refGene.gtf \
     --runThreadN 10 \
     --runMode alignReads \
     --genomeLoad NoSharedMemory\
     --outSAMattributes	NH HI AS nM NM\
     --outSAMstrandField intronMotif\
     --outFilterMultimapNmax 20\
     --alignSJoverhangMin 8\
     --readFilesIn $1 $2 \
     --alignSJDBoverhangMin 1\
     --outFilterMismatchNmax 999\
     --outFilterMismatchNoverLmax 0.1\
     --alignIntronMin 20\
     --alignIntronMax 1000000\
     --alignMatesGapMax	1000000\
     --outFilterType BySJout\
     --outFilterScoreMinOverLread 0.33 \
     --outFilterMatchNminOverLread 0.33 \
     --limitSjdbInsertNsj 1200000 \
     --outFilterIntronMotifs None \
     --alignSoftClipAtReferenceEnds Yes\
     --outSAMattrRGline	ID:$4 SM:$4 \
     --chimSegmentMin 15 \
     --chimJunctionOverhangMin 15\
     --limitBAMsortRAM 0\
     --outSAMtype BAM SortedByCoordinate\
     --outSAMunmapped Within \
     --quantMode GeneCounts transcriptomeSAM \
     --quantTranscriptomeBan IndelSoftclipSingleend \
     --outFileNamePrefix $3 \
     --twopassMode Basic
```


```{r}
# Upload infoTable
infoTable=read.csv("../metadata/AllRNA_samples_jan.csv")
```

## RNA Initial QC

```{r rna-preprocess, cache=T}
BatchNo="april"

rsemFiles=dir("../data/RNA_expression/rsem/", ".results")
allrsem=matrix(NA, nrow=17455, ncol=length(rsemFiles)) #31038
allTPM=matrix(NA, nrow=17455, ncol=length(rsemFiles))
allFPKM=matrix(NA, nrow=17455, ncol=length(rsemFiles))
for (i in 1:length(rsemFiles)){
  a1=read.delim(file.path("../data/RNA_expression/rsem/", rsemFiles[i]))
  allrsem[ ,i]=a1$expected_count
  allTPM[ ,i]=a1$TPM
  allFPKM[ ,i]=a1$FPKM
}

cNames=unlist(strsplit(rsemFiles, ".genes.results"))
cNames=unlist(strsplit(cNames, "_0.33_v2"))
sAnnot=match(cNames, infoTable$starSampleName)
colnames(allrsem)=paste(infoTable$Rat_ID[sAnnot],infoTable$Location[sAnnot], infoTable$Fraction[sAnnot],  sep="_")
rownames(allrsem)=a1$gene_id

colnames(allTPM)=colnames(allrsem)
rownames(allTPM)=rownames(allrsem)

colnames(allFPKM)=colnames(allrsem)
rownames(allFPKM)=rownames(allrsem)

starFiles=dir("../data/RNA_expression/star_april/", ".tab")
allstar=matrix(NA, nrow=17455, ncol=length(starFiles))
allmapp=matrix(NA, nrow=4, ncol=length(starFiles))


for (i in 1:length(starFiles)){
  a1=read.delim(file.path("../data/RNA_expression/star_april/", starFiles[i]), header=F)
  allstar[ ,i]=a1[ -c(1:4),2]
  allmapp[ ,i]=a1[ c(1:4),2]
}

cNames=unlist(strsplit(starFiles, "ReadsPerGene.out.tab"))
cNames=unlist(strsplit(cNames, "_0.33_v2"))
sAnnot=match(cNames, infoTable$starSampleName)
colnames(allstar)=paste(infoTable$Rat_ID[sAnnot], infoTable$Location[sAnnot],infoTable$Fraction[sAnnot], sep="_")
rownames(allstar)=a1[-c(1:4) ,1]

colnames(allmapp)=colnames(allstar)
allmapp=rbind(allmapp, colSums(allstar))

rownames(allmapp)=c(as.character(a1[c(1:4), 1]), "UniqueReads")


## in all cases, remove the files 
id=match(cNames, infoTable$starSampleName)
infoTable=infoTable[ na.omit(id), ]
id2=which(is.na(id))

if (length(id2)>0){

allmapp=allmapp[ , -grep("NA_NA", colnames(allmapp))]

allTPM=allTPM[ , -id2]
allFPKM=allFPKM[ , -id2]
allrsem=allrsem[ , -id2]
allstar=allstar[, -id2]
}
```


Default output from R showing the number of unique reads compared to multimapped, unmapped etc. This is shown for each batch.
Note that batch 3 has differences (high percentage of unmapped) compared to the other batches, possibly due to DNA contamination.

Below we check for three measures:

- mapped million reads (ideally, 10M+ reads)
- Gene Sparsity: This is a measurement of the number of genes which have non-zero values. Ideally, would be greater than 10K, but values which are too high may also suggest contamination from DNA (unexpressed genes are also counted)
- Varability: standard deviation of the transcriptomic counts. If this value is too low, would suggest that high DNA contamination, non-representative transcriptome.


```{r summary-plots-rna-quality}
# number of mapped reads
UnMappedNorm=t(allmapp)/colSums(allmapp)

mUnMap=melt(UnMappedNorm)
mUnMap$Batch=infoTable$Batch[match(mUnMap$Var1, infoTable$SampleID)]

# how many genes represented
Sparsity=colSums(sign(allstar))
# check how skewed the data is

cSDs=colSds(allstar)

TVals=data.frame(MappedReadsM=allmapp[5, ]/1E6, GeneSparsityK=Sparsity/1E3,Batch=infoTable$Batch, GeneVariabilityCounts=cSDs, Type=as.character(infoTable$Fraction), names=colnames(allstar))

mTV=melt(TVals, measure.vars = c("MappedReadsM", "GeneSparsityK", "GeneVariabilityCounts"))

#pdf(sprintf("../rslt/DESeq/GE_preprocessing_%s_%s.pdf", BatchNo,Sys.Date()), height=5, width=8)

ggplot(mUnMap, aes(x=Var1, y=value, fill=Var2))+geom_bar(stat="identity")+facet_grid(~Batch, space="free", scale="free")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ylab("proportion of reads")+ggtitle("mapping summary")

ggplot(mTV, aes(x=names, y=value,fill=Type))+geom_bar(stat="identity")+
  facet_grid(variable~Batch, space="free_x", scale="free")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("#Mapped Reads, #Unique Gebes, #Variability")

par(mfrow=c(2,2))

plot(density(TVals$MappedReadsM), main="mapped reads")
x1=mean(TVals$MappedReadsM)
sdv=sd(TVals$MappedReadsM)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.07, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)

plot(density(TVals$GeneSparsityK), main="gene sparsity")
x1=mean(TVals$GeneSparsityK)
sdv=sd(TVals$GeneSparsityK)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.07, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)

plot(density(TVals$GeneVariabilityCounts), main="Gene Variability")
x1=mean(TVals$GeneVariabilityCounts)
sdv=sd(TVals$GeneVariabilityCounts)
abline(v=c(x1, x1-1.5*sdv, x1+1.5*sdv), col="grey", lty=2)
text( c(x1, x1-1.5*sdv, x1+1.5*sdv), 0.00015, c(x1, x1-2*sdv, x1+2*sdv), las=2, cex = 0.75, srt=90)

#dev.off()
```


Samples to remove from analysis:

The thresholds indicated below are based on the above density plots, and removes cases which are <1.5 SD of the mean

* low total number of mapped reads (under 1.5M)
* sparsity: less than 8K genes
* variability : threshold under 500


```{r}
rmSamples=which(TVals$MappedReadsM<1.5 | TVals$GeneSparsityK<8 | TVals$GeneVariabilityCounts<500)
allstarFinal=allstar[ ,-rmSamples]
allrsemFinal=allrsem[ ,-rmSamples]
allTPMFinal=allTPM[ ,-rmSamples]
allFPKMFinal=allFPKM[ ,-rmSamples]
infoTableFinal=infoTable[-rmSamples, ]
```

The omitted samples are:

```{r}
kable(TVals[rmSamples, ])
```

We are left with `r ncol(allstarFinal)` samples. 

There are `r table(infoTableFinal$Fraction)` samples in the `r unique(infoTableFinal$Fraction)` fractions.

There are `r table(infoTableFinal$Batch)` samples from batches 1, 2 and 3 respectively.

## Normalisation

Run through DESEq and normalise the library. Using all samples, we run the model:

expression ~ Celltype + factor (Batch)

and keep the genes which have a total count of at least half the number of samples. ie.
$$ sum(gene_i) > N_{samples}/2 $$


```{r deseq-1, cache=T, eval=T}
# remove rows where counts are low
rownames(infoTableFinal)=infoTableFinal$SampleID
infoTableFinal$Batch=factor(infoTableFinal$Batch)
dds=DESeqDataSetFromMatrix(allstarFinal, infoTableFinal, design=~Fraction+factor(Batch)) ## change class
keep=rowSums(counts(dds))>(ncol(dds)/2)
dds=dds[keep, ]
dds=DESeq(dds)

vsd <- varianceStabilizingTransformation(dds)
normalizedTableVSD <- assay(vsd)

infoTableFinal$TumorIDnew=Cdata$NewID[match(infoTableFinal$TumorID, Cdata$TumorID)]

save(dds, vsd,allstarFinal, allrsemFinal,allTPMFinal, normalizedTableVSD,infoTableFinal,  file=sprintf("../dds_normalised_data_newstar_RNAseq%s_%s.RData", BatchNo, Sys.Date()))
```

### preliminary visualisation (to remove outliers)

Below are PCA plots based on:

* Batch
* CellType

```{r vsd-transform,eval=T, cache=T, fig.height=4}
vsd2 <- vst(dds)

#pdf(sprintf("../rslt/DESeq/PCA_preliminary_%s_%s.pdf",BatchNo, Sys.Date() ), width=8, height=6)

plotPCA(vsd2, "Batch")+ggtitle("Batch")
plotPCA(vsd2, "Fraction")+ggtitle("Fraction")
plotPCA(vsd2, c("Fraction"))+geom_label(aes(label = name)) 
```

Batches in general separate out well, however, some samples appear to be outliers in comparison to the main group. We look in closer detail the CD45, DN and EpCAM populations.

In the CD45 population, narrow down to only immune related genes to see if there is a difference.

```{r}
plotPCA(vsd2[rownames(assay(vsd2))%in%RatAllImm  , grep("CD45", colnames(vsd2))], c("Growth"))+ggtitle("CD45 only Growth")
plotPCA(vsd2[ , grep("Ep", colnames(vsd2))], "Growth")+geom_label(aes(label = name))+ggtitle("Ep only Growth")
plotPCA(vsd2[ , grep("DN", colnames(vsd2))], "Growth")+geom_label(aes(label = name))+ggtitle("DN only Growth")

```

Based on the above plots, we remove the following outliers and re-run the normalisation:

* 2R_D_DN
* 4L_B_CD45

```{r rm-ill-samples, cache=T}
rmThese=c("2R_D_DN", "4L_B_CD45")

## Note based on the above plots, sample "2R_D_DN" is misclassified as a cd45 sample. Need to remove this sample and re-run the preprocessing:
allstarFinal=allstarFinal[ ,-match(rmThese, colnames(allstarFinal))]
infoTableFinal=infoTableFinal[-match(rmThese, rownames(infoTableFinal)), ]
allrsemFinal=allrsemFinal[ ,-match(rmThese, colnames(allrsemFinal))]
allTPMFinal=allTPMFinal[ ,-match(rmThese, colnames(allTPMFinal))]

dds=DESeqDataSetFromMatrix(allstarFinal, infoTableFinal, design=~Fraction+factor(Batch)) ## change class
keep=rowSums(counts(dds))>(ncol(dds)/2)
dds=dds[keep, ]
dds=DESeq(dds)

vsd <- varianceStabilizingTransformation(dds)
normalizedTableVSD <- assay(vsd)

infoTableFinal$MHEpCAM=df.Spatial$MH.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$IFEpCAM=df.Spatial$IF.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$knnEpCAM=df.Spatial$knn.EpCAM[match(gsub("_", "", infoTableFinal$TumorID), rownames(df.Spatial))]
infoTableFinal$CD8Frac=df.Spatial$CD8frac[match(gsub("_", "", infoTableFinal$TumorID),rownames(df.Spatial))]

# infoTableFinal$Treatment=RNADNAsamples$Treatment[match(infoTableFinal$FqFile, RNADNAsamples$FqFile.CD45)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.Ep)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]
# idx=match(infoTableFinal$FqFile, RNADNAsamples$FqFile.DN)
# infoTableFinal$Treatment[-which(is.na(idx))]=RNADNAsamples$Treatment[na.omit(idx)]

save(dds, vsd,allstarFinal, allrsemFinal,allTPMFinal, normalizedTableVSD,infoTableFinal,  file=sprintf("outputs/dds_normalised_data_newstar_RNAseq_%s_rm_outliers.RData", Sys.Date()))
```

## Processing files for external software

We also process these files for external software (TIMER) - which can also run cibersort

```{r data4immune, cache=T, eval=F}
Rnames=rownames(allrsemFinal)
mNames1=SymHum2Rat$HGNC.symbol[match(Rnames, SymHum2Rat$RGD.symbol)]
mNames2=Rat2Hum$HGNC.symbol[match(Rnames, Rat2Hum$RGD.symbol)]

HumNameFinal=ifelse(is.na(mNames1), mNames2, mNames1)
x1=which(is.na(HumNameFinal)==T)

## save rsem for xcell
allrsemSave=allrsemFinal[-x1, ]
rownames(allrsemSave)=na.omit(HumNameFinal)

write.table(allrsemSave, sep="\t", file=sprintf("../output4external/RSEM_for_xcell%s__%s.txt",BatchNo, Sys.Date()), col.names = NA)

## save row names for cibersort
alltpmSave=allTPMFinal[-x1, ]
rownames(alltpmSave)=na.omit(HumNameFinal)
write.table(alltpmSave, sep="\t", file=sprintf("../output4external/TPM_for_cibersort%s_%s.txt",BatchNo, Sys.Date()), col.names = NA)
```

Also split up the immunotherapy and the characterisation cohorts.
Save the mouse names for TIMER cistrome: check that this is actually required for TIMER

```{r, cache=T, eval=F}

# Write files for CIBERSORT using rgd. Use cohort specific values
allTPMCD45=allTPMFinal[ , which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort=="Progression")]

write.csv(allTPMCD45, file=sprintf("../output4external/CD45_TPM_rgd_names_prog_%s.csv", Sys.Date()))

allTPMCD45=allTPMFinal[ , which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort!="Progression")]

write.csv(allTPMCD45, file=sprintf("../output4external/CD45_TPM_rgd_names_char_%s.csv", Sys.Date()))
```




<!--chapter:end:03-rna-preprocessing.Rmd-->

# RNA data: preliminary plots

Prior to doing any comparative analysis, we will look at the following plots to get an overview of the data.

## PCA plots

We can check the new PCA plots, and overlay parameters of interest including treatment, growth, tumor size, CD8 fraction, spatial distribution.

```{r vsd-corrected,eval=T, cache=T}
vsd2 <- vst(dds)
vsd2$MHEpCAMcut=cut(infoTableFinal$MHEpCAM, c(-1, median(infoTableFinal$MHEpCAM, na.rm = T), 1.1), c("low", "high"))
vsd2$knnEpCAMcut=cut(infoTableFinal$knnEpCAM, c(-1, median(infoTableFinal$knnEpCAM, na.rm = T), 1E7), c("low", "high"))
vsd2$IFEpCAMcut=cut(infoTableFinal$IFEpCAM, c(-1, median(infoTableFinal$IFEpCAM, na.rm = T), 1.1), c("low", "high"))
vsd2$CD8FracCut=cut(infoTableFinal$CD8Frac, c(-1, median(infoTableFinal$CD8Frac, na.rm = T), 1.1), c("low", "high"))

plotPCA(vsd2, c("Treatment"))+ggtitle("Treatment")
plotPCA(vsd2, c("Growth"))+ggtitle("Growth")
plotPCA(vsd2, "Batch")+ggtitle("Batch")

vsdLimmaCor=(vsd2)
assay(vsdLimmaCor)=limma::removeBatchEffect(assay(vsdLimmaCor),vsdLimmaCor$Batch)
```


In addition, we can look at the CD45 population and the distributions based on CD8 content and spatial infiltration

```{r pca-immune}
par(mfrow=c(2,2))

plotPCA(vsdLimmaCor[ , grep("CD45", colnames(vsdLimmaCor))], "CD8FracCut")+ggtitle("CD8 content")
plotPCA(vsdLimmaCor[ , grep("CD45", colnames(vsdLimmaCor))], "IFEpCAMcut")+ggtitle("CD8-EpCAM Infiltrating Fraction")
plotPCA(vsdLimmaCor[ , grep("CD45", colnames(vsdLimmaCor))], "knnEpCAMcut")+ggtitle("CD8-EpCAM nearest neighbor distances")
plotPCA(vsdLimmaCor[ , grep("CD45", colnames(vsdLimmaCor))], "MHEpCAMcut")+ggtitle("CD8-EpCAM MH index")
```

Note that the vsd values will need to be normalised by batch for visualisation.

## Expression patterns by cell type

Below, we check whether the different fractions are expressing expected markers 

The cell types are:

* Red: Cd45
* Epcam: green 
* DN:blue

```{r Ext3d, fig.cap="Ext3d PCA plot"}
Xa=c(brewer.pal(3, "Reds"), brewer.pal(3, "Blues"), brewer.pal(3, "Greens"))

a2=plotPCA(vsd[, which(vsd$Cohort%in%"Progression")], c("Growth", "Fraction"))+scale_color_manual(values=Xa[c( 3,9, 6,1, 7, 4, 2,8, 5)])+theme_bw()
a2
SaveOutput=a2$data
SaveOutput$sample=infoTableFinal$TumorIDnew[match(SaveOutput$name, rownames(infoTableFinal))]

DT::datatable(SaveOutput, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


#write.csv(SaveOutput, file="nature-tables/Ext3d.csv")
```

We can also visualise PCA plots specifically for CD45, DN or Ep samples

```{r pca-other-vis}
plotPCA(vsdLimmaCor[, which(vsdLimmaCor$Cohort%in%"Progression" & vsdLimmaCor$Fraction=="CD45")], c("Growth"))+scale_color_manual(values=c("orange", "#31A354"))+theme_bw()+ggtitle("CD45 frac by growth")
plotPCA(vsdLimmaCor[, which(vsdLimmaCor$Cohort%in%"Progression" & vsdLimmaCor$Fraction=="DN")], c("Growth"))+scale_color_manual(values=c("orange", "#31A354"))+theme_bw()+ggtitle("DN frac by growth")
plotPCA(vsdLimmaCor[, which(vsdLimmaCor$Cohort%in%"Progression" & vsdLimmaCor$Fraction=="Ep")], c("Growth"))+scale_color_manual(values=c("orange", "#31A354"))+theme_bw()+ggtitle("Ep frac by growth")
```
  
Reference Genes:

* purple: immune
* blue: epithelial
* green: stroma
* orange: myoepithelial
* red: endothelial

Below, we see that the CD45 cells separate from the Ep/DN populations have high expression of immune related genes including CD3, CD4, IFNG.

However, the DN/Ep fractions are more intermixed. The DN fraction has expression of keratins, as well as fibroblast markers (Acta1), and myeoepithelial markers (Tp63)

```{r Ext3e, fig.cap="Ext3e"}
## why doesnt this work???
Agenes=unlist(GeneListRat)

# Use the original desseq data,a nd then the limma data
x1=match(Agenes, rownames(assay(vsd)))
RatExpr2=assay(vsd)[na.omit(x1), which(vsd$Cohort=="Progression")]

RowSideCol=names(Agenes)[which(!is.na(x1))]
RowSideCol=substr(RowSideCol, 1, 3)

ColSideCol=sapply(strsplit(colnames(RatExpr2), "_"), function(x) x[length(x)])

colnames(RatExpr2)=paste(infoTableFinal$TumorIDnew[match(colnames(RatExpr2), rownames(infoTableFinal))],
                         infoTableFinal$Fraction[match(colnames(RatExpr2), rownames(infoTableFinal))])
#pdf("~/Desktop/FiguS3_celltype_markers_RNA.pdf", height = 10, width=14)

a1=heatmap.2(RatExpr2, col=RdBu[11:1], trace="none", RowSideColors = brewer.pal(6, "Set1")[factor(RowSideCol)], scale="row",  ColSideColors =brewer.pal(3, "Set1")[factor(ColSideCol)] )
```

We can also remove the CD45 fraction to see if there is a good separation between the CD45 and EPcam samples

```{r}
 a1=heatmap.2(RatExpr2[, -grep("CD45", colnames(RatExpr2))], col=RdBu[11:1], trace="none", RowSideColors = brewer.pal(6, "Set1")[factor(RowSideCol)], scale="row",
              ColSideColors =brewer.pal(3, "Set1")[factor(ColSideCol[-grep("CD45", colnames(RatExpr2))])] )


DT::datatable(RatExpr2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


 #write.csv(RatExpr2, file="nature-tables/Ext3e.csv")
 
#dev.off()
```


<!--chapter:end:04-rna-prelim.Rmd-->

# DESeq analysis: Progression/Immunotherapy cohort

This document sets up DESeq runs to compare:

* DN vs Ep samples
* growing vs stable samples (all 3 fractions)
* treatments (all 3 fractions)
* spatial patterns (cd8 or epithelial fractions)

The outputs of these analyses will be used for Gene Set Enrichment Analysis,
using MSigDB databases (c2, c5, hallmark), alongside pathways from Metacore (Process Networks, Pathway Maps)

## DN vs Ep

In section 6.2, we have noticed that some DN samples had expression of epithelial markers. Here, we perform a differential gene expression analysis to find genes which are different between these two fractions. 

Below is a summary of the number of differential genes, using p value cut off of 0.05 and log2 fold change of 1.5 and base expression of 100+.

```{r ep-v-dn, cache=T}
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction!="CD45")])
DNEpdds=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~Fraction) ## 
DNEpdds=DESeq(DNEpdds)
resDNep=results(DNEpdds, contrast=c("Fraction", "DN", "Ep"))
summary(resDNep)

vsdDNep=vst(DNEpdds)

print('significant differential genes')

resDNeprslt2=resDNep[which(resDNep$padj<0.05 & abs(resDNep$log2FoldChange)>1.5 &
                             resDNep$baseMean>100), ]
resDNeprslt2$CellMarker=ifelse(rownames(resDNeprslt2)%in%unlist(GeneListRat), 1, 0)
resDNeprslt2=resDNeprslt2[order(resDNeprslt2$CellMarker, abs(resDNeprslt2$log2FoldChange), decreasing = T), ]


DT::datatable(as.data.frame(resDNeprslt2), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

HighExprGenes=rownames(resDNeprslt2)[which(resDNeprslt2$baseMean>100 & resDNeprslt2$log2FoldChange<0) ]

colSide=factor(infoTableFinal$Fraction[ which(infoTableFinal$Fraction!="CD45" & infoTableFinal$Cohort=="Progression")])
colSide2=factor(infoTableFinal$Growth[ which(infoTableFinal$Fraction!="CD45"& infoTableFinal$Cohort=="Progression")])
colSide3=factor(infoTableFinal$Treatment[ which(infoTableFinal$Fraction!="CD45"& infoTableFinal$Cohort=="Progression")])
colSide4=cut(infoTableFinal$CD8Frac[ which(infoTableFinal$Fraction!="CD45"& infoTableFinal$Cohort=="Progression")], c(-1, 0.025, 0.05, 0.1, 1), brewer.pal(4, "Greens"))
colSide5=cut(infoTableFinal$IFEpCAM[which(infoTableFinal$Fraction!="CD45"& infoTableFinal$Cohort=="Progression")], c(-1, 0.05, 0.1, 0.15, 1), brewer.pal(4, "Greens"))

TableCols=rbind(palette()[colSide], palette()[colSide2], palette()[colSide3], as.character(colSide4), as.character(colSide5))
rownames(TableCols)=c("Fraction", "growth", "treatment", "cd8 fraction", "cd8 int. fraction")
colnames(TableCols)=colnames(assay(vsdDNep))

#pdf(sprintf("rslt/DESeq/difference_between_DN_ep_samples_%s.pdf", Sys.Date()), height=7, width=8)

t1=assay(vsdDNep)[rownames(vsdDNep)%in%unlist(GeneListRat), ]

heatmap.2(t1, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="cell type specific markers")

t2=assay(vsdDNep)[which(rownames(vsdDNep)%in%RatCosmic & rownames(vsdDNep)%in%rownames(resDNeprslt2)), ]
heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="DEG cosmic genes")

t2=assay(vsdDNep)[which( rownames(vsdDNep)%in%HighExprGenes), ]
a1=heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="Enriched in Ep genes")
#heatmap.2(t2[ ,-grep("CD45", colnames(t2))], trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide2], scale="row", main="Enriched in Ep genes")

TableCols2=TableCols[ ,a1$colInd]

colOutput=melt(TableCols2)
colOutput$Var2=factor(colOutput$Var2, levels=unique(colOutput$Var2))

#write.csv(resDNeprslt2, file=sprintf("outputs/DESeq/difference_between_DN_Ep(ref)_samples_%s.csv", Sys.Date()))
```

## No. samples in comparisons

Separate out the tables into CD45, DN and Ep fractions. 
Below, we check the number of samples in each subgroup, based on

1. Treatment
2. growth rate
3. fraction


```{r, fig.height=7}
infoTableFinal$Treatment=factor(infoTableFinal$Treatment)#[which(is.na(infoTableFinal$Treatment))]="PDL1"
infoTableFinal$SpatialManual=factor(infoTableFinal$SpatialManual)
infoTableFinal$treatA=factor(ifelse(infoTableFinal$Treatment=="Vehicle", "control", "imm"))
infoTableFinal$MHcut=factor(ifelse(infoTableFinal$MHEpCAM>=median(df.Spatial$MH.EpCAM, na.rm = T), "inf", "res"))
infoTableFinal$CD8FracCut=factor(ifelse(infoTableFinal$CD8Frac>=median(df.Spatial$CD8frac, na.rm = T), "high", "low"))
infoTableFinal$Growth=factor(infoTableFinal$Growth)

# print('number of samples for each treatment and growth rate')
# table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$Growth)

a1=table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$Growth)
par(mfrow=c(3,2))
ContTable(t(a1[ , , 1]), "growing", F, ylabL="fraction", xlabL="treatment")
ContTable(t(a1[ , , 2]), "stable", F, ylabL="fraction", xlabL="treatment")

a1=table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$MHcut)
ContTable(t(a1[ , , 1]), "infiltrating (MH)", F, ylabL="fraction", xlabL="treatment")
ContTable(t(a1[ , , 2]), "restricted (MH)", F, ylabL="fraction", xlabL="treatment")

a1=table(infoTableFinal$Fraction, infoTableFinal$Treatment, infoTableFinal$CD8FracCut)
ContTable(t(a1[ , , 1]), "CD8 low", F, ylabL="fraction", xlabL="treatment")
ContTable(t(a1[ , , 2]), "CD8 high", F, ylabL="fraction", xlabL="treatment")

```

Note that based on the above tables, there some comparisons which are slightly imbalanced:

* Note that PDL1/LY treatment with high cd8 content results in very few epithelial cells for analysis
* There are few "stable" samples for comparisons
* LY samples are overwhelmingly "infiltrating"


## Set-up cell-type specific the comparisons

Setup the following comparisons for each cell type (Separate out the tables into CD45, DN and Ep fractions)

$$ expression ~ growing + treatment + batch (exclude 1) $$ 

Compare:

1. Treatment (EpddsTreat)
2. Any immunotherapy treatment (Epdds)
3. Growth alone: (EpddsGrowth)
4. MH index: (EpddsStrMH)
5. CD8 content (EpddsCD8)

We remove genes which have 0 counts in more than half the samples, and genes which have a row sum less than $10^{(log10(mean(rowsums))-log10(sd(rowsums)))}$


```{r deseq-assoc-runs, cache=T}
# find epithelial samples
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="Ep" & !is.na(infoTableFinal$Growth))])

# 2: ep
Epdds=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~treatA+factor(Batch))
a1x=rowSums(counts(Epdds))
a1b=apply(counts(Epdds), 1, function(c) sum(c!=0))
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(Epdds))>10^sd1vals)
keep2=which(apply(counts(Epdds), 1, function(c) sum(c!=0))> (ncol(Epdds)/2))
Epdds=Epdds[intersect(keep, keep2), ]
Epdds=DESeq(Epdds)
# 1: ep
EpddsTreat=Epdds
design(EpddsTreat)=~Treatment+factor(Batch)
EpddsTreat=DESeq(EpddsTreat)
# 3. ep
EpddsGrowth=Epdds
design(EpddsGrowth)=~Growth+factor(Batch)  ## error is here!
EpddsGrowth=DESeq(EpddsGrowth)
# 4. ep
EpddsStrMH=Epdds[ ,which(!is.na(Epdds$MHcut))]
design(EpddsStrMH)=~MHcut+factor(Batch)
EpddsStrMH=DESeq(EpddsStrMH)
# 5.ep
Epddscd8=Epdds[ ,which(!is.na(Epdds$CD8FracCut))]
design(Epddscd8)=~CD8FracCut+factor(Batch)
Epddscd8=DESeq(Epddscd8)

#R1=results(EpddsTreatG, contrast = list(c("Treatment_LY_vs_Vehicle", "Growthgrowing")))
## CD45 samples

cdidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="CD45" & !is.na(infoTableFinal$Growth))])
CDdds=DESeqDataSetFromMatrix(allstarFinal[ ,cdidx], infoTableFinal[cdidx, ], design=~treatA+factor(Batch)) ## change class
a1x=rowSums(counts(CDdds))
a1b=apply(counts(CDdds), 1, function(c) sum(c!=0))
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(CDdds))>10^sd1vals)
keep2=which(apply(counts(CDdds), 1, function(c) sum(c!=0))> (ncol(CDdds)/2))
CDdds=CDdds[intersect(keep, keep2), ]
#1. CD45
CDdds=DESeq(CDdds)
#2, CD45
CDddsTreat=CDdds
design(CDddsTreat)=~Treatment+factor(Batch)
CDddsTreat=DESeq(CDddsTreat)

# 3. Cd45
CDddsGrowth=CDdds
design(CDddsGrowth)=~Growth+factor(Batch)
CDddsGrowth=DESeq(CDddsGrowth)
#4
CDddsStrMH=CDdds[ ,which(!is.na(CDdds$MHcut))]
design(CDddsStrMH)=~MHcut+factor(Batch)
CDddsStrMH=DESeq(CDddsStrMH)

CDddscd8=CDdds[ ,which(!is.na(CDdds$CD8FracCut))]
design(CDddscd8)=~CD8FracCut+factor(Batch)
CDddscd8=DESeq(CDddscd8)

## DN samples

DNidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression" & infoTableFinal$Fraction=="DN" & !is.na(infoTableFinal$Growth))])
DNdds=DESeqDataSetFromMatrix(allstarFinal[ ,DNidx], infoTableFinal[DNidx, ], design=~treatA+factor(Batch)) ## change class
a1x=rowSums(counts(DNdds))
a1b=apply(counts(DNdds), 1, function(c) sum(c!=0))
# par(mfrow=c(1,2))
# hist(log10(a1x+1), main="log10 total counts")
# hist((a1b+1), main="Non-zero entries")
sd1vals=median(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(DNdds))>10^sd1vals)
keep2=which(apply(counts(DNdds), 1, function(c) sum(c!=0))> (ncol(DNdds)/2))
keep=which(rowSums(counts(DNdds))>(ncol(DNdds)))
keep2=which(apply(counts(DNdds), 1, function(c) sum(c!=0))> (ncol(DNdds)/2))
DNdds=DNdds[intersect(keep, keep2), ]
DNdds=DESeq(DNdds)

DNddsTreat=DNdds
design(DNddsTreat)=~Treatment+factor(Batch)
DNddsTreat=DESeq(DNddsTreat)

DNddsGrowth=DNdds
design(DNddsGrowth)=~Growth+factor(Batch)
DNddsGrowth=DESeq(DNddsGrowth)

DNddsStrMH=DNdds[ ,which(!is.na(DNdds$MHcut))]
design(DNddsStrMH)=~MHcut+factor(Batch)
DNddsStrMH=DESeq(DNddsStrMH)

DNddscd8=DNdds[ ,which(!is.na(DNdds$CD8FracCut))]
design(DNddscd8)=~CD8FracCut+factor(Batch)
DNddscd8=DESeq(DNddscd8)

save(Epdds, EpddsTreat,CDdds, CDddsTreat, DNdds, DNddsTreat,
    EpddsGrowth, CDddsGrowth, DNddsGrowth, 
      DNddscd8,  DNddsStrMH,
     CDddscd8,  CDddsStrMH,
      Epddscd8,  EpddsStrMH,
     file=sprintf("outputs/subfraction_analysis_%s.RData", Sys.Date()))

# Alist=results(EpddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))
# Clist=results(CDddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))
# Dlist=results(DNddsSpatMan, c("SpatialManual", "Infiltrating", "restricted"))

#load("rslt/DESeq/subfraction_analysis_2020-09-29.RData")
#write.csv(a2, sprintf("rslt/DESeq/Spatial_Manual_comparison_%s.csv", Sys.Date()))
```

These comparisons are saved in the temporary outputfile `r sprintf("outputs/subfraction_analysis_%s.RData", Sys.Date())`. In each comparison, there are 
`r nrow(Epdds); nrow(CDdds); nrow(DNdds)` genes compared.

## PCA plots

Below, we look at PCA plots with information on treatment, growth, spatial patterns overlaid. 

These are separated based on cell type

### EpCAM

We see that treatment nor growth separates out these samples. Below is a pca plot of the result, we can also print out the tables for each comparison

```{r}
Epdds$cd8MH=paste(Epdds$CD8FracCut, Epdds$MHcut)

vstEp=vst(Epdds, blind=F)
#vstEp$Treatment2=ifelse(vstEp$Treatment=="Vehicle", "no", "yes")
vsdLimmaEp=vstEp
assay(vsdLimmaEp)<- limma::removeBatchEffect(assay(vsdLimmaEp),vsdLimmaEp$Batch)

plotPCA(vsdLimmaEp, c("Growth"))+scale_color_manual(values=c(ColSizeb, "#31A354"))+theme_bw()+ggtitle("Growth Ep")
a2=plotPCA(vsdLimmaEp, c("Treatment"))+theme_bw()+ggtitle("Treatment Ep")+scale_color_manual(values=c(ColMerge[ ,1], "#5D5D5D"))
a2

DT::datatable(a2$data, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(a2$data, file="nature-tables/3i_epcam.csv")

```

### CD45

Note there is a strong batch effect: need to apply limma remove Batch Effect prior to creating PCA plots

```{r}
#CDdds$cd8MH=paste(CDdds$CD8FracCut, CDdds$MHcut)

vstCD=vst(CDdds, blind=F)
plotPCA(vstCD, "Batch")
vsdLimmaCD=vstCD

assay(vsdLimmaCD)<- limma::removeBatchEffect(assay(vsdLimmaCD),vstCD$Batch)
# library(cluster)

ax1=plotPCA(vsdLimmaCD, c("Batch"), returnData=T)
plotPCA(vsdLimmaCD, c("Growth"))+scale_color_manual(values=c(ColSizeb, "#31A354"))+theme_bw()+ggtitle("Growth CD45")
a2=plotPCA(vsdLimmaCD, c("Treatment"))+theme_bw()+ggtitle("Treatment CD45")+scale_color_manual(values=c(ColMerge[,1], "#5D5D5D"))
a2
DT::datatable(a2$data, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(a2$data, file="nature-tables/3i_cd45.csv")

```

### DN

```{r}
DNdds$cd8MH=paste(DNdds$CD8FracCut, DNdds$MHcut)

vstDN=vst(DNdds, blind=T)
vstDN$Treatment2=ifelse(vstDN$Treatment=="Vehicle", "no", "imm")

vsdLimmaDN=vstDN

assay(vsdLimmaDN)<- limma::removeBatchEffect(assay(vsdLimmaDN),vstDN$Batch)

ax1=plotPCA(vsdLimmaDN, c("Batch"), returnData=T)
plotPCA(vsdLimmaDN, c("Growth"))+scale_color_manual(values=c("orange", "#31A354"))+theme_bw()+ggtitle("Growth DN")
a2=plotPCA(vsdLimmaDN, c("Treatment"))+theme_bw()+ggtitle("Treatment DN")+scale_color_manual(values=c(ColMerge[,1], "#5D5D5D"))

DT::datatable(a2$data, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


#write.csv(a2$data, file="nature-tables/3i_dn.csv")

```

## Pearson correlation plots of samples

Below are pearson correlation plots of the samples in each comparison, colored by growth status

```{r}
Xa1=cor(assay(vsdLimmaEp))
heatmap.2(Xa1, col=RdBu[11:1], ColSideColors = ColSizeb[vstEp$Growth], trace="none", main="Ep")

DT::datatable(Xa1, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(Xa1, file="nature-tables/Ext3j.csv")


Xa1=cor(assay(vsdLimmaCD))
heatmap.2(Xa1, col=RdBu[11:1], ColSideColors = ColSizeb[vstCD$Growth], trace="none", main="CD45")
DT::datatable(Xa1, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(Xa1, file="nature-tables/FIgS2-cd45-pca-cor-plot.csv")


Xa1=cor(assay(vsdLimmaDN))
heatmap.2(Xa1, col=RdBu[11:1], ColSideColors = ColSizeb[vstDN$Growth], trace="none", main="DN")

#dev.off()
DT::datatable(Xa1, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(Xa1, file="nature-tables/DNsamples_progression_similarity.csv")
```

<!--chapter:end:05-deseqruns.Rmd-->

# Collating results and running GSEA

In this section, we combine all the comparisons together for downstream analysis, including

* number of differential genes per comparisons
* number of samples per comparison
* write the output to file (outputs/DESeq/Ep_growth_treat.xlsx)

For GSEA we

* convert rat to human symbols
* run overlap analysis if there are more than 3 hits (outputs/DESeq/HyperGeo_Ep_growth_treat.xlsx)
* run gene set enrichment analysis on all samples (outputs/DESeq/GSEA_Ep_growth_treat.xlsx)
* all outputs saved to outputs/all_differential_comparisons.RData)

An example of the code is below:

```{r, eval=F, echo=T}
hits=EpCompSig[[i]] ## list of significant genes
hits=epGenesConv[match(hits, rownames(Epdds))]
fcTab=EpComp4[[i]]$log2FoldChange
names(fcTab)=epGenesConv


  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)


```

```{r}

EpComp4=list()
EpCompSig=list()
UpDn1=matrix(NA, nrow=2, ncol=7)

#for (i in 1:2){
Eres1=results(Epdds, contrast=c("treatA", "imm", "control"))
EpComp4[[1]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
EpCompSig[[1]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
UpDn1[ ,1]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
#}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(EpddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
EpComp4[[i+1]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[i+1]]=g1
UpDn1[ ,i+1]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}

Eres5=results(EpddsGrowth, contrast=c("Growth", "stable", "growing"))
EpComp4[[5]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[5]]=g1
UpDn1[ ,5]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(EpddsStrMH, contrast=c("MHcut", "res", "inf"))
EpComp4[[6]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[6]]=g1
UpDn1[ ,6]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(Epddscd8, contrast=c("CD8FracCut", "low", "high"))
EpComp4[[7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
EpCompSig[[7]]=g1
UpDn1[ ,7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

rownames(UpDn1)=c("down", "up")
colnames(UpDn1)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(EpComp4)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(EpCompSig)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")

## write to a xls
write_xlsx(EpComp4, path=sprintf("outputs/DESeq/DGEA_Ep_growth_treat_%s.xlsx", Sys.Date()))
```


```{r run-gsea, cache=T}
#load("anntotations/Rat_biomart_gene_annotations.RData")

epGenes=rownames(Epdds)
cdGenes=rownames(CDdds)
dnGenes=rownames(DNdds)

l1=SymHum2Rat$HGNC.symbol[match(epGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(epGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(epGenes, Mouse2Hum$MGI.symbol)]
epGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, epGenes)))

l1=SymHum2Rat$HGNC.symbol[match(cdGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(cdGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(cdGenes, Mouse2Hum$MGI.symbol)]
cdGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, cdGenes)))

l1=SymHum2Rat$HGNC.symbol[match(dnGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(dnGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(dnGenes, Mouse2Hum$MGI.symbol)]
dnGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, dnGenes)))

```


```{r}
load("../anntotations/ListofGeneSets2.RData")
```

```{r ep-samples-gsea, cache=T, results='hide', warning=F, message=F}
#save(ListGSC, file="anntotations/ListofGeneSets2.RData")
OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(EpComp4)*2, nrow=length(x)))
ismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
ismrB<-ismr3 

for (i in 1:length(EpComp4)){

hits=EpCompSig[[i]]
hits=epGenesConv[match(hits, rownames(Epdds))]
fcTab=EpComp4[[i]]$log2FoldChange
names(fcTab)=epGenesConv


if (length(hits)>2){
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca=GSCA(listOfGeneSetCollections=ListGSC, geneList=fcTab)
  gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(ismr3[[j]]))
  ismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}

if (length(hits)>2){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(ismrB[[j]]))
  ismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}


}

Epismr3 <- lapply(ismr3, function(x){ colnames(x)<- paste(rep(names(EpComp4), each=2), c("NES", "padj")); x})
names(Epismr3)=names(ListGSC)
Epismr3<-lapply(Epismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(Epismr3, path=sprintf("outputs/DESeq/GSEA_Ep_growth_treat_%s.xlsx", Sys.Date()))

EpismrHG <- lapply( ismrB, function(x){ colnames(x)<- paste(rep(names(EpComp4), each=2), c("pval", "padj")); x})
names(EpismrHG)=names(ListGSC)
EpismrHG<-lapply(EpismrHG, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(EpismrHG, path=sprintf("outputs/DESeq/HyperGeo_Ep_growth_treat_%s.xlsx", Sys.Date()))
```


```{r cd45-samples-gsea, results='hide', warning=F, message=F, cache=T}
#load("rslt/DESeq/Epithelial_fraction.RData")

## for treatment control: big differences here which are not replicated

CDComp4=list()
CDCompSig=list()
CDUpDn1=matrix(NA, nrow=2, ncol=7)

#for (i in 1:4){
Eres1=results(CDdds, contrast=c("treatA", "imm", "control"))
CDComp4[[1]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
CDCompSig[[1]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
CDUpDn1[ ,1]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
#}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(CDddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
CDComp4[[i+1]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[i+1]]=g1
CDUpDn1[ ,i+1]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}


Eres5=results(CDddsGrowth, contrast=c("Growth", "stable", "growing"))
CDComp4[[5]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[5]]=g1
CDUpDn1[ ,5]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(CDddsStrMH, contrast=c("MHcut", "res", "inf"))
CDComp4[[6]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[6]]=g1
CDUpDn1[ ,6]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(CDddscd8, contrast=c("CD8FracCut", "low", "high"))
CDComp4[[7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
CDCompSig[[7]]=g1
CDUpDn1[ ,7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


rownames(CDUpDn1)=c("down", "up")
colnames(CDUpDn1)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(CDComp4)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(CDCompSig)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")


## write to a xls
write_xlsx(CDComp4, path=sprintf("outputs/DESeq/CD_growth_treat_%s.xlsx", Sys.Date()))

OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(CDComp4)*2, nrow=length(x)))
CDismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
CDismrB=CDismr3
for (i in 1:length(CDComp4)){

hits=CDCompSig[[i]]
hits=cdGenesConv[match(hits, rownames(CDdds))]
fcTab=CDComp4[[i]]$log2FoldChange
names(fcTab)=cdGenesConv


if (length(hits)>3){
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(CDismr3[[j]]))
  CDismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}

if (length(hits)>3){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(CDismrB[[j]]))
  CDismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}

}

CDismr3 <- lapply(CDismr3, function(x){ colnames(x)<- paste(rep(names(CDComp4), each=2), c("NES", "padj")); x})
names(CDismr3)=names(ListGSC)
CDismr3<-lapply(CDismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(CDismr3, path=sprintf("outputs/DESeq/GSEA_CD_growth_treat.xlsx"))


CDismrB <- lapply(CDismrB, function(x){ colnames(x)<- paste(rep(names(CDComp4), each=2), c("pval", "padj")); x})
names(CDismrB)=names(ListGSC)
CDismrB<-lapply(CDismrB, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(CDismrB, path=sprintf("outputs/DESeq/HyperGeom_CD_growth_treat.xlsx"))
```


```{r dn-samples-gsea, cache=T, results='hide', warning=F, message=F}
#load("rslt/DESeq/Epithelial_fraction.RData")

DNComp4=list()
DNCompSig=list()
DNUpDn1=matrix(NA, nrow=2, ncol=7)

#for (i in 1:4){
Eres1=results(DNdds, contrast=c("treatA", "imm", "control"))
DNComp4[[1]]=as.data.frame(cbind(Gene=rownames(Eres1), Eres1))
DNCompSig[[1]]=sort(rownames(Eres1)[which(Eres1$padj<0.1)])
DNUpDn1[ ,1]=c(length(which(Eres1$padj<0.1 & Eres1$log2FoldChange<0)),
             length(which(Eres1$padj<0.1 & Eres1$log2FoldChange>0)))
#}
# for control

cList=c("PDL1+LY", "LY", "PDL1")
for (i in 1:3){
Eres5=results(DNddsTreat, contrast=c("Treatment", cList[i], "Vehicle"))
DNComp4[[i+1]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[i+1]]=g1
DNUpDn1[ ,i+1]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))
}


#
Eres5=results(DNddsGrowth, contrast=c("Growth", "stable", "growing"))
DNComp4[[5]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[5]]=g1
DNUpDn1[ ,5]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))


Eres5=results(DNddsStrMH, contrast=c("MHcut", "res", "inf"))
DNComp4[[6]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[6]]=g1
DNUpDn1[ ,6]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

Eres5=results(DNddscd8, contrast=c("CD8FracCut", "low", "high"))
DNComp4[[7]]=as.data.frame(cbind(Gene=rownames(Eres5), Eres5))
g1=sort(rownames(Eres5)[which(Eres5$padj<0.1)])
DNCompSig[[7]]=g1
DNUpDn1[ ,7]=c(length(which(Eres5$padj<0.1 & Eres5$log2FoldChange<0)),
             length(which(Eres5$padj<0.1 & Eres5$log2FoldChange>0)))

rownames(DNUpDn1)=c("down", "up")
colnames(DNUpDn1)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(DNComp4)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")
names(DNCompSig)=c("imm_vs_control", paste(cList, "_vs_Vehicle", sep=""),"stable_vs_growing", "res_vs_inf.MH",  "lo_vs_hi_cd8")



## write to a xls
write_xlsx(DNComp4, path=sprintf("outputs/DN_growth_treat_%s.xlsx", Sys.Date()))

OutputMatrix=lapply( ListGSC, function(x) matrix(NA, ncol=length(DNComp4)*2, nrow=length(x)))
DNismr3 <- lapply(1:length(OutputMatrix), function(x){ row.names(OutputMatrix[[x]])<-names(ListGSC[[x]]); OutputMatrix[[x]]})
DNismrB=DNismr3

for (i in 1:length(DNComp4)){

hits=DNCompSig[[i]]
hits=dnGenesConv[match(hits, rownames(DNdds))]
fcTab=DNComp4[[i]]$log2FoldChange
names(fcTab)=dnGenesConv

gsca=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gsca1 <- preprocess(gsca, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
if (length(hits)>0){
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = T)
}else{
  gsca2 <- analyze(gsca1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
}

for (j in 1:length(ListGSC)){
  x1=gsca2@result$GSEA.results[[j]]
  mx1=match(rownames(x1), rownames(DNismr3[[j]]))
  DNismr3[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(1, 3)])
}


if (length(hits)>2){
for (j in 1:length(ListGSC)){
  x1=gsca2@result$HyperGeo.results[[j]]
  mx1=match(rownames(x1), rownames(DNismrB[[j]]))
  DNismrB[[j]][ mx1,(2*i-1):(2*i)]=data.matrix(x1[, c(6, 7)])
}}


}

DNismr3 <- lapply(DNismr3, function(x){ colnames(x)<- paste(rep(names(DNComp4), each=2), c("NES", "padj")); x})
names(DNismr3)=names(ListGSC)
DNismr3<-lapply(DNismr3, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(DNismr3, path=sprintf("outputs/GSEA_DN_growth_treat.xlsx"))

DNismrB <- lapply(DNismrB, function(x){ colnames(x)<- paste(rep(names(DNComp4), each=2), c("pval", "padj")); x})
names(DNismrB)=names(ListGSC)
DNismrB<-lapply(DNismrB, function(x) as.data.frame(cbind(GeneSet=rownames(x), x)))
write_xlsx(DNismrB, path=sprintf("outputs/DESeq/HyperGeom_DN_growth_treat.xlsx"))


save(DNComp4, EpComp4, CDComp4, DNismr3,Epismr3, CDismr3,DNismrB, EpismrHG, CDismrB,
     DNCompSig, EpCompSig, CDCompSig, UpDn1, CDUpDn1, DNUpDn1, file=sprintf("outputs/all_differential_comparisons_%s.RData", Sys.Date()))
```


```{r, eval=F}
## Pathway: PDL1+LY vs vehicle


dneg1=as.numeric(DNismr3$ProcessNetworks$`PDL1+LY_vs_Vehicle NES`[which(DNismr3$ProcessNetworks$`PDL1+LY_vs_Vehicle padj`<0.05)])
names(dneg1)=rownames(DNismr3$ProcessNetworks)[which(DNismr3$ProcessNetworks$`PDL1+LY_vs_Vehicle padj`<0.05)]

par(oma=c(5,2, 1, 1))
barplot(sort(dneg1), las=2)

xx2=sapply(c("Cell adhesion", "Proteolysis", "Autophagy", "Inflammation",
             "Development"), function(x) grep(x, names(dneg1)))

barplot(sort(dneg1[unlist(xx2)]), las=2)
```

<!--chapter:end:06-GSEArun.Rmd-->

# ER/Pgr Subtyping

In this section, we will look at whether there are differences in rat subtype by:

* creating a list of specific markers of interest 
* applying PAM clsutering (partitioning around medoids)

As the DN samples do have keratin expression, we will also try to determine the subtypes in these samples too.

In the below analyses, we will conduct this subtyping as follows:

* progression specific epithelial cohort
* characterisation specific epithelial cohort
* dn specific cohort (progression)

## Gene List

We will assess clustering using two different lists. A. is a more comprehensive list containing epithelial, mesenchymal markers and proliferation markers, B. has a more narrow list of subtype specific markers

a. 'Ar', 'Cd24', 'Cdh1', 'Foxa1', 'Gata3', 'Krt8', 'Krt18', 'Krt5', 'Vim', 'Erbb2', 'Esr1', 'Pgr', 'Mki67', 'Pcna'
b. 'Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr'

## Progression cohort

We will be using variance stabilised counts in this section.

Firstly, we will look at the progression cohort. Note that the overlap between the two gene-sets are similar, and the heatmap is row-scaled. 

```{r}
Markers1=c('Ar', 'Cd24', 'Cdh1', 'Foxa1', 'Gata3', 'Krt8', 'Krt18', 'Krt5', 'Vim', 'Erbb2', 'Esr1', 'Pgr', 'Mki67', 'Pcna')
Markers2=c('Ar', 'Foxa1', 'Gata3', 'Erbb2', 'Esr1', 'Pgr')
# Progression cohort
Ax1a=assay(vstEp)[ match(Markers1, rownames(assay(vstEp))),]
Ax2a=assay(vstEp)[ match(Markers2, rownames(assay(vstEp))),]
Pam1=pam(t(Ax1a), 2)
Pam2=pam(t(Ax2a), 2)

par(mfrow=c(2,2))
plot(Pam1, main="List A, progression cohort")
plot(Pam2, main="List B, progression cohort")

ColA=Pam1$clustering
ColA=ifelse(ColA==1, "Basal", "Lum")
ColB=Pam2$clustering
ColB=ifelse(ColB==1, "Basal", "Lum")
```

The following shows the heatmaps using these list, using average distances in the hclustering approaches: firstly, using the longer list

```{r Ext3i, fig.cap="HR clustering"}
#colnames(Ax1a)=infoTableFinal$TumorIDnew[match(colnames(Ax1a), rownames(infoTableFinal))]

#hclust.ave <- function(x) hclust(x, method="average")
ax1=heatmap.2(Ax1a, trace="none", hclustfun = hclust.ave, col=brewer.pal(11, "RdBu")[11:1], scale="row", main="narrow list", ColSideColors = c("red", "blue")[factor(ColA)])
```

and now using the shorter list

```{r}
ax1=heatmap.2(Ax2a, trace="none", hclustfun = hclust.ave, col=brewer.pal(11, "RdBu")[11:1], scale="row", main="narrow list", ColSideColors = c("red", "blue")[factor(ColB)])

DT::datatable(ax1$carpet, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
#write.csv(ax1$carpet, file="nature-tables/Ext3i.csv")

colnames(Ax2a)=infoTableFinal$TumorIDnew[match(colnames(Ax2a), rownames(infoTableFinal))]
Cdata$HR_status=NA
Cdata$HR_status[match(colnames(Ax2a), Cdata$NewID)]=ColB
```

## Charcterisation cohort

We can perform a similar analysis to the characterisation cohort: (and save to file)

```{r}
c2=infoTableFinal$SampleID[which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort!="Progression")]

Ax1=assay(vsd)[ match(Markers1, rownames(assay(vsd))), match(c2, colnames(vsd))]
Ax2=assay(vsd)[ match(Markers2, rownames(assay(vsd))), match(c2, colnames(vsd))]

Pam3=pam(t(Ax1), 2)
Pam4=pam(t(Ax2), 2)

#plot(Pam3)
plot(Pam4, main="narrow list")

Ax1b=scale(t(Ax1))

#plot(Pam3, "extended list")
ColC=Pam3$clustering
ColC=ifelse(ColC==2, "Basal", "Lum")
ColD=Pam4$clustering
ColD=ifelse(ColD==1, "Basal", "Lum")

colnames(Ax1)=infoTableFinal$TumorIDnew[match(rownames(Ax1b), rownames(infoTableFinal))]
heatmap.2((Ax1), trace="none", hclustfun = hclust.ave, col=brewer.pal(11, "RdBu")[11:1], scale="row", ColSideColors = c("red", "blue")[factor(ColC)])
```

```{r 1f, fig.cap="HR status in characterisation cohort"}
colnames(Ax2)=infoTableFinal$TumorIDnew[match(rownames(Ax1b), rownames(infoTableFinal))]
heatmap.2((Ax2), trace="none", hclustfun = hclust.ave, col=brewer.pal(11, "RdBu")[11:1], scale="row", ColSideColors = c("red", "blue")[factor(ColD)])

DT::datatable(Ax2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(Ax2, file="nature-tables/1f.csv")
```


## DN samples

DN samples: note there is variability in DN expression of PR, Foxa1, Esr1, Ar,
Erbb2 and Gata3 shows fairly stable expression values

```{r}
Ax2=assay(vsdLimmaDN)[ match(Markers2, rownames(assay(vsdLimmaDN))),]
Pam5=pam(t(Ax2), 2)
plot(Pam5, main="extended list DN")
ColE=Pam5$clustering
ColE=ifelse(ColE==1, "Basal", "Lum")


ColE=gsub("Basal", "red", ColE)
ColE=gsub("Lum", "blue", ColE)

#pdf("~/Desktop/5X-DN-samples-HR-status.pdf", width=6, height=5)
colnames(Ax2)=infoTableFinal$TumorIDnew[match(colnames(Ax2), rownames(infoTableFinal))]
heatmap.2(Ax2, col=brewer.pal(11, "RdBu")[11:1], ColSideColors =ColE,scale="row", main="DN samples vsd marker list1", trace="none", hclustfun = hclust.ave)
```



## Comparison with staining

We can collate these different scores and assess whether there are similarities with PgR and ER staining:

```{r, eval=T}
## match to infoTable here

# Contingency Tables
par(mfrow=c(1,2))
a1=table(Cdata$HR_status, Cdata$PgR.IF)
ContTable(a1[ ,-2], "Pgr Expr", T, "Pgr IF", "compressed subtype")

# Contingency Tables
a1=table(Cdata$HR_status, Cdata$ER.IF)
ContTable(a1[ ,-2], "ER Expr", T, "ER IF", "compressed subtype")


```


## Summary of expression markers for each subtype/cell fraction

We can pull out the main markers of interest: ER, PGR, Erbb2 and Ki67 (or PCNA). 
We also compare these expression distribution of these markers to CD45, DN and Ep overall:

Notes:

* Pgr highest in luminal samples
* Esr1 dynamic range is lower
* Ar is higher in basal samples
* Pcna is higher in Basal

```{r}
gList=c("Esr1", "Pgr", "Erbb2", "Ar", "Pcna", "Mki67", "Acta2", "Epcam", "Krt18")


summ4=table(infoTableFinal$Fraction)

#pdf("~/Desktop/FigS3-plot-gene-of-interest-average-expression.pdf", height=8, width=8)

par(mfrow=c(2,3))
for (i in gList){
boxplot(allTPMFinal[i, ]~infoTableFinal$Fraction, main=i,  names=paste(names(summ4)," N=",summ4, sep=""), las=2, ylab=i, xlab="")
}

#dev.off()
```


# Expression in Specific pathways

The above plots suggest that there could be a different in growing and stable based on:

* inflammation
* Kras signalling
* MHC presentation
* checkpoint proteins

We can pull out the genes in these sets and visualise the relative expression in a heatmap in the DN, CD45 and Ep samples:

Note that red is growing and green is stable

```{r}
# library(org.Hs.eg.db)
load("../anntotations/ListofGeneSets.RData")

SetNamesc2=names(PathInc2) #names(ListGSC$c2List)
x1=grep("MHC", SetNamesc2)
GeneNames=unique(unlist(geneIds(PathInc2[x1[c(1, 4,5)]])))

#test1=mapIds(org.Hs.eg.db, GeneNames, 'SYMBOL','ENTREZID')
RatGeneNamesMHC=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

#RatGeneNamesKras=mapIds(org.Hs.eg.db, ListGSC$Hallmark$HALLMARK_KRAS_SIGNALING_UP, 'SYMBOL','ENTREZID')
GeneNames=unlist(geneIds(PathInH["HALLMARK_KRAS_SIGNALING_UP"]))
RatGeneNamesKras=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

GeneNames=unlist(geneIds(PathInH["HALLMARK_INFLAMMATORY_RESPONSE"]))
RatGeneNamesInf=na.omit(unique(SymHum2Rat$RGD.symbol[match(GeneNames, SymHum2Rat$HGNC.symbol)]))

CheckpointProt=unlist(ImmSuppAPC)
RatGeneNamesCheckpoint=na.omit(unique(SymHum2Rat$RGD.symbol[match(CheckpointProt, SymHum2Rat$HGNC.symbol)]))
```

#### DN samples:

Note the distribution of growing/stable in DN is: `r table(DNdds$Growth)`

```{r}
ColsideColsC=hue_pal()(2)[DNdds$Growth]

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesMHC, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesKras, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesInf, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstDN)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstDN)[na.omit(match(MHCPres2Rat, rownames(vstDN))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```

#### CD45 samples:

Note the distribution of growing/stable in CD is: `r table(CDdds$Growth)`


```{r}
ColsideColsC=hue_pal()(2)[CDdds$Growth]

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesMHC, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesKras, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesInf, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstCD)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstCD)[na.omit(match(MHCPres2Rat, rownames(vstCD))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```

#### Epithelial samples:

```{r}
ColsideColsC=hue_pal()(2)[Epdds$Growth]

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesMHC, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC expression")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesKras, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Kras expression")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesInf, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="Inflammatory response")

heatmap.2(assay(vstEp)[na.omit(match(RatGeneNamesCheckpoint, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="checkpoint proteins")

heatmap.2(assay(vstEp)[na.omit(match(MHCPres2Rat, rownames(vstEp))), ], col=RdBu[11:1], trace="none", scale="row", ColSideColors = ColsideColsC, main="MHC proteins")
```



<!--chapter:end:06A-Subtype.Rmd-->

# DESeq analysis: Immunotherapy/Growth comparisons

## Summary of comparisons

Quick plot of the differences in number of differential genes:

```{r}
Allchanges=rbind(UpDn1, CDUpDn1, DNUpDn1)
Allchanges=cbind(Allchanges, Frac=c("Ep", "Ep", "CD", "CD", "DN", "DN"), dir=rownames(Allchanges))

AllchangesB=melt(as.data.frame(Allchanges), id.vars = c("Frac", "dir"))

ggplot(AllchangesB, aes(x=variable, y=as.numeric(value), fill=dir))+geom_bar(stat="identity",position = "dodge")+facet_grid(Frac~., scale="free_y", space="free_y")+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ylab("No. differential genes")+ggtitle("number of differential genes")+scale_y_log10()
## plot the number of samples in each comparison
```

Notes:

Comparison Type | Main cell type impacted
----------------|-----------------------
Treatment | CD45+, PDL1+LY in the DN, LY may affect Ep
growth | Ep and CD45
growth in control | CD and DN
Spatial Patterns | CD45, Ep
Spatial, high cd8 | all cases


## DESeq: immunotherapy

What are the differential genes if we compare 
1. All immunotherapy vs the control arm?
2. all pairwise comparisons: (each immunotherapy to the control arm?)

First look at the epithelial fraction:

```{r}
# EpddsTreatB=EpddsTreat
# design(EpddsTreatB)=~treatA+factor(Batch)
# EpddsTreatB=DESeq(EpddsTreatB)

epr=results(Epdds)
Xa1=epr[which(epr$padj<0.05 & epr$baseMean>60), ]

epvsd=vst(Epdds)
assay(epvsd)<- limma::removeBatchEffect(assay(epvsd),factor(epvsd$Batch))


Mat2=epvsd[match(rownames(Xa1), rownames(epvsd)), ]

colSCols=ColMerge[ ,1][Mat2$Treatment]

heatmap.2(assay(Mat2), ColSideColors = colSCols, trace="none", scale="row", col=RdBu[11:1], hclustfun = hclust.ave)

DT::datatable(as.data.frame(epr), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

## all pairwise comparisons:
ax1=results(EpddsTreat, c("Treatment", "LY", "Vehicle"))
bx1=results(EpddsTreat, c("Treatment", "PDL1", "Vehicle"))
cx1=results(EpddsTreat, c("Treatment", "PDL1+LY", "Vehicle"))

testout=cbind(ax1, bx1, cx1)
DT::datatable(as.data.frame(testout), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


```

DN: two data tables are shown: first is any immunotherapy vs the vechicle.
The second shows all pairwise comparisons in the order LY, PDL1, combo 

```{r}
xcellgenes=readxl::read_xlsx("../anntotations/xcell_genes.xlsx", sheet=1)
AllGenes=as.vector(xcellgenes[ ,-c(1:2)])
AllGenes=firstup(tolower(unique(as.character(unlist(AllGenes)))))

#rm list
rmList=c("15L_B_DN", "6R_B_DN", "10L_C_DN", "6R_D_DN")

DNr=results(DNdds)
Xa1=DNr[which(DNr$padj<0.05 & DNr$baseMean>100 & abs(DNr$log2FoldChange)>1.5), ]

# DNvsd=vst(DNddsTreatB)
# assay(DNvsd)<- limma::removeBatchEffect(assay(DNvsd),factor(DNvsd$Batch))
AllG2=rownames(Xa1)[which(rownames(Xa1)%in%c(AllGenes, "Il6"))]

Mat2=vsdLimmaDN[match(AllG2, rownames(vsdLimmaDN)), ]
colnames(Mat2)=Cdata$NewID[match(substr(colnames(Mat2),1 , nchar(colnames(Mat2))-3), Cdata$TumorID)]

colSCols=ColMerge[ ,1][Mat2$Treatment]

heatmap.2(assay(Mat2), ColSideColors = colSCols, trace="none", scale="row", col=RdBu[11:1])

DT::datatable(as.data.frame(DNr), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(DNr, file="nature-tables/Supp2_DN_io_vs_non_io.csv")

ax1=results(DNddsTreat, c("Treatment", "LY", "Vehicle"))
bx1=results(DNddsTreat, c("Treatment", "PDL1", "Vehicle"))
cx1=results(DNddsTreat, c("Treatment", "PDL1+LY", "Vehicle"))

testout=cbind(ax1, bx1, cx1)
DT::datatable(as.data.frame(testout), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(testout, file="nature-tables/Supp3_dn_all_pairwise_treatments.csv")


```

CD45: three data tables are shown: 
first are values used in the heatmap
second is any immunotherapy vs the vechicle.
third shows all pairwise comparisons in the order LY, PDL1, combo 

```{r 3j, fig.cap="CD45 IO vs non-IO"}
# CDddsTreatB=CDddsTreat
# design(CDddsTreatB)=~treatA
# CDddsTreatB=DESeq(CDddsTreatB)

CDr=results(CDdds)
Xa1=CDr[which(CDr$padj<0.05 & CDr$baseMean>100 & abs(CDr$log2FoldChange)>1.5), ]

AllG2=rownames(Xa1)[which(rownames(Xa1)%in%RatAllImm)]

Mat2=vsdLimmaCD[match(AllG2, rownames(vsdLimmaCD)), ]
colnames(Mat2)=Cdata$NewID[match(substr(colnames(Mat2),1 , nchar(colnames(Mat2))-5), Cdata$TumorID)]

colSCols=ColMerge[ ,1][Mat2$Treatment]

#pdf("figure-outputs/FIgure3j_1_vs_all.pdf", height=7, width=6)

heatmap.2(assay(Mat2), ColSideColors = colSCols, trace="none", scale="row", col=RdBu[11:1],
          hclustfun = hclust.ave)

#dev.off()
#DT::datatable(as.data.frame(Mat2), rownames=F, class='cell-border stripe',
#          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(assay(Mat2), file="nature-tables/Figure3j_1_vs_all.csv")

DT::datatable(as.data.frame(CDr), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


#write.csv(CDr, file="nature-tables/Supp3_cd45_io_vs_nonio.csv")
```

```{r 3jb, fig.cap="IO vs any other treatment"}
## ALSO LOOK AT the pairwise comparisons and pull out those genes
ax1=results(CDddsTreat, c("Treatment", "LY", "Vehicle"))
bx1=results(CDddsTreat, c("Treatment", "PDL1", "Vehicle"))
cx1=results(CDddsTreat, c("Treatment", "PDL1+LY", "Vehicle"))
xa=rownames(ax1)
xb=rownames(bx1)
xc=rownames(cx1)

G1=rownames(ax1)[which(ax1$baseMean>100 & ax1$padj<0.05 & abs(ax1$log2FoldChange)>2)]
G2=rownames(bx1)[which(bx1$baseMean>100 & bx1$padj<0.05 & abs(bx1$log2FoldChange)>2)]
G3=rownames(cx1)[which(cx1$baseMean>100 & cx1$padj<0.05 & abs(cx1$log2FoldChange)>2)]

AllG=unique(c(G1, G2, G3))

AllG2=AllG[which(AllG%in%RatAllImm)]

Mat2=vsdLimmaCD[match(AllG2, rownames(vsdLimmaCD)), ]
colnames(Mat2)=Cdata$NewID[match(substr(colnames(Mat2),1 , nchar(colnames(Mat2))-5), Cdata$TumorID)]

colSCols=ColMerge[ ,1][Mat2$Treatment]
#pdf("figure-outputs/FIgure3j_all_comparisons.pdf", height=9, width=6)

heatmap.2(assay(Mat2), ColSideColors = colSCols, trace="none", scale="row", col=RdBu[11:1], hclustfun = hclust.ave)
#dev.off()

testout=cbind(ax1, bx1, cx1)

DT::datatable(as.data.frame(testout), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


#write.csv(testout, file="nature-tables/Supp3_cd45_all_pairwise_treatments.csv")
```


## Growing vs stable emphasis

Below, we focus specifically on the growing vs stable comparison in greater depth.
Here, we look at the 3 different fractions in greater depth and look at volcano plots of DEG and heatmaps of differential genes. Samples are colored according to whether they are growing or stable

### DN fraction

```{r}

#pdf(sprintf("rslt/DESeq/volcano_plots_differences_stable_vs_growing_%s.pdf", Sys.Date()), height=7, width=8)

DNa1=DNComp4$stable_vs_growing
DNa=DNComp4$stable_vs_growing[ which(DNComp4$stable_vs_growing$padj<0.1 & DNComp4$stable_vs_growing$baseMean>50 & abs(DNComp4$stable_vs_growing$log2FoldChange)>1.5), ]
with(DNa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: DN Stable (+) vs Growing (-)", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(DNa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(DNa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.05, Gene, pch=20, col="red", cex=0.75))


heatmap.2(assay(vstDN)[ DNa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstDN$Growth)), col=RdBu[11:1], main="DN genes")

DT::datatable(as.data.frame(DNa1), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'),scrollX=T))

#write.csv(DNa1, file="nature-tables/Supp_2_DEG_DN_growing_stable.csv")
```

### CD fraction

Volcano plot
```{r 4g, fig.cap="volcano plot of DEG stable vs growing CD45"}

#pdf("~/Desktop/Figure4G_CD_stable_growing.pdf", height=12, width=12)
CDa1=CDComp4$stable_vs_growing
CDa=CDComp4$stable_vs_growing[ which(CDComp4$stable_vs_growing$padj<0.05 & CDComp4$stable_vs_growing$baseMean>100 & abs(CDComp4$stable_vs_growing$log2FoldChange)>2), ]
with(CDa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: CD Stable (+) vs Growing (-)", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(CDa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(CDa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.05, Gene, pch=20, col="red", cex=0.75))

#write.csv(CDa1, file="nature-tables/4g.csv")

DT::datatable(as.data.frame(CDa1), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Here are a bunch of heatmaps, which are then separated by wehther genes are downregulated (growing specific) or upregulated (stable specific)

```{r }
heatmap.2(assay(vstCD)[ CDa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstCD$Growth)), col=RdBu[11:1], main="CD genes")

## growing specific
CDg=CDa$Gene[which(CDa$log2FoldChange<0)]
heatmap.2(assay(vstCD)[CDg, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstCD$Growth)), col=RdBu[11:1], main="CD genes growing")

## stable specific
CDs=CDa$Gene[which(CDa$log2FoldChange>0)]
heatmap.2(assay(vstCD)[CDs, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstCD$Growth)), col=RdBu[11:1], main="CD genes stable")

#dev.off()
```

### Ep Fraction

```{r}
Epa1=EpComp4$stable_vs_growing
Epa=EpComp4$stable_vs_growing[ which(EpComp4$stable_vs_growing$padj<0.1 & EpComp4$stable_vs_growing$baseMean>50 & abs(EpComp4$stable_vs_growing$log2FoldChange)>1.5), ]
with(Epa1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: Ep Stable vs Growing", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(Epa1, padj<0.1 & abs(log2FoldChange)>1.5), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
with(subset(Epa1, padj<0.1 & abs(log2FoldChange)>1.5), text(log2FoldChange+0.05, -log10(padj)+0.1, Gene, pch=20, col="red", cex=0.75))

heatmap.2(assay(vstEp)[ Epa$Gene, ], scale="row", trace="none", ColSideColors = as.character(as.numeric(vstEp$Growth)), col=RdBu[11:1], main="Ep genes")

#write.csv(Epa1, file="nature-tables/Supp_2_DEG_Ep_growing_stable.csv")

DT::datatable(as.data.frame(Epa1), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```



<!--chapter:end:07-deseqoutputs.Rmd-->

# Summary of GSEA runs

## Stable vs growing: all samples

Below is a summary of growing vs stable comparisons using Process Networks:

```{r 5a, fig.cap="GSEA summary stable growing"}
d1=DNismr3$ProcessNetworks[, c("stable_vs_growing NES", "stable_vs_growing padj")]
e1=Epismr3$ProcessNetworks[, c("stable_vs_growing NES", "stable_vs_growing padj")]
c1=CDismr3$ProcessNetworks[, c("stable_vs_growing NES", "stable_vs_growing padj")]
#
ds=which(d1[ ,2]<0.05)
es=which(e1[ ,2]<0.05)
cs=which(c1[ ,2]<0.05)

AUnique=c(rownames(d1)[ds], rownames(e1)[es], rownames(c1)[cs])
xalist=unique(AUnique)

tx=cbind(as.numeric(d1[match(xalist, rownames(d1)), 1]),as.numeric(e1[match(xalist, rownames(e1)), 1]),
         as.numeric(c1[match(xalist, rownames(c1)), 1]))
tx2=cbind(as.numeric(d1[match(xalist, rownames(d1)), 2]),as.numeric(e1[match(xalist, rownames(e1)), 2]),
         as.numeric(c1[match(xalist, rownames(c1)), 2]))
tx[which(tx2>0.1, arr.ind = T)]=0
rownames(tx)=substr(xalist, 2, 100)
txb=sapply(strsplit(rownames(tx), "_"), function(x) x[1])
rCol=c(brewer.pal(12, "Set3"), brewer.pal(8, "Set2"))[factor(txb)]
colnames(tx)=c("DN", "Ep", "CD")


#pdf("~/Desktop/5A-summary-pathways-process-networks.pdf", height=9, width=4)
par(oma=c(1, 1, 1, 5))
ax=heatmap.2(tx, col=RdBu[11:1], trace = "none", scale = "none", RowSideColors = rCol)
## re-order this?
axb=ax$carpet
an2=c(brewer.pal(12, "Set3"), brewer.pal(8, "Set2"))[factor(sapply(strsplit(colnames(axb), "_"), function(x) x[1]))]
colnames(axb)=sapply(strsplit(colnames(axb), "_"), function(x) x[length(x)])
rOrd=order(an2)
```



```{r 5a-part2}
par(oma=c(1, 1, 1, 5))
heatmap.2(t(axb[, rOrd]), col=RdBu[11:1], trace = "none", scale = "none", RowSideColors = an2[rOrd],
             Rowv = NA, main="stable red, growing blue")
#dev.off()

d1$names=rownames(d1)
e1$names=rownames(e1)
c1$names=rownames(c1)

All1=merge(d1, e1, by.x="names", by.y="names", all=T)
All2=merge(All1, c1, by.x="names", by.y="names", all=T)

#write.csv(tx, file="nature-tables/5a.csv")
#write.csv(t(axb[, rOrd]), file="nature-tables/5a_version2.csv")

DT::datatable(All2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```


### barplots of enriched pathways

Below are the bar-plots for the enriched pathways in CD45 cells:

```{r 4h, fig.cap="CD45 cells enriched pathways"}
termA=c1[cs, ]

TermsA=sapply(strsplit(rownames(termA), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(termA)[which(is.na(TermsA))], 2, 50)

sigTerms=TermsA
TermType=substr(sapply(strsplit(rownames(termA), "_"), function(x) x[1]), 2, 40)

## check whether this runs:

TermType[which(TermType=="Apoptosis")]="Transcription"
TermType[which(TermType=="Proliferation")]="Transcription"
TermType[which(TermType=="Translation")]="Transcription"
testType=c("Inflammation", "Immune response", "Transcription")

#pdf("~/Desktop/4H-growing(-ve)-vs-stable(+ve)-CD45.pdf", height=8, width=8)
par(oma=c(2, 5, 0,0), mfrow=c(2,2))
for (i in testType){
  barplot(as.numeric(termA[which(TermType==i), 1]), names.arg = sigTerms[which(TermType==i)], horiz = T, las=2,
          xlab="NES", main=testType, col=factor(sign(as.numeric(termA[which(TermType==i), 1]))))
}

Ntab=data.frame(TermType=TermType, sigTerm=sigTerms, termA)
#write.csv(Ntab, file="nature-tables/4h.csv")

DT::datatable(Ntab, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```


## Comparisons based on treatment

We can do the same analysis for the DN compartment, but for comparing treatment effect:

```{r Ext3h, fig.cap="DN assoc treatment GSEA"}

d1=DNismr3$ProcessNetworks[, c("imm_vs_control NES", "imm_vs_control padj")]
ds=which(d1[ ,2]<0.05)

termA=d1[ds, ]

TermsA=sapply(strsplit(rownames(termA), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(termA)[which(is.na(TermsA))], 2, 50)

sigTerms=TermsA
TermType=substr(sapply(strsplit(rownames(termA), "_"), function(x) x[1]), 2, 40)

## check whether this runs:

barplot(as.numeric(termA[, 1]), names.arg = sigTerms, horiz = T, las=2,
         xlab="NES", main=testType, col=factor(sign(as.numeric(termA[, 1]))))

Ntab=data.frame(TermType=TermType, sigTerm=sigTerms, termA)

#write.csv(Ntab, file="nature-tables/Ext3h.csv")
DT::datatable(Ntab, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Also look at the output for combo treatment vs vehcile

```{r}
d1=DNismr3$ProcessNetworks[, c("PDL1+LY_vs_Vehicle NES", "PDL1+LY_vs_Vehicle padj")]
ds=which(d1[ ,2]<0.05)

termA=d1[ds, ]

TermsA=sapply(strsplit(rownames(termA), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(termA)[which(is.na(TermsA))], 2, 50)

barplot(as.numeric(termA[, 1]), names.arg = TermsA, horiz = T, las=2,
         xlab="NES", main=testType, col=factor(sign(as.numeric(termA[, 1]))))
```



## Pathways of Interest 2

Focus on:

* JAK-STAT signalling
* interferon-gamma signalling
* IL-6 signalling
* BCR pathway
* TCR pathway
* antigen presentation
* KRAS signalling?
* T helper differentiation

In DN samples:

* androgen receptor signalling?
* esr1 signalling?
* myc targets
* EMT

Perform GSVA on these pathways

```{r, warning=F, results='hide'}
load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData")

sList=PathwayMapAllComp[match(substr(rownames(e1)[es], 2, 100), names(PathwayMapAllComp))]

rNames2=SymHum2Rat$HGNC.symbol[match(rownames(allTPMFinal), SymHum2Rat$RGD.symbol)]
rNames2[which(is.na(rNames2))]=toupper(rownames(allTPMFinal)[which(is.na(rNames2))])


tpmTemp=allTPMFinal[ , match(vstEp$SampleID, colnames(allTPMFinal))]
rownames(tpmTemp)=rNames2
colnames(tpmTemp)=infoTableFinal$TumorIDnew[match(colnames(tpmTemp), rownames(infoTableFinal))]


gsva1=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva1), function(x) sd(gsva1[x, ]))
a1=which(nx2>0.03)

sList=PathwayMapAllComp[match(substr(rownames(d1)[ds], 2, 100), names(PathwayMapAllComp))]

tpmTemp=allTPMFinal[ , match(vstDN$SampleID, colnames(allTPMFinal))]
colnames(tpmTemp)=infoTableFinal$TumorIDnew[match(colnames(tpmTemp), rownames(infoTableFinal))]
rownames(tpmTemp)=rNames2

gsva2=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva2), function(x) sd(gsva2[x, ]))
a2=which(nx2>0.03)

sList=PathwayMapAllComp[match(substr(rownames(c1)[cs], 2, 100), names(PathwayMapAllComp))]

tpmTemp=allTPMFinal[ , match(vstCD$SampleID, colnames(allTPMFinal))]
colnames(tpmTemp)=infoTableFinal$TumorIDnew[match(colnames(tpmTemp), rownames(infoTableFinal))]
rownames(tpmTemp)=rNames2

gsva3=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva3), function(x) sd(gsva3[x, ]))
a3=which(nx2>0.03)

#pdf("~/Desktop/5B-ssgsea-scores.pdf", height=5, width=5)

par(oma=c(1, 1, 1, 5))
heatmap.2(gsva1[a1, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstEp$Growth],
          main="Ep")

heatmap.2(gsva2[a2, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstDN$Growth],
          main="DN")

heatmap.2(gsva3[a3, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstCD$Growth],
          main="CD")

#dev.off()

```




<!--chapter:end:08-GSEA_output_summary.Rmd-->

# Epcam+ Inflammatory vs non-inflammatory samples

## Identification of inflammatory samples

Here, look at individual enrichment scores (ssGSEA). We notice in the Epithelial samples there are 5 samples which appear to be hyperinflammatory: They have higher enrichment for TNFA, interferon signalling for example.

```{r, results='hide', message=F, warning=F}
d1=DNismr3$Hallmark[, c("stable_vs_growing NES", "stable_vs_growing padj")]
e1=Epismr3$Hallmark[, c("stable_vs_growing NES", "stable_vs_growing padj")]
c1=CDismr3$Hallmark[, c("stable_vs_growing NES", "stable_vs_growing padj")]
#
ds=which(d1[ ,2]<0.05)
es=which(e1[ ,2]<0.05)
cs=which(c1[ ,2]<0.05)

AUnique=c(rownames(d1)[ds], rownames(e1)[es], rownames(c1)[cs])
xalist=unique(AUnique)

sList=PathInH[match((rownames(e1)[es]), names(PathInH))]

tpmTemp=allTPMFinal[ , match(vstEp$SampleID, colnames(allTPMFinal))]
colnames(tpmTemp)=infoTableFinal$TumorIDnew[match(colnames(tpmTemp), rownames(infoTableFinal))]
rownames(tpmTemp)=rNames2

gsva1=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva1), function(x) sd(gsva1[x, ]))
a1=which(nx2>0.03)

sList=PathInH[match((rownames(d1)[ds]), names(PathInH))]

tpmTemp=allTPMFinal[ , match(vstDN$SampleID, colnames(allTPMFinal))]
colnames(tpmTemp)=infoTableFinal$TumorIDnew[match(colnames(tpmTemp), rownames(infoTableFinal))]
rownames(tpmTemp)=rNames2

gsva2=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva2), function(x) sd(gsva2[x, ]))
a2=which(nx2>0.03)

sList=PathInH[match((rownames(c1)[cs]), names(PathInH))]

tpmTemp=allTPMFinal[ , match(vstCD$SampleID, colnames(allTPMFinal))]
rownames(tpmTemp)=rNames2

gsva3=gsva(tpmTemp, sList, method="ssgsea", ssgsea.norm=T)

nx2=sapply(1:nrow(gsva3), function(x) sd(gsva3[x, ]))
a3=which(nx2>0.03)

#pdf("~/Desktop/5B-ssgsea-scores-hallmark-pathways.pdf", height=5, width=5)

HRstat2=Cdata$HR_status[match(vstEp$TumorID, Cdata$TumorID)]
HRstat2[which(HRstat2=="Basal")]=NA
```


Check which pathways are enriched in which specific samples:

```{r 5b, fig.cap="ssGSEA specific pathways"}
par(oma=c(1, 1, 1, 5))
# heatmap.2(gsva1[a1, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstEp$Growth],
#           main="Ep")
heatmap.2(gsva1[a1, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColMerge[ vstEp$Treatment,1],
          main="Ep")

write.csv(gsva1[a1, ], file="nature-tables/5b.csv")
```

Below are the pathways specific to cd45 and dn

```{r}
heatmap.2(gsva2[a2, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstDN$Growth],
          main="DN")

heatmap.2(gsva3[a3, ], col=RdBu[11:1], scale="none", trace="none", ColSideColors = ColSizeb[vstCD$Growth],
          main="CD")

```

## DEG: inflammatory vs non-inflammatory

What genes are different between inflammatory and non-inflammatory?

```{r Ext5c, fig.cap="Differential gene exp inflammatory vs non-inflammatory"}
Inflamm=c("11N_D_Ep", "6R_B_Ep", "8L_D_Ep", "10L_D_Ep", "3N_B_Ep")

Epdds$Inflammation="no"
Epdds$Inflammation[which(colnames(Epdds)%in%Inflamm)]="yes"
Epdds$Inflammation=factor(Epdds$Inflammation)


vstEpInf=Epdds
design(vstEpInf)=~Inflammation
vstEpInf=DESeq(vstEpInf)

vstEpInfRes=results(vstEpInf)

sigGenes=rownames(vstEpInfRes)[which(vstEpInfRes$padj<0.05 & abs(vstEpInfRes$log2FoldChange)>2.5 & 
                 vstEpInfRes$baseMean>200)]

colnames(vstEp)=infoTableFinal$TumorIDnew[match(colnames(vstEp), rownames(infoTableFinal))]

heatmap.2(assay(vstEp)[sigGenes, ], col=RdBu[11:1], trace="none", scale = "row", ColSideColors = ColSizeb[vstEpInf$Growth], hclustfun = hclust.ave)

write.csv(assay(vstEp)[sigGenes, ], file="nature-tables/Ext5c_heatmap.csc")

DT::datatable(as.data.frame(vstEpInfRes), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

There are `r length(which(sigGenes%in%RatAllImm))` genes which differentiates these two, which includes `r sigGenes[which(sigGenes%in%RatAllImm)]`.


We can also assess whether there is an association between immune infiltration. We can compare whether the non-inflammatory have differences in T-cell infiltration, mixing indices based on imaging data. Below 'no' samples are non-inflammatory and 'yes' samples are hyper-inflammatory.

```{r Ext5d, fig.cap="association signature with WSI"}
## boxplots for 
nTab=data.frame(inf=vstEpInf$Inflammation, MH=vstEpInf$MHEpCAM, cd8=vstEpInf$CD8Frac,
           knn=vstEpInf$knnEpCAM)
nTabmelt=melt(nTab, measure.vars = c("cd8", "knn", "MH"))

ggplot(data=nTabmelt, aes(x=inf, y=value))+geom_boxplot()+geom_point()+theme_bw()+facet_wrap(~variable, scale="free")

#write.csv(nTabmelt, file="nature-tables/Ext5d.csv")

Cdata$Inflammation=NA
Cdata$Inflammation=vstEpInf$Inflammation2[match(Cdata$NewID, colnames(vstEp))]

DT::datatable(nTab, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Statistics are below:

```{r Ext5d-ttest}
print('assoc with cd8')
t.test(nTab$cd8~nTab$inf)
#table(nTab$cd8, nTab$inf)
print('assoc with MH index')
t.test(nTab$MH~nTab$inf)
#table(nTab$MH,nTab$inf)
print('assoc with knn')
t.test(nTab$knn~nTab$inf)
#table(nTab$knn~nTab$inf)

```

## Finding 3 signatures for 3 branches

Below we can perform a 1 vs all analysis i.e. compare

1. growing vs the rest
2. inflammatory vs the rest
3. stable vs the rest

```{r}
#vstEpInf$Inflammation2=vstEpInf$Inflammation
vstEpInf$Inflammation2=factor(ifelse(vstEpInf$Inflammation=="yes", "inf", ifelse(vstEpInf$Growth=="growing", "grow", "stab")))


design(vstEpInf)=~Inflammation2
vstEpInf=DESeq(vstEpInf)

vstEpInfRes1=results(vstEpInf, contrast = c("Inflammation2", "stab", "inf"))
res1genes=rownames(vstEpInfRes1)[which(vstEpInfRes1$padj<0.05 & abs(vstEpInfRes1$log2FoldChange)>1.5 &
                                         vstEpInfRes1$baseMean>100)]

vstEpInfRes2=results(vstEpInf, contrast = c("Inflammation2", "stab", "grow"))
res2genes=rownames(vstEpInfRes2)[which(vstEpInfRes2$padj<0.05 & abs(vstEpInfRes2$log2FoldChange)>1.5 &
                                         vstEpInfRes2$baseMean>100)]

vstEpInfRes3=results(vstEpInf, contrast = c("Inflammation2", "grow", "inf"))
res3genes=rownames(vstEpInfRes3)[which(vstEpInfRes3$padj<0.05 & abs(vstEpInfRes3$log2FoldChange)>1.5 &
                                         vstEpInfRes3$baseMean>100)]

aUnique=c(res1genes, res2genes, res3genes)

AX1=setdiff(res2genes, res1genes)
ax2=setdiff(res3genes, res1genes)

heatmap.2(assay(vstEp)[AX1, ], col=RdBu[11:1], trace="none", scale = "row", ColSideColors = ColSizec[vstEpInf$Inflammation2], hclustfun = hclust.ave)

write.csv(assay(vstEp)[AX1, ], file="nature-tables/Ext5c.csv")

nTab=data.frame(inf=vstEpInf$Inflammation2, MH=vstEpInf$MHEpCAM, cd8=vstEpInf$CD8Frac,
           knn=vstEpInf$knnEpCAM)
nTabmelt=melt(nTab, measure.vars = c("cd8", "knn", "MH"))

ggplot(data=nTabmelt, aes(x=inf, y=value))+geom_boxplot()+geom_point()+theme_bw()+facet_wrap(~variable, scale="free")

vstOut=vst(vstEpInf)

plotPCA(vstOut, "Inflammation2")
```

We see that the growing vs stable samples are very similary overall, however, DEGs between growing and stable are also expressed in the inflammatory branch.

We can use these gene signatures to identify each branch: Below, we see the separation between the 3 groups using these genes. (note that the stable branch has no identifiable upregulated genes and is defined by the negative score of the downregulated genes:). We use ssGSEA to get a score for each sample

```{r wtf-is-this, message=F, results='hide'}
vstEpInf$Inflammation3=vstEpInf$Inflammation2
vstEpInf$Inflammation3[which(vstEpInf$Inflammation3=="stab")]="inf"
vstEpInf$Inflammation3=factor(vstEpInf$Inflammation3)
design(vstEpInf)=~(Inflammation3)
vstEpInfb=DESeq(vstEpInf)
vstEpInfRes1b=results(vstEpInfb)
res1genesGrow=rownames(vstEpInfRes1b)[which(vstEpInfRes1b$padj<0.05 & (vstEpInfRes1b$log2FoldChange)<(-1.5) &
                                         vstEpInfRes1b$baseMean>100)]
vstEpInf$Inflammation3=vstEpInf$Inflammation2
vstEpInf$Inflammation3[which(vstEpInf$Inflammation2=="grow")]="inf"
vstEpInf$Inflammation3=factor(vstEpInf$Inflammation3)
design(vstEpInf)=~(Inflammation3)
vstEpInfb=DESeq(vstEpInf)
vstEpInfRes1b=results(vstEpInfb)
res1genesStab=rownames(vstEpInfRes1b)[which(vstEpInfRes1b$padj<0.05 & (vstEpInfRes1b$log2FoldChange)<(-1.5) &
                                         vstEpInfRes1b$baseMean>100)]

vstEpInf$Inflammation3=vstEpInf$Inflammation2
vstEpInf$Inflammation3[which(vstEpInf$Inflammation2=="stab")]="grow"
vstEpInf$Inflammation3=factor(vstEpInf$Inflammation3)
design(vstEpInf)=~(Inflammation3)
vstEpInfb=DESeq(vstEpInf)
vstEpInfRes1b=results(vstEpInfb)
res1genesInf=rownames(vstEpInfRes1b)[which(vstEpInfRes1b$padj<0.05 & (vstEpInfRes1b$log2FoldChange)>(1.5) &
                                         vstEpInfRes1b$baseMean>100)]

## perform ssGSEA on these samples and see where they fit:

RatssGSEA=gsva(assay(vsdLimmaEp), 
               list(grow=res1genesGrow, inh=res1genesInf, nonstab=res1genesStab), method="ssgsea", ssgsea.norm=T)

par(mfrow=c(1,2))
plot(RatssGSEA[1, ], RatssGSEA[2, ], col=factor(vstEpInf$Inflammation2), xlab="grow score", ylab="inh score")
plot(RatssGSEA[1, ], -RatssGSEA[3, ], col=factor(vstEpInf$Inflammation2), xlab="grow score", ylab="-stab score")
RatssGSEA[3, ]=-RatssGSEA[3, ]
```

We can also overlay these signatures from ssGSEA to see how well it can predict each group:

```{r}
# plot histograms for the 3 samples:
par(mfrow=c(3,3))

for (i in 1:3){
  for (j in c("inf", "grow", "stab")){
    plot(density(RatssGSEA[i, which(vstEpInf$Inflammation2==j)]), main=paste(j, rownames(RatssGSEA)[i]), 
         xlim=c(-0.6, 0.8))
  }
}
```



GSEA for the above 3 groups?

```{r gsea-1-v-all-ep, results='hide', message=F}

l1=SymHum2Rat$HGNC.symbol[match(rownames(vstEpInfRes1), SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(rownames(vstEpInfRes1), Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(rownames(vstEpInfRes1), Mouse2Hum$MGI.symbol)]
EpGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, rownames(vstEpInfRes1))))


## run 1
hits=EpGenesConv[match(res1genes, rownames(vstEpInfRes1))]
fcTab=vstEpInfRes1$log2FoldChange
names(fcTab)=EpGenesConv
  gscaepInf1=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gscaepInf1 <- preprocess(gscaepInf1, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gscaepInf1 <- analyze(gscaepInf1, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
## run2
hits=EpGenesConv[match(res2genes, rownames(vstEpInfRes2))]
fcTab=vstEpInfRes2$log2FoldChange
names(fcTab)=EpGenesConv
gscaepInf2=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gscaepInf2 <- preprocess(gscaepInf2, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
gscaepInf2 <- analyze(gscaepInf2, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
## run3
hits=EpGenesConv[match(res3genes, rownames(vstEpInfRes3))]
fcTab=vstEpInfRes3$log2FoldChange
names(fcTab)=EpGenesConv
gscaepInf3=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
gscaepInf3 <- preprocess(gscaepInf3, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
gscaepInf3 <- analyze(gscaepInf3, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)


GSEA1=gscaepInf1@result$GSEA.results$ProcessNetworks
GSEA2=gscaepInf2@result$GSEA.results$ProcessNetworks
GSEA3=gscaepInf3@result$GSEA.results$ProcessNetworks

tempOut=cbind(GSEA1, GSEA2, GSEA3, file="nature-tables/Supp3_output_GSEA_tables_growing_stable.csv")

lx1=unique(c(rownames(GSEA1)[which(GSEA1[ ,3]<0.05)],
      rownames(GSEA2)[which(GSEA2[ ,3]<0.05)],
      rownames(GSEA3)[which(GSEA3[ ,3]<0.05)]))


Fx=cbind(GSEA1[lx1, 1], GSEA3[lx1, 1], GSEA2[lx1, 1])
Fx2=cbind(GSEA1[lx1, 3], GSEA3[lx1, 3], GSEA2[lx1, 3])
Fx[which(Fx2>0.05, arr.ind=T)]=0

rownames(Fx)=lx1
colnames(Fx)=c("s/i", "g/i", "s/g")


ltest=which(rowSums(sign(abs(Fx)))>1)
ltest2=which(abs(Fx[,3])>0)

par(oma=c(1,1,1,5))
heatmap.2(Fx[unique(c(ltest,ltest2)), ], col=RdBu[11:1], trace="none", scale = "none", hclustfun = hclust.ave)

```


## Analyse the non-inflammatory samples

We remove all the inflammtory samples and compare differences between stable and growing here. 
Below is the volcano plot for the 

```{r Epddsinflamm, fig.cap="ep non-inflammatory comparison"}
#Remove inflammatory samples
#Also remove samples which are basal-like

Inflamm=c("11N_D_Ep", "6R_B_Ep", "8L_D_Ep", "10L_D_Ep", "3N_B_Ep") #,"2N__Ep", "15N_C_Ep", "7N_A_Ep", "8R_CU_Ep", "12L_D_Ep", "14N_D_Ep")

EpddsInflam=EpddsGrowth
EpddsInflam=EpddsInflam[, -match(Inflamm, colnames(EpddsInflam))]

EpddsInflam=DESeq(EpddsInflam)

ResA=results(EpddsInflam, contrast = c("Growth", "stable", "growing"))
ResAb=ResA[which(ResA$padj<0.05 & abs(ResA$log2FoldChange)>1.5), ]


#pdf("~/Desktop/5C-heatmap-inflamm-vs-non-inflamm-lowexpressing-included.pdf", width=8, height=12)

plot(ResA$log2FoldChange, -log10(ResA$padj), pch=20, col="black",
     main="growing (-ve) vs stable (+ve)")

text(ResAb$log2FoldChange, -log10(ResAb$padj), rownames(ResAb), col="red")

#write.csv(ResA, file="nature-tables/5f.csv")
```

Followed by the heatmap for this analysis

```{r Epddsinflamm2, fig.cap="ep non-inflammatory comparison heatmap"}
vst2=vst(EpddsInflam)

heatmap.2(assay(vst2)[match(rownames(ResAb), rownames(vst2)), ], col=RdBu[11:1], 
          ColSideColors = ColSizeb[vst2$Growth], trace="none", scale="row")

#write.csv(ResAb, file="~/Desktop/5C-growing-stable-in-non-inflammatory-Ep-lowexpressing-included.csv")
```

### GSEA

Quickly run GSEA for these samples:

```{r gsea-non-inflammatory-branch, fig.cap="5g: non inflammatory branch"}

EpGenes=rownames(ResA)

l1=SymHum2Rat$HGNC.symbol[match(EpGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(EpGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(EpGenes, Mouse2Hum$MGI.symbol)]
EpGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, EpGenes)))


hits=EpGenesConv[match(rownames(ResAb), EpGenes)]
fcTab=ResA$log2FoldChange
names(fcTab)=EpGenesConv


  gscaepInf=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gscaepInf <- preprocess(gscaepInf, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gscaepInf <- analyze(gscaepInf, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
  
A1=summarize(gscaepInf)  

PNresultsef=gscaepInf@result$GSEA.results$ProcessNetworks

TermsA=sapply(strsplit(rownames(gscaepInf@result$GSEA.results$ProcessNetworks), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(gscaepInf@result$GSEA.results$ProcessNetworks)[which(is.na(TermsA))], 2, 50)

## check whether this runs:
gscaepInf@result$GSEA.results$ProcessNetworks$Gene.Set.Term=TermsA
viewEnrichMap(gscaepInf, gscs=c("ProcessNetworks"),
              allSig = TRUE, gsNameType="term" )
#plotGSEA(gscaepInf, gscs=c("ProcessNetworks"), filepath="figure-outputs/", output="pdf")


save(gscaepInf2, file="figure-outputs/5g.Rdata") # save this file to change the color scheme
write.csv(gscaepInf@result$GSEA.results$ProcessNetworks, file="nature-tables/Ext5g_perhaps.csv")
```

We've noticed that some of the differentially expressed genes above are splicing related or epigenetic related. Could there be an association with transcriptional diversity? Below we calculate the transcriptional diversity based on rsem values

```{r Ext5j, fig.cap="Transcriptional heterogeneity"}
local.rnaseq.shannon <- function(exp.mat, pseudoNum = 0){
# calculate shannon index from transcriptome matrix
apply(exp.mat, 2, function(x){
x<-x+pseudoNum
prop<-x/sum(x)
#prop<-prop[prop>0]
shidx = -sum(prop*log(prop), na.rm=T)/log(length(prop))
shidx
})
}


Output1=local.rnaseq.shannon(allrsemFinal)
Output2=Output1[which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort=="Progression")]

tab2=data.frame(inf=vstEpInf$Inflammation2, het=Output2[-3])
ggplot(tab2, aes(x=inf, y=het))+geom_boxplot()+geom_point()+ggtitle("transcriptional heterogeneity: rsem")
wilcox.test(tab2$het[tab2$inf!="inf"]~tab2$inf[tab2$inf!="inf"])

write.csv(tab2, file="nature-tables/Ext5j_transcriptional_heterigeneity.csv")
```

## Luminal-only non-inflammtory samples samples

We removed all the basal samples and did the same comparison:

```{r EpddsLum, fig.cap="DEG non-inflamm Lum only"}
Epdds$HR=Cdata$HR_status[match(substr(colnames(Epdds), 1, nchar(colnames(Epdds))-3), Cdata$TumorID)]
vstLumOnly=Epdds[, which(Epdds$HR=="Lum")]
design(vstLumOnly)=~Growth
vstLumOnly=DESeq(vstLumOnly)
colnames(Epdds)

vstLumRes=results(vstLumOnly)
vsdLumvst=vst(vstLumOnly)

write.csv(vstLumRes, file="nature-tables/5j_lumonly_ep_growing_vs_stable.csv")
genes2=rownames(vstLumRes)[which(vstLumRes$padj<0.05 & abs(vstLumRes$log2FoldChange)>1.5 & vstLumRes$baseMean>100)]

ColSideCols=ColSizeb[vstLumOnly$Growth]
#pdf("figure-outputs/Figure5_XX_heatmap_lumonly_growing_vs_stable.pdf", height=9, width=5)

heatmap.2(assay(vsdLumvst)[ genes2,  ], scale="row", trace="none", ColSideColors = ColSideCols, col=RdBu[11:1], main="Ep genes")
#dev.off()

#write.csv(assay(vsdLumvst)[ genes2,  ], file="nature-tables/5xx_lum_only_growing_vs_stable.csv")
DT::datatable(as.data.frame(vstLumRes), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```

Quickly run GSEA for these samples:

```{r gsea-noninf-lum-branch, fig.cap="luminal non inflammatory branch"}

EpGenes=rownames(vstLumRes)

l1=SymHum2Rat$HGNC.symbol[match(EpGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(EpGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(EpGenes, Mouse2Hum$MGI.symbol)]
EpGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, EpGenes)))


hits=EpGenesConv[match(rownames(vstLumRes), EpGenes)]
fcTab=vstLumRes$log2FoldChange
names(fcTab)=EpGenesConv


  gscaepNI_lum=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gscaepNI_lum<- preprocess(gscaepNI_lum, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gscaepNI_lum <- analyze(gscaepNI_lum, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
  
A1=summarize(gscaepNI_lum)  

PNresultsef=gscaepNI_lum@result$GSEA.results$ProcessNetworks

TermsA=sapply(strsplit(rownames(gscaepNI_lum@result$GSEA.results$ProcessNetworks), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(gscaepNI_lum@result$GSEA.results$ProcessNetworks)[which(is.na(TermsA))], 2, 50)

save(gscaepNI_lum, file="figure-outputs/5xx_lumonly.Rdata") # save this file to change the colors

## check whether this runs:
gscaepNI_lum@result$GSEA.results$ProcessNetworks$Gene.Set.Term=TermsA
viewEnrichMap(gscaepNI_lum, gscs=c("ProcessNetworks"),
              allSig = TRUE, gsNameType="term" )

write.csv(gscaepNI_lum@result$GSEA.results$ProcessNetworks, file="nature-tables/5g_lum_gsea.csv")
```

<!--chapter:end:09-EpCAM_comparison_inflammatory.Rmd-->

# TCGA: Associate Epcam+ inflammatory with survival

Associate the signature with outcome in TCGA: Load in TCGA right now

```{r}
TCGArsem=read.delim("../data/TCGA/BRCA.rnaseqv2__illuminahiseq_rnaseqv2__unc_edu__Level_3__RSEM_genes_normalized__data.data.txt", sep="\t")
rownames(TCGArsem)=TCGArsem[ ,1]
TCGArsem=TCGArsem[, grep("01A", colnames(TCGArsem))]
colnames(TCGArsem)=substr(colnames(TCGArsem), 1, 12)
colnames(TCGArsem)=gsub("\\.", "-", colnames(TCGArsem))
TCGArsem=TCGArsem[-1, ]

TCGArsem2=apply(TCGArsem, 2, as.numeric)
#TCGArsem2=t(TCGArsem2)
#colnames(TCGArsem2)=colnames(TCGArsem)
#TCGArsem2=data.frame(TCGArsem2)
rownames(TCGArsem2)=rownames(TCGArsem)
rownames(TCGArsem2)=sapply(strsplit(rownames(TCGArsem2), "\\|"), function(x) x[1])
TCGArsem2=TCGArsem2[-which(rownames(TCGArsem2)=="?"), ]

load("../data/TCGA/BrClin_clinical_Nov2017.RData")

ax1=match(BrClin$Patient.ID, colnames(TCGArsem))

BrClin=BrClin[-which(is.na(ax1)), ]
TCGArsem=TCGArsem[ , na.omit(ax1)]

## load in the inflammation subtype information
ThorssData=read.xlsx("../data/TCGA/Thorsson2018_table1.xlsx",1)
```


Edit the clinical data to make sure data is censored at 60 months (5 years) and that stage is given an integer value (no 2A, 2b etc.) for easier comparisons

```{r}
#m1=match(colnames(TCGAssgsea), BrClin$Patient.ID)
BrClin$Stage=(substr(BrClin$American.Joint.Committee.on.Cancer.Tumor.Stage.Code, 2, 2))
BrClin$Stage[which(BrClin$Stage==""|BrClin$Stage=="X")]=NA

BrClin$Overall.Survival..Months.[which(BrClin$Overall.Survival..Months.>=60)]=60
BrClin$Overall.Survival.Status[which(BrClin$Overall.Survival..Months.>=60)]="LIVING"

BrClin$Disease.Free..Months.[which(BrClin$Disease.Free..Months.>=60)]=60
BrClin$Disease.Free.Status[which(BrClin$Disease.Free..Months.>=60)]="Disease Free"

```

## Associating CD74 with phenotype and outcome

The Thorsson data has pre-calculated scores for:

* immune subtypes
* leukocyte fractins
* proportion of data with coding mutations
* TCR shannon index

Z-Scale CD74 scores prior to analysis:

```{r 5d, fig.cap="CD74 assoc with patient data"}
TCGAssgsea=scale(TCGArsem2[match("CD74", rownames(TCGArsem2)), ])
m1=match(colnames(TCGArsem2), BrClin$Patient.ID)

tinfo=data.frame(pam=BrClin$PAM50[m1], OSM=BrClin$Overall.Survival..Months.[m1],
                 OSS=BrClin$Overall.Survival.Status[m1], cd74=TCGAssgsea,
                 DFS=BrClin$Disease.Free.Status[m1],
                 DFM=BrClin$Disease.Free..Months.[m1],
                 Stage=BrClin$Stage[m1])

ThorssData=ThorssData[which(ThorssData$TCGA.Study=="BRCA"), ]

n1=match(rownames(tinfo), ThorssData$TCGA.Participant.Barcode)
tinfo$immSub=ThorssData$Immune.Subtype[n1]
tinfo$leukFrac=as.numeric(ThorssData$Leukocyte.Fraction[n1])
tinfo$strFrac=as.numeric(ThorssData$Stromal.Fraction[n1])
tinfo$codingMut=as.numeric(ThorssData$Nonsilent.Mutation.Rate[n1])
tinfo$TCRshann=as.numeric(ThorssData$TCR.Shannon[n1])

par(mfrow=c(2,3))
boxplot(tinfo$cd74~tinfo$pam, ylab="gene exp", main="PAM50")
boxplot(tinfo$cd74~tinfo$immSub, ylab="gene exp", main="Immune sbtype")
ax=cor.test(tinfo$cd74, log10(tinfo$codingMut+1), method="spearman")
smoothScatter(tinfo$cd74, log10(tinfo$codingMut+1), xlab="gene exp", ylab="log10 mut")
text(4,0.5, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfo$cd74, tinfo$leukFrac, method="spearman")
smoothScatter(tinfo$cd74, (tinfo$leukFrac), xlab="gene exp", ylab="leuk frac")
text(4,0.2, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfo$cd74, tinfo$TCRshann, method="spearman")
smoothScatter(tinfo$cd74, tinfo$TCRshann, xlab="gene exp", ylab="TCR diversity")
text(4,1, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
hist(tinfo$cd74)

#write.csv(tinfo, file="nature-tables/5d-TCGA_data.csv")
```

We can also check if there is an association with survival:

```{r}

axD=Surv(tinfo$DFM, ifelse(tinfo$DFS=="Recurred/Progressed", 1, ifelse(tinfo$DFS=="DiseaseFree", 0, NA)))

axO=Surv(tinfo$OSM, ifelse(tinfo$OSS=="DECEASED", 1, ifelse(tinfo$OSS=="LIVING", 0, NA)))

SurvOSS=coxph(axO~tinfo$pam+tinfo$Stage+tinfo$cd74)
SurvDFS=coxph(axD~tinfo$pam+tinfo$Stage+tinfo$cd74)

ao=summary(SurvOSS)
ao
as=summary(SurvDFS)
as
```
Note that CD74 is associated with survival: The harzards ratio is `r ao$coefficients[5,2]` (95CI:`r ao$conf.int[ 5,3:4]`), p value `r ao$logtest[3]`. 

This means that this is associated with survival regardless of subtype. We can look at these values in forestplots

```{r 5e, fig.cap="forest plot CD74"}

data1=data.frame(X1=c("","PAM50", "", "", "", "", "Stage", "","","", "CD74"),
                X2=c("","Basal", "Her2", "LumA", "LumB", "Normal" ,"1", "2", "3", "4", ""),
                X3=c("NSamp",  table(tinfo$pam), table(tinfo$Stage), length(na.omit(tinfo$cd74))),
                X4=c("HR", "", round(summary(SurvOSS)$coefficients[ 1:4,2],2), "",
                     round(summary(SurvOSS)$coefficients[ 5:8,2],2)))

mdata=data.frame(summary(SurvOSS)$conf.int[ ,c(1,3:4)])
mdata=rbind(NA,NA, mdata[1:4, ], NA, mdata[5:8, ])

#pdf("figure-outputs/Figure5_CD74_forestplot.pdf", width=5, height=5)

forestplot(data1, mdata, xlog=T,
           boxsize=0.5)

#write.csv(cbind(data1, mdata), file="nature-tables/5e_forest_plot.csv")

DT::datatable(cbind(data1, mdata), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```





We can look below what the association with subtype is in KM curves:

```{r Ext5e-os, fig.cap="OS CD74 by subtype", fig.height=8}
par(mfrow=c(2,2))

Xind=c("Basal", "Her2", "LumA", "LumB")

for (i in Xind){
  l1=which(tinfo$pam==i)
  ax=Surv(tinfo$OSM[l1], ifelse(tinfo$OSS[l1]=="DECEASED", 1, ifelse(tinfo$OSS[l1]=="LIVING", 0, NA)))
  TCGAvalCut=cut(tinfo$cd74[l1], quantile(tinfo$cd74[l1], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax1=summary(coxph(ax~TCGAvalCut+tinfo$Stage[l1]))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "CD74 gene exp"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="OS", mark.time=T)
  text(20, 0.2, sprintf("HR:%s (%s-%s) p=%s", round(ax1$coefficients[2,2 ],2), 
                     round(ax1$conf.int[2,3 ],2), round(ax1$conf.int[2, 4],2),round(ax1$logtest[3],2)))
}
```


```{r Ext5e-dfs, fig.cap="DFS CD74 by subtype"}

par(mfrow=c(2,2))

for (i in Xind){
   l1=which(tinfo$pam==i)
  ax=Surv(tinfo$DFM[l1], ifelse(tinfo$DFS[l1]=="Recurred/Progressed", 1, ifelse(tinfo$DFS[l1]=="DiseaseFree", 0, NA)))
  TCGAvalCut=cut(tinfo$cd74[l1], quantile(tinfo$cd74[l1], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax1=summary(coxph(ax~TCGAvalCut+tinfo$Stage[l1]))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "CD74 gene exp"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="DFS", mark.time=T)
  text(20, 0.2, sprintf("HR:%s (%s-%s) p=%s", round(ax1$coefficients[2,2 ],2), 
                     round(ax1$conf.int[2,3 ],2), round(ax1$conf.int[2, 4],2),round(ax1$logtest[3],2)))
}
```

## Associating ADMATS10 with phenotype and outcome

Do the same thing as above with the ADAMST10 scores

### All samples

Z-Scale ADAMTS10 scores prior to analysis:

```{r adamst10, fig.cap="ADAMTS10 assoc with patient data"}
TCGAssgsea=scale(TCGArsem2[match("ADAMTS10", rownames(TCGArsem2)), ])
tinfo$adamts10=TCGAssgsea

#pdf("figure-outputs/Figure5_ADAMST10_output.pdf", height=7, width=9)

par(mfrow=c(2,3))
boxplot(tinfo$adamts10~tinfo$pam, ylab="gene exp", main="PAM50")
boxplot(tinfo$adamts10~tinfo$immSub, ylab="gene exp", main="Immune sbtype")
ax=cor.test(tinfo$adamts10, log10(tinfo$codingMut+1), method="spearman")
smoothScatter(tinfo$adamts10, log10(tinfo$codingMut+1), xlab="gene exp", ylab="log10 mut")
text(4,0.5, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfo$adamts10, tinfo$leukFrac, method="spearman")
smoothScatter(tinfo$adamts10, (tinfo$leukFrac), xlab="gene exp", ylab="leuk frac")
text(4,0.2, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfo$adamts10, tinfo$TCRshann, method="spearman")
smoothScatter(tinfo$adamts10, tinfo$TCRshann, xlab="gene exp", ylab="TCR diversity")
text(4,1, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
#hist(tinfo$adamts10)
ax=cor.test(tinfo$adamts10, tinfo$strFrac, method="spearman")
smoothScatter(tinfo$adamts10, (tinfo$strFrac), xlab="gene exp", ylab="str frac")
text(4,0.2, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))

DT::datatable(tinfo, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

We can also check if there is an association with survival:

```{r adamst-surv}

axD=Surv(tinfo$DFM, ifelse(tinfo$DFS=="Recurred/Progressed", 1, ifelse(tinfo$DFS=="DiseaseFree", 0, NA)))

axO=Surv(tinfo$OSM, ifelse(tinfo$OSS=="DECEASED", 1, ifelse(tinfo$OSS=="LIVING", 0, NA)))

SurvOSS=coxph(axO~tinfo$pam+tinfo$Stage+tinfo$adamts10)
SurvDFS=coxph(axD~tinfo$pam+tinfo$Stage+tinfo$adamts10)

ao=summary(SurvOSS)
ao
as=summary(SurvDFS)
as
```
Note that ADAMST10 is associated with survival: The harzards ratio is `r ao$coefficients[5,2]` (95CI:`r ao$conf.int[ 5,3:4]`), p value `r ao$logtest[3]`. 

This means that this is associated with survival regardless of subtype. We can look at these values in forestplots

```{r adamst10-forestplot, fig.cap="forest plot ADAMTS10"}

data1=data.frame(X1=c("","PAM50", "", "", "", "", "Stage", "","","", "ADAMST10"),
                X2=c("","Basal", "Her2", "LumA", "LumB", "Normal" ,"1", "2", "3", "4", ""),
                X3=c("NSamp",  table(tinfo$pam), table(tinfo$Stage), length(na.omit(tinfo$cd74))),
                X4=c("HR", "", round(summary(SurvOSS)$coefficients[ 1:4,2],2), "",
                     round(summary(SurvOSS)$coefficients[ 5:8,2],2)))

mdata=data.frame(summary(SurvOSS)$conf.int[ ,c(1,3:4)])
mdata=rbind(NA,NA, mdata[1:4, ], NA, mdata[5:8, ])

#pdf("figure-outputs/Figure5_CD74_forestplot.pdf", width=5, height=5)

forestplot(data1, mdata, xlog=T,
           boxsize=0.5)

#dev.off()
#write.csv(cbind(data1, mdata), file="nature-tables/5e_forest_plot_adamts10.csv")

DT::datatable(cbind(data1, mdata), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


```


We can look below what the association with subtype is in KM curves:

```{r Ext5e-osAD, fig.cap="OS CD74 by subtype", fig.height=8}
par(mfrow=c(2,2))

Xind=c("Basal", "Her2", "LumA", "LumB")

for (i in Xind){
  l1=which(tinfo$pam==i)
  ax=Surv(tinfo$OSM[l1], ifelse(tinfo$OSS[l1]=="DECEASED", 1, ifelse(tinfo$OSS[l1]=="LIVING", 0, NA)))
  TCGAvalCut=cut(tinfo$adamts10[l1], quantile(tinfo$adamts10[l1], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax1=summary(coxph(ax~TCGAvalCut+tinfo$Stage[l1]))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "ADAMTS10 gene exp"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="OS", mark.time=T)
  text(20, 0.2, sprintf("HR:%s (%s-%s) p=%s", round(ax1$coefficients[2,2 ],2), 
                     round(ax1$conf.int[2,3 ],2), round(ax1$conf.int[2, 4],2),round(ax1$logtest[3],2)))
}
```

```{r Ext5e-dfsAD, fig.cap="DFS ADAMTS10 by subtype", fig.height=8}

par(mfrow=c(2,2))

for (i in Xind){
   l1=which(tinfo$pam==i)
  ax=Surv(tinfo$DFM[l1], ifelse(tinfo$DFS[l1]=="Recurred/Progressed", 1, ifelse(tinfo$DFS[l1]=="DiseaseFree", 0, NA)))
  TCGAvalCut=cut(tinfo$adamts10[l1], quantile(tinfo$adamts10[l1], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax1=summary(coxph(ax~TCGAvalCut+tinfo$Stage[l1]))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "ADAMTS10 gene exp"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="DFS", mark.time=T)
  text(20, 0.2, sprintf("HR:%s (%s-%s) p=%s", round(ax1$coefficients[2,2 ],2), 
                     round(ax1$conf.int[2,3 ],2), round(ax1$conf.int[2, 4],2),round(ax1$logtest[3],2)))
}
```

### Redone using only ER cases

Redo survival and limit only to ER+ cases:

```{r}
## make a change here
tinfoER=tinfo[which(tinfo$pam%in%c("LumA", "LumB")),  ]
tinfoER$pam=factor(tinfoER$pam)

axD=Surv(tinfoER$DFM, ifelse(tinfoER$DFS=="Recurred/Progressed", 1, ifelse(tinfoER$DFS=="DiseaseFree", 0, NA)))

axO=Surv(tinfoER$OSM, ifelse(tinfoER$OSS=="DECEASED", 1, ifelse(tinfoER$OSS=="LIVING", 0, NA)))

SurvOSS=coxph(axO~tinfoER$pam+tinfoER$Stage+tinfoER$adamts10)
SurvDFS=coxph(axD~tinfoER$pam+tinfoER$Stage+tinfoER$adamts10)

ao=summary(SurvOSS)
ao
as=summary(SurvDFS)
as

```


```{r}
#pdf("figure-outputs/NEwpanelB.pdf", height=7, width=9)

par(mfrow=c(2,3))

boxplot(tinfoER$adamts10~tinfoER$pam, ylab="gene exp", main="PAM50")
boxplot(tinfoER$adamts10~tinfoER$immSub, ylab="gene exp", main="Immune sbtype")
ax=cor.test(tinfoER$adamts10, log10(tinfoER$codingMut+1), method="spearman")
smoothScatter(tinfoER$adamts10, log10(tinfoER$codingMut+1), xlab="gene exp", ylab="log10 mut")
text(4,0.5, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfoER$adamts10, tinfoER$leukFrac, method="spearman")
smoothScatter(tinfoER$adamts10, (tinfoER$leukFrac), xlab="gene exp", ylab="leuk frac")
text(4,0.2, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfoER$adamts10, tinfoER$TCRshann, method="spearman")
smoothScatter(tinfoER$adamts10, tinfoER$TCRshann, xlab="gene exp", ylab="TCR diversity")
text(4,1, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))
ax=cor.test(tinfoER$adamts10, tinfoER$strFrac, method="spearman")
smoothScatter(tinfoER$adamts10, (tinfoER$strFrac), xlab="gene exp", ylab="str frac")
text(4,0.2, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 3)))

DT::datatable(tinfoER, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Also check the forest plots

```{r Ext5f, fig.cap="Adamts10 expression survival analysis, ER only "}

data1=data.frame(X1=c("","PAM50", "",  "Stage", "","","", "ADAMST10"),
                X2=c("","LumA", "LumB" ,"1", "2", "3", "4", ""),
                X3=c("NSamp",  table(tinfoER$pam), table(tinfoER$Stage), length(na.omit(tinfoER$adamts10))),
                X4=c("HR", "", round(summary(SurvOSS)$coefficients[ 1,2],2), "",
                     round(summary(SurvOSS)$coefficients[ 2:5,2],2)))

mdata=data.frame(summary(SurvOSS)$conf.int[ ,c(1,3:4)])
mdata=rbind(NA,NA, mdata[1, ], NA, mdata[2:5, ])

#pdf("figure-outputs/Figure5_CD74_forestplot.pdf", width=5, height=5)

forestplot(data1, mdata, xlog=T,
           boxsize=0.5)

DT::datatable(cbind(data1, mdata), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```


## Signature: Lum cases non-inflammatory: growing vs stable

Here, use the signature which was applied before to see the difference between the non-inflammatory growing vs stable samples.



```{r, results='hide'}
GlistGrowing=rownames(vstLumRes)[which(vstLumRes$log2FoldChange>1.5 & vstLumRes$baseMean>100 & vstLumRes$padj<0.05 )]
Glistnon=rownames(vstLumRes)[which(vstLumRes$log2FoldChange<(-1.5) & vstLumRes$baseMean>100 & vstLumRes$padj<0.05 )]

HumGeneList=SymHum2Rat$HGNC.symbol[match(GlistGrowing, SymHum2Rat$RGD.symbol)]
HumGeneList2=Rat2Hum$HGNC.symbol[match(GlistGrowing, Rat2Hum$RGD.symbol)]

TCGAssgsea=gsva((TCGArsem2), list(grow=na.omit(HumGeneList2), 
                                                stab=Rat2Hum$HGNC.symbol[match(Glistnon, Rat2Hum$RGD.symbol)]), method="ssgsea", ssgsea.norm=F)

TCGAssgsea=t(scale(t(TCGAssgsea)))

par(mfrow=c(1,2))
hist(TCGAssgsea[1, ], main="stable")
hist(TCGAssgsea[2, ], main="growing")
plot(TCGAssgsea[1, ], TCGAssgsea[2, ], xlab="stable", ylab="growing")


write.csv("nature-tables/Supplemental_table5.csv")
```

The Growing signature genes are `r Glistnon`
and stable are `r GlistGrowing`.

Below are the survival curves for the stable signature:

```{r, fig.height=8}
#pdf("figure-outputs/Fig5_survival_analysis_Lum_samples_baseMean_greater100.pdf", height=8, width = 8)

par(mfrow=c(2,2))

Xind=c("Basal", "Her2", "LumA", "LumB")

for (i in Xind){
  l1=which(BrClin$PAM50==i)
  lx2=match(BrClin$Patient.ID[l1], colnames(TCGArsem2))
  ax=Surv(BrClin$Overall.Survival..Months.[l1], ifelse(BrClin$Overall.Survival.Status[l1]=="DECEASED", 1, ifelse(BrClin$Overall.Survival.Status[l1]=="LIVING", 0, NA)))
   axb=coxph(ax~TCGAssgsea[1, lx2]+BrClin$Stage[l1])
  axc=summary(axb)
  TCGAvalCut=cut(TCGAssgsea[1, lx2], quantile(TCGAssgsea[1, lx2], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "lum stable"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="OS", mark.time=T)
   text(10, 0, sprintf("univ. cts. var. HR=%s (%s-%s), p=%s", round(axc$coefficients[1,2], 2),
                      round(axc$conf.int[1,3],2), round(axc$conf.int[1,4],2),round(axc$logtest[3],2 )))
   legend("topleft",paste(c("L", "M", "H"), summary(TCGAvalCut)), col=brewer.pal(3, "Blues"), lwd=1,
          pch=19)
  
}


for (i in Xind){
  l1=which(BrClin$PAM50==i)
  lx2=match(BrClin$Patient.ID[l1], colnames(TCGArsem2))
  ax=Surv(BrClin$Disease.Free..Months.[l1], ifelse(BrClin$Disease.Free.Status[l1]=="Recurred/Progressed", 1, ifelse(BrClin$Disease.Free.Status[l1]=="DiseaseFree", 0, NA)))
  axb=coxph(ax~TCGAssgsea[1, lx2]+BrClin$Stage[l1])
  axc=summary(axb)
  
  TCGAvalCut=cut(TCGAssgsea[1, lx2], quantile(TCGAssgsea[1, lx2], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "lum stable"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="DFS", mark.time=T)
  text(10, 0, sprintf("univ. cts. var. HR=%s (%s-%s), p=%s", round(axc$coefficients[1,2], 2),
                      round(axc$conf.int[1,3],2), round(axc$conf.int[1,4],2),round(axc$logtest[3],2 )))
  legend("topleft",paste(c("L", "M", "H"), summary(TCGAvalCut)), col=brewer.pal(3, "Blues"), lwd=1,
          pch=19)
}


#DT::datatable(as.data.frame(test), rownames=F, class='cell-border stripe',
#         extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

The OS curves for the growing signature

```{r 5i, fig.cap="OS: growing signature", fig.height=8}
par(mfrow=c(2,2))

Xind=c("Basal", "Her2", "LumA", "LumB")

for (i in Xind){
  l1=which(BrClin$PAM50==i)
   lx2=match(BrClin$Patient.ID[l1], colnames(TCGArsem2))
  ax=Surv(BrClin$Overall.Survival..Months.[l1], ifelse(BrClin$Overall.Survival.Status[l1]=="DECEASED", 1, ifelse(BrClin$Overall.Survival.Status[l1]=="LIVING", 0, NA)))
   axb=coxph(ax~TCGAssgsea[2, lx2]+BrClin$Stage[l1])
  axc=summary(axb)
  
  TCGAvalCut=cut(TCGAssgsea[2, lx2], quantile(TCGAssgsea[2, lx2], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "lum growing"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time", ylab="OS", mark.time=T)
   text(10, 0, sprintf("univ. cts. var. HR=%s (%s-%s), p=%s", round(axc$coefficients[1,2], 2),
                      round(axc$conf.int[1,3],2), round(axc$conf.int[1,4],2),round(axc$logtest[3],2 )))
   legend("topleft",paste(c("L", "M", "H"), summary(TCGAvalCut)), col=brewer.pal(3, "Blues"), lwd=1,
          pch=19)
  
}
```

Followed by the DFS plots for this signature

```{r 5i-dfs, fig.cap="DFS forgrowing signature", fig.height=8}
par(mfrow=c(2,2))

for (i in Xind){
  l1=which(BrClin$PAM50==i)
   lx2=match(BrClin$Patient.ID[l1], colnames(TCGArsem2))
  ax=Surv(BrClin$Disease.Free..Months.[l1], ifelse(BrClin$Disease.Free.Status[l1]=="Recurred/Progressed", 1, ifelse(BrClin$Disease.Free.Status[l1]=="DiseaseFree", 0, NA)))
   axb=coxph(ax~TCGAssgsea[2, lx2]+BrClin$Stage[l1])
   
  axc=summary(axb)
  axc
  TCGAvalCut=cut(TCGAssgsea[2, lx2], quantile(TCGAssgsea[2, lx2], c(0, 0.33, 0.67, 1)), c("L","M", "P"))
  ax2=plot(survfit(ax~TCGAvalCut), main=paste(i, "lum growing"), col=brewer.pal(3, "Blues"),lwd=2, xlab="Time (months)", ylab="DFS", mark.time=T)
    text(10, 0, sprintf("univ. cts. var. HR=%s (%s-%s), p=%s", round(axc$coefficients[1,2], 2),
                      round(axc$conf.int[1,3],2), round(axc$conf.int[1,4],2),round(axc$logtest[3],2 )))
    legend("topleft",paste(c("L", "M", "H"), summary(TCGAvalCut)), col=brewer.pal(3, "Blues"), lwd=1,
          pch=19)
  
}

 l1=which(BrClin$PAM50=="LumA")
   lx2=match(BrClin$Patient.ID[l1], colnames(TCGAssgsea))
  ax=Surv(BrClin$Disease.Free..Months.[l1], ifelse(BrClin$Disease.Free.Status[l1]=="Recurred/Progressed", 1, ifelse(BrClin$Disease.Free.Status[l1]=="DiseaseFree", 0, NA)))
   axb=coxph(ax~TCGAssgsea[2, lx2]+BrClin$Stage[l1])
   summary(axb)

   hist(TCGAssgsea[2, lx2])
   
```

The gene lists are 

Stable:

`r GlistGrowing` 

Growing:

`r Glistnon`


We can see whether this signature associates with leukocyte content and TCR diversity in the TCGA cohort:

```{r Ext5i-growing, fig.cap="luminal signature associated with clinical variables", fig.height=8}

l1=which(BrClin$PAM50=="LumA")
lx2=match(BrClin$Patient.ID[l1], colnames(TCGAssgsea))

lx3=match(BrClin$Patient.ID[l1], ThorssData$TCGA.Participant.Barcode)

newinfoTab=data.frame(pat=BrClin$Patient.ID[l1], TCGAval=TCGAssgsea[2, lx2],
                      leuk=as.numeric(ThorssData$Leukocyte.Fraction[lx3]),
                      str=as.numeric(ThorssData$Stromal.Fraction[lx3]),
                      TCRshann=as.numeric(ThorssData$TCR.Shannon[lx3]),
                      immSub=ThorssData$Immune.Subtype[lx3])


#pdf("figure-outputs/NewpanelC.pdf", height=8, width=9)
par(mfrow=c(2,2))
ax=cor.test(newinfoTab$TCGA, newinfoTab$leuk, method="spearman")
smoothScatter(newinfoTab$TCGA, newinfoTab$leuk)
text(0.6,0.6, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 2)))
ax=cor.test(newinfoTab$TCGA, newinfoTab$str, method="spearman")
smoothScatter(newinfoTab$TCGA, newinfoTab$str)
text(0.6,0.6, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 2)))
ax=cor.test(newinfoTab$TCGA, newinfoTab$TCRshann, method="spearman")
smoothScatter(newinfoTab$TCGA, newinfoTab$TCRshann)
text(0.6,5, sprintf("cor=%s, p=%s", round(ax$estimate, 2), round(ax$p.value, 2)))
#dev.off()

DT::datatable(newinfoTab, rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), Xscroll=T))


```

As well as whether it associates with any of the previously identified immune subtypes:

```{r thorrs-subtypes}
ggplot(newinfoTab, aes(x=immSub, y=TCGAval))+geom_boxplot()+geom_point()+theme_bw()
write.csv(newinfoTab, file="nature-tables/5h_lum_growing_vs_stable.csv")
```

### TCGA: LumA high vs low signatures

We can pull out the samples here which have high vs low signature (in the lumA group) and perform differential gene expression analysis on these cases:

```{r TCGA-deseq}
newinfoTab$TCGAvalcut=cut(newinfoTab$TCGAval,  quantile(newinfoTab$TCGAval, c(0, 0.33, 0.67, 1) ), c("L", "M", "O"))

colDataTCGA=newinfoTab[which(newinfoTab$TCGAvalcut!="M"), ]

head(colDataTCGA)

TCGAdeseq=DESeqDataSetFromMatrix(round(TCGArsem2[ ,match(colDataTCGA$pat, colnames(TCGArsem2))]), colDataTCGA, design=~TCGAvalcut)

TCGAdeseq=DESeq(TCGAdeseq)

TCGAdeseqRes=results(TCGAdeseq, contrast=c("TCGAvalcut", "O", "L"))

#write.csv(TCGAdeseqRes, file="nature-tables/5J_TCGA.csv")

TCGAdeseqRes2=TCGAdeseqRes[which(TCGAdeseqRes$padj<0.05 & abs(TCGAdeseqRes$log2FoldChange)>1.5 
                                 & TCGAdeseqRes$baseMean>100), ]

A1=as.data.frame(TCGAdeseqRes)

DT::datatable(A1, rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), Xscroll=T))
write.csv(TCGAdeseqRes, file="nature-tables/TCGA_stable_growing.csv")
```

We can plot the differential genes here in a volcano plot:

```{r tcga-volcano, fig.cap="yet another volcano plot"}
#pdf("figure-outputs/Fig5J_TCGA_deg.pdf", height=8, width=8)
with(TCGAdeseqRes, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot: Low exp (-) vs high (+)", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))
with(subset(TCGAdeseqRes, padj<0.05 & abs(log2FoldChange)>1.5 & baseMean>100), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))
text(TCGAdeseqRes2$log2FoldChange+0.02, -log10(TCGAdeseqRes2$padj)+0.05, rownames(TCGAdeseqRes2))
#with(subset(TCGAdeseqRes, padj<0.05 & abs(log2FoldChange)>2), text(log2FoldChange+0.05, -log10(padj)+0.05, rownames(TCGAdeseqRes), pch=20, col="red", cex=0.75))
#dev.off()
```


```{r heatmap-tcga, fig.cap="because someone will ask for it"}
vstTCGA=vst(assay(TCGAdeseq))

ColSideCols=c("skyblue", "blue")[factor(TCGAdeseq$TCGAvalcut)]

ax1=vstTCGA[ match(rownames(TCGAdeseqRes2), rownames(vstTCGA)),  ]

#pdf("figure-outputs/Figure5J_XX_heatmap_LumA_TCGA.pdf", height=15, width=10)

heatmap.2(vstTCGA[ rownames(TCGAdeseqRes2),  ], scale="row", trace="none", ColSideColors = ColSideCols, col=RdBu[11:1], main="LumA TCGA")
```


also check the directions by looking at CXCl13, which is an overexpressed gene:

```{r}
boxplot(vstTCGA["CXCL13", ]~TCGAdeseq$TCGAvalcut)

```

Run gsea here

```{r TCGA-gsea, fig.cap="pointless TCGA hairball"}

hits=rownames(TCGAdeseqRes2)
fcTab=TCGAdeseqRes$log2FoldChange

names(fcTab)=rownames(TCGAdeseq)
  gscaTCGA=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
   gscaTCGA<- preprocess( gscaTCGA, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
   gscaTCGA <- analyze( gscaTCGA, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)
   
save( gscaTCGA, file="figure-outputs/TCGA_hairball.RData")
   
TermsA=sapply(strsplit(rownames(gscaTCGA@result$GSEA.results$ProcessNetworks), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(gscaTCGA@result$GSEA.results$ProcessNetworks)[which(is.na(TermsA))], 2, 50)

## check whether this runs:
gscaTCGA@result$GSEA.results$ProcessNetworks$Gene.Set.Term=TermsA
viewEnrichMap(gscaTCGA, gscs=c("ProcessNetworks"),
              allSig = TRUE, gsNameType="term" )

write.csv(gscaTCGA@result$GSEA.results$ProcessNetworks, file="nature-tables/5k_TCGA_lumA_GSEA.csv")
```


<!--chapter:end:09ab-associate_TCGA.Rmd-->

# DESeq analysis: Characterisation cohort (big vs small)

This document sets up DESeq runs to compare:

* CD45 samples
* Ep samples

according to size of the cohort samples

## CD45 samples

In section 6.2, we have noticed that some DN samples had expression of epithelial markers. Here, we perform a differential gene expression analysis to find genes which are different between these two fractions. 


Below is a summary of the number of differential genes, using p value cut off of 0.05 and log2 fold change of 1.5 and base expression of 100+.

```{r cd45-char-bigsmall, cache=T}
infoTableFinal$TumSize=Cdata$Tumor.diameter.sac.mm[match(infoTableFinal$TumorID, Cdata$TumorID)]
infoTableFinal$SizeCat=factor(ifelse(infoTableFinal$Cohort=="Progression", ifelse(infoTableFinal$TumSize>X2a, "big", "small"), ifelse(infoTableFinal$TumSize>7, "big", "small")))
epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction=="CD45" & !is.na(infoTableFinal$SizeCat))])
CD45ddsChar=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~(SizeCat)) ## change class

a1x=rowSums(counts(CD45ddsChar))
a1b=apply(counts(CD45ddsChar), 1, function(c) sum(c!=0))

sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(CD45ddsChar))>10^sd1vals)
keep2=which(apply(counts(CD45ddsChar), 1, function(c) sum(c!=0))> (ncol(CD45ddsChar)/2))
CD45ddsChar=CD45ddsChar[intersect(keep, keep2), ]
CD45ddsChar=DESeq(CD45ddsChar)

A1=results(CD45ddsChar)
DT::datatable(as.data.frame(A1), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

```

### PCA plot

First, have a look at the samples in a PCA plot: do they separate based on size:

```{r}


vst1=vst(CD45ddsChar)

ax1=plotPCA(vst1, "SizeCat")+theme_bw()+geom_text(aes(label=colnames(vst1)))+ggtitle("CD45 cells")+scale_color_manual(values=ColSize)

# nclude the control CD45 sample
vst1=vsd[, which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort!="Progression")]
vst1$SizeCat=infoTableFinal$SizeCat[match(colnames(vst1), infoTableFinal$SampleID)]

ax1=heatmap.2(cor((assay(vst1))), col=RdBu[11:1], trace="none", ColSideColors = ColSize[(vst1$SizeCat)])

t1=ax1$carpet
t1r=c(1:ncol(t1))
t1r[10:11]=c(11:10)
```

Slightly re-order this to make sure the normal mammary gland is on the outside

```{r Ext2d, fig.cap="correlation matrix of cd45 cells" }
heatmap.2(t1, Colv = t1r, Rowv = t1r, trace="none", col=RdBu[11:1])

rownames(t1)=infoTableFinal$TumorIDnew[match(rownames(t1), rownames(infoTableFinal))]
colnames(t1)=rownames(t1)
#write.csv(t1, file="nature-tables/Ext2d.csv")
DT::datatable(t1, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

```

### Differential Gene Expression

Below are volcano plots of the differentially expressed genes with abs(log2change)>1.5, padj<0.05 and baseMean>100.

The first plot lists all differentially expressed genes, the second only lists those which are known to be immune related.

```{r cd450deg0char}
print('significant differential genes')
CD45res=results(CD45ddsChar, contrast=c("SizeCat", "big", "small"))
CD45res2=CD45res[which(CD45res$padj<0.05 & abs(CD45res$log2FoldChange)>1.5 &
                             CD45res$baseMean>100), ]

#pdf("~/Desktop/DESeq-small-vs-largeCD45-characterisation.pdf", height=6, width=6)
namId=which(rownames(vsd)%in%RatAllImm & rownames(vsd)%in%rownames(CD45res2))
namIdN=rownames(vsd)[namId]

plot(CD45res$log2FoldChange, -log10(CD45res$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(CD45res2$log2FoldChange, -log10(CD45res2$padj), rownames(CD45res2), col="red")

CD45res3=CD45res[match(namIdN, rownames(CD45res)), ]

plot(CD45res$log2FoldChange, -log10(CD45res$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(CD45res3$log2FoldChange, -log10(CD45res3$padj), rownames(CD45res3), col="red")

DT::datatable(as.data.frame(CD45res2), rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

```

We can also visualise this in a heatmap below, showing immune specific differentially expressed genes:

```{r 2d, fig.cap="Differential CD45 genes big vs small"}
#HighExprGenes=rownames(CD45res2)[which(CD45res2$baseMean>100 & CD45res2$log2FoldChange<0) ]

colSide=CD45ddsChar$SizeCat


t2=assay(vsd)[namId, match(colnames(CD45ddsChar), colnames(vsd))]

colnames(t2)=infoTableFinal$TumorIDnew[match(colnames(t2), rownames(t2))]

heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="immune genes DEG")

write.csv(t2, file="nature-tables/2d.csv")
```

### GSEA

Run GSEA. Here, we will look specifically at the Process Network pathways which are enriched, focusing specifically on immune related terms

```{r char-gsea-cd45, results='hide', fig.cap="gsea for cd45 samples"}
cd45Genes=rownames(CD45res)

l1=SymHum2Rat$HGNC.symbol[match(cd45Genes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(cd45Genes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(cd45Genes, Mouse2Hum$MGI.symbol)]
cd45GenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, cd45Genes)))


hits=cd45GenesConv[match(rownames(CD45res2), cd45Genes)]
#hits=epGenesConv[match(hits, rownames(Epdds))]
fcTab=CD45res$log2FoldChange
names(fcTab)=cd45GenesConv


  gscacd=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gscacd <- preprocess(gscacd, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gscacd <- analyze(gscacd, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)

A1=summarize(gscacd)  

PNresults=gscacd@result$GSEA.results$ProcessNetworks

Ax1=which(PNresults$Adjusted.Pvalue<0.1)

Lx1=PNresults[Ax1, 1:2]
Lx1$Group=sapply(strsplit(rownames(Lx1), "_"), function(x) x[1])
Lx1$Process=sapply(strsplit(rownames(Lx1), "_"), function(x) x[2])

## replace certain groups
Lx1$Group[grep("ymphocyte", Lx1$Process)]="NImmune response"

# plot for inflammation, immune response, cell adhesion, transcription?

TestGrp=c("NInflammation", "NCell adhesion", "NImmune response", "NTranscription")

#pdf("~/Desktop/2E-process-networks-significant-pathways.pdf", width=6, height=6)

par(mfrow=c(2,2), oma=c(0, 3, 0, 0))

for (i in TestGrp){
        x1=which(Lx1$Group==i)
        barplot(Lx1$Observed.score[x1], names.arg = Lx1$Process[x1], horiz = T, las=2,
                main=i)
}

#dev.off()

write.csv(gscacd@result$GSEA.results$ProcessNetworks, file="nature-tables/Supp_3_cd45_big_small.csv")
write.csv(Lx1, file="nature-tables/2e.csv")
```

In the following hairball, we can look at all the terms

```{r cd45-hairball, fig.cap="gsea hairball for all cd45 samples"}
TermsA=sapply(strsplit(rownames(gscacd@result$GSEA.results$ProcessNetworks), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(gscacd@result$GSEA.results$ProcessNetworks)[which(is.na(TermsA))], 2, 50)

## check whether this runs:
gscacd@result$GSEA.results$ProcessNetworks$Gene.Set.Term=TermsA
viewEnrichMap(gscacd, gscs=c("ProcessNetworks"),
              allSig = TRUE, gsNameType="term")

save(gscacd, file="figure-outputs/2e.Rdata")

```

## Epithelial samples

```{r ep-samples-cache}
infoTableFinal$TumSize=Cdata$Tumor.diameter.sac.mm[match(infoTableFinal$TumorID, Cdata$TumorID)]
#infoTableFinal$SizeCat=factor(ifelse(infoTableFinal$Cohort=="Progression", ifelse(infoTableFinal$TumSize>X2a, "big", "small"), ifelse(infoTableFinal$TumSize>X1a, "big", "small")))

epidx=as.character(infoTableFinal$SampleID[which(infoTableFinal$Cohort!="Progression" & infoTableFinal$Fraction=="Ep" & !is.na(infoTableFinal$SizeCat))])
EpddsChar=DESeqDataSetFromMatrix(allstarFinal[ ,epidx], infoTableFinal[epidx, ], design=~(SizeCat)) ## change class

a1x=rowSums(counts(EpddsChar))
a1b=apply(counts(EpddsChar), 1, function(c) sum(c!=0))
 # par(mfrow=c(1,2))
 # hist(log10(a1x+1), main="log10 total counts")
 # hist((a1b+1), main="Non-zero entries")
sd1vals=mean(log10(a1x+1))-sd(log10(a1x+1))
keep=which(rowSums(counts(EpddsChar))>10^sd1vals)
keep2=which(apply(counts(EpddsChar), 1, function(c) sum(c!=0))> (ncol(EpddsChar)/2))
EpddsChar=EpddsChar[intersect(keep, keep2), ]
EpddsChar=DESeq(EpddsChar)
```

### PCA plot

First, have a look at the samples in a PCA plot: do they separate based on size:

```{r Ext1f, fig.cap="PCA plot of epithelial samples"}

#pdf("~/Desktop/S1CD-Ep-characterisation-PCA-outcome.pdf", width=6, height=6)

vst1=vst(EpddsChar)

plotPCA(vst1, "SizeCat")+theme_bw()+geom_text(aes(label=colnames(vst1)))+ggtitle("Ep cells")+scale_color_manual(values=ColSize)
```

And the plot of how much samples correlate with each other

```{r Ext1g, fig.cap="correlation plot epithelial samples"}
ax1=heatmap.2(cor((assay(vst1))), col=RdBu[11:1], trace="none", ColSideColors = ColSize[(vst1$SizeCat)])

#dev.off()

write.csv(cor((assay(vst1))), file="nature-tables/Ext1g.csv")
```

Here is a volcano plot the significant differential genes showing the difference between big and small tumors in the Ep fraction:

```{r 1g, fig.cap="Ep DEG big-small"}
Epres=results(EpddsChar, contrast=c("SizeCat", "big", "small"))
Epres2=Epres[which(Epres$padj<0.05 & abs(Epres$log2FoldChange)>1.5 &
                             Epres$baseMean>100), ]

plot(Epres$log2FoldChange, -log10(Epres$padj), pch=20, col="black",
     main="small (-ve) vs large (+ve)")
text(Epres2$log2FoldChange, -log10(Epres2$padj), rownames(Epres2), col="red")
```

And the accompanying heatmap:

```{r 1gheatmap, fig.cap="heatmap of big vs small"}
colSide=EpddsChar$SizeCat

t2=assay(vsd)[which( rownames(vsd)%in%rownames(Epres2)), match(colnames(EpddsChar), colnames(vsd))]
a1=heatmap.2(t2, trace="none", col=RdBu[11:1], ColSideColors = palette()[colSide], scale="row", main="all DEG")

boxplot(assay(vsd)["Creb1", match(colnames(EpddsChar), colnames(vsd))]~EpddsChar$SizeCat,
        main="Creb1 gene small vs big vst expression")

write.csv(Epres2, file=sprintf("nature-tables/1gl%s.csv", Sys.Date()))
write.csv(Epres, file=sprintf("nature-tables/Supp2_A_DEGs.csv"))
```

### GSEA

Run GSEA. Here, we will look specifically at the Process Network pathways which are enriched

```{r 1h, results='hide', fig.cap="Ep hairball with size"}
EpGenes=rownames(Epres)

l1=SymHum2Rat$HGNC.symbol[match(EpGenes, SymHum2Rat$RGD.symbol)]
l2=Rat2Hum$HGNC.symbol[match(EpGenes, Rat2Hum$RGD.symbol)]
l3=Mouse2Hum$HGNC.symbol[match(EpGenes, Mouse2Hum$MGI.symbol)]
EpGenesConv=ifelse(is.na(l1)==F, l1, ifelse(is.na(l2)==F, l2, ifelse(is.na(l3)==F, l3, EpGenes)))


hits=EpGenesConv[match(rownames(Epres2), EpGenes)]
#hits=epGenesConv[match(hits, rownames(Epdds))]
fcTab=Epres$log2FoldChange
names(fcTab)=EpGenesConv


  gscaep=GSCA(listOfGeneSetCollections=ListGSC,geneList=fcTab, hits = hits)
  gscaep <- preprocess(gscaep, species="Hs", initialIDs="SYMBOL",
                    keepMultipleMappings=TRUE, duplicateRemoverMethod="max",
                    orderAbsValue=FALSE)
  gscaep <- analyze(gscaep, 
                 para=list(pValueCutoff=0.05, pAdjustMethod="BH",
                           nPermutations=100, minGeneSetSize=5,
                           exponent=1), 
                           doGSOA = F)

A1=summarize(gscaep)  

save(gscaep, file="figure-outputs/1h.Rdata")
TermsA=sapply(strsplit(rownames(gscaep@result$GSEA.results$ProcessNetworks), "_"), function(x) x[2])
TermsA[which(is.na(TermsA))]=substr(rownames(gscaep@result$GSEA.results$ProcessNetworks)[which(is.na(TermsA))], 2, 50)

## check whether this runs:
gscaep@result$GSEA.results$ProcessNetworks$Gene.Set.Term=TermsA
viewEnrichMap(gscaep, gscs=c("ProcessNetworks"),
              allSig = TRUE, gsNameType="term")

write.csv(gscaep@result$GSEA.results$ProcessNetworks, file="nature-tables/Supp_2_B_GSEA.csv")
```

We can also look at the results using barplots, as shown below

```{r ep-gsea-barplots}
PNresultse=gscaep@result$GSEA.results$ProcessNetworks

Ax1=which(PNresultse$Adjusted.Pvalue<0.1)

Lx1=PNresultse[Ax1, 1:2]
Lx1$Group=sapply(strsplit(rownames(Lx1), "_"), function(x) x[1])
Lx1$Process=sapply(strsplit(rownames(Lx1), "_"), function(x) x[2])

## replace certain groups
Lx1$Group[grep("ymphocyte", Lx1$Process)]="NInflammation"
Lx1$Group[which(Lx1$Group=="NImmune response")]="NInflammation"

# plot for inflammation, immune response, cell adhesion, transcription?

TestGrp=c("NCell adhesion", "NDevelopment", "NTranscription", "NInflammation")

#pdf("~/Desktop/1E-process-networks-significant-pathways_ep.pdf", width=6, height=6)

par(mfrow=c(2,2), oma=c(0, 3, 0, 0))

for (i in TestGrp){
        x1=which(Lx1$Group==i)
        barplot(Lx1$Observed.score[x1], names.arg = Lx1$Process[x1], horiz = T, las=2,
                main=i)
}

#dev.off()

write.csv(Lx1, file="nature-tables/1h.csv")


load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData")


# match the genes in the Tgfb pathway
Genes1=PathwayMapAllComp$`Cell adhesion_Leucocyte chemotaxis`
mid=match(Genes1, toupper(rownames(vst1)))

heatmap.2(assay(vst1)[na.omit(mid), ], col=RdBu[11:1], ColSideColors = ColSize[vst1$SizeCat], 
          trace="none", scale="row")

```

Double check the above result by running a ssGSEA and checking the directionality

```{r, results='hide'}
Mx1=assay(vst1)
rownames(Mx1)=toupper(rownames(Mx1))

testOut=gsva(Mx1, PathwayMapAllComp,method="ssgsea", kcdf="Gaussian", ssgsea.norm=T)
boxplot(testOut["Cell cycle_S phase", ]~vst1$SizeCat)
boxplot(testOut["Cell adhesion_Cell-matrix interactions", ]~vst1$SizeCat)

```

### Check expression of checkpoint proteins

```{r Ext2f, fig.cap="checkpoint proteins expressed in epithelial samples"}
#pdf("figure-outputs/Supp2_checkpoint.pdf", height=5, width=5)
ImmSuppAPCRat=sapply(ImmSuppAPC, function(x) na.omit(SymHum2Rat$RGD.symbol[match(x, SymHum2Rat$HGNC.symbol)]))

vstB=assay(vst1)[match(unlist(ImmSuppAPCRat), rownames(vst1)), ]
ColSideCols=rep(c("red", "blue", "purple"), times=sapply(ImmSuppAPCRat, length))

rmx=which(is.na(vstB[ ,1]))

heatmap.2(vstB[-rmx, ], col=RdBu[11:1], scale="none", trace="none", 
          RowSideColors = ColSideCols[-rmx], hclustfun = hclust.ave)


## Also do this using TPM values
valuesB=allTPMFinal[ match(unlist(ImmSuppAPCRat), rownames(allTPMFinal)), match(colnames(vstB), colnames(allTPMFinal))]
colnames(valuesB)=infoTableFinal$TumorIDnew[match(colnames(valuesB), rownames(infoTableFinal))]

heatmap.2(log10(valuesB[ -rmx, ]+1), col=RdBu[11:1], scale="none", trace="none", 
          RowSideColors = ColSideCols[-rmx], hclustfun = hclust.ave)

#dev.off()
DT::datatable(as.data.frame(valuesB), rownames=T, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))



#write.csv(vstB[-rmx, ], file="nature-tables/Ext2f_checkpoint_expression.csv")

```


Write the tables to file

```{r}
write.csv(infoTableFinal, file="nature-tables/infoTableFinal_output.csv")
write.csv(allstarFinal, file="nature-tables/allstarFinal_output.csv")

```

<!--chapter:end:10b-GE-characterisation-cohort.Rmd-->

# Signature analysis

In this section, we use ss gene-set enrichment analysis to investigate differences in 

- Major signalling pathways
- MHC expression signatures

## MHC signature analysis

Look if there is an association between MHC class I and class II and checkpoint proteins with growth in the different fractions. The summary appears:

* class I: association with stable in ep samples
* class II: low expression in DN stable sampels
* MHC presentation: higher in stable samples Ep (and also the characterisation cohort in general), may also be the case in DN samples

### MHC-I

```{r}
classI <- c("RT1-A1", "RT1-A2", "RT1-A3", "RT1-Cl", "RT1-M2", "RT1-M3-1", "RT1-M4", "RT1-M5", "RT1-N1", "RT1-N2", "RT1-N3", "RT1-O1", "RT1-S2", "RT1-S3")
classII <- c("RT1-Ba", "RT1-Bb", "RT1-Da", "RT1-Db1", "RT1-Db2", "RT1-DMa", "RT1-DMb", "RT1-DOa", "RT1-DOb", "RT1-Ha")

#pdf(sprintf("rslt/signatureAnalysis/MHC_presentation_%s.pdf", Sys.Date()), height=6, width=7)

MHCclassSumm2=assay(vsd)[na.omit(match(classI, rownames(assay(vsd)))),  ]
colnames(MHCclassSumm2)=infoTableFinal$TumorIDnew[match(colnames(MHCclassSumm2), rownames(infoTableFinal))]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort=="Progression")])], scale="row", main="CD: MHC class I", hclustfun = hclust.ave)

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep" & infoTableFinal$Cohort=="Progression")])], scale="row", main="Ep: MHC class I", hclustfun = hclust.ave)

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN" & infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors =ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN" & infoTableFinal$Cohort=="Progression")])], scale="row", main="DN: MHC class I", hclustfun = hclust.ave)
```

### MHC-II

```{r}
MHCclassSumm2=assay(vsd)[na.omit(match(classII, rownames(assay(vsd)))), ]
colnames(MHCclassSumm2)=infoTableFinal$TumorIDnew[match(colnames(MHCclassSumm2), rownames(infoTableFinal))]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45"& infoTableFinal$Cohort=="Progression")])], scale="row", main="CD: MHC class II")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")])], scale="row", main="Ep: MHC class II")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN"& infoTableFinal$Cohort=="Progression")])], scale="row", main="DN: MHC class II")
```

### MHC presentation proteins

```{r}
MHCclassSumm2=assay(vsd)[na.omit(match(MHCPres2Rat[-1], rownames(assay(vsd)))), ]
colnames(MHCclassSumm2)=infoTableFinal$TumorIDnew[match(colnames(MHCclassSumm2), rownames(infoTableFinal))]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="CD45"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="CD45" & infoTableFinal$Cohort=="Progression")])], scale="row", main="CD45: MHC presentation")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")])], scale="row", main="Ep: MHC presentation")

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="DN"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="DN"& infoTableFinal$Cohort=="Progression")])], scale="row", main="DN: MHC presentation")

#dev.off()
```

### inflammation related genes: IL6-JAK-STAT and TNF/NFKB

```{r Ext5b, fig.cap="Genes associated with inflammation"}
InflammGenes=c("Jak1","Jak3", "Jak2", "Stat3", "Il6", "Il2", "Il5","Ifng", "Ifna1", "Nfkb1", "Cdf", "Stat5a", "Stat1", "Stat2", "Il6r", "Socs3", "Il5r", "Il2r", "Tnf", "Tnfrsf1a", "Tnfrsf1b")

MHCclassSumm2=assay(vsd)[na.omit(match(InflammGenes, rownames(assay(vsd)))), ]
colnames(MHCclassSumm2)=infoTableFinal$TumorIDnew[match(colnames(MHCclassSumm2), rownames(infoTableFinal))]

heatmap.2(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")], col=RdBu[11:1], trace="none", ColSideColors = ColSizeb[factor(infoTableFinal$Growth[which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")])], scale="row", main="Ep: JAK/STAT signalling", hclustfun = hclust.ave)

write.csv(MHCclassSumm2[ ,which(infoTableFinal$Fraction=="Ep"& infoTableFinal$Cohort=="Progression")], 
          file="nature-tables/Ext5b.csv")
```

<!--chapter:end:11a-ssGSEA-checkpoint.Rmd-->

# Immune estimation

In this section, we will look at Deconvolution methods (CIBERSORT, TIMER etc) for estimating immune fractions and cell types


Deconvolution was performed using the TIMER website, which lists results from TIMER,
XCELL,
CIBERSORT,
EPIC, MMPCOUNTER

TPM counts were used for this analysis (using Rat gene names) on the TIMER website ()

```{r}
ProgSpecCD45=read.csv("../data/RNA_expression/CD45_TPM_rgd_names_prog_12-08_estimation_matrix.csv")
colnames(ProgSpecCD45)=gsub("X", "", colnames(ProgSpecCD45))
CharSpecCD45=read.csv("../data/RNA_expression/CD45-tpm-rgdnames-char-2020-11-22-estimation_matrix.csv")
colnames(CharSpecCD45)=gsub("X", "", colnames(CharSpecCD45))

## merge the two together

output1=merge(ProgSpecCD45, CharSpecCD45, by.x="cell_type", by.y="cell_type", all=T)

```


## Overview of the cell types

Below, we will look at the enrichment scores of specific cell types compared to others using these different methods. It appears that most methods have scores which skews towards high representation of T cells:

TIMER for example shows an enrichment of dendritic and CD8 T cells.
EPIC in contrast shows enrichment for CD4+ and to a lesser extend CD8 T cells
MMPCOUNTER puts an unusually large weighting to T cells and this does not fit our FACS analysis
XCELL enriches for T cells

```{r, fig.height=8}
RowNames=c("TIMER", "CIBERSORT$", "CIBERSORT-ABS", "EPIC", "MMCPCOUNTER", "XCELL")
Type=c("enrichment", "fraction", "enrichment", "fraction", "enrichment", "enrichment")

par(mfrow=c(3, 2))

for (i in 1:length(RowNames)){
timSamples=output1[grep(RowNames[i], output1$cell_type), ]
rownames(timSamples)=sapply(strsplit(as.character(timSamples$cell_type), "_"), function(x) x[1])
boxplot(t(timSamples[ ,-1]), las=2, main=RowNames[i], ylab=Type[i])
}
```

## characterisation cohort: assoc with size

Associations with size? Perform a correlation test between all of the information above and tumor size. 

We obtain a matrix which is colored with a coefficient correlation (red is associative, blue is negatively associated). Correlations which are significant are marked with an asterisk:

```{r}
sizeInfo=infoTableFinal$TumSize[match(colnames(CharSpecCD45)[-1], rownames(infoTableFinal))]

CorVals=rep(NA, nrow(CharSpecCD45))
names(CorVals)=CharSpecCD45$cell_type
CorValsP=CorVals

CorVals=sapply(1:nrow(CharSpecCD45), function(x) cor(t(CharSpecCD45[x, -1]), sizeInfo, use="complete"))
CorValsP=sapply(1:nrow(CharSpecCD45), function(x) cor.test(t(CharSpecCD45[x, -1]), sizeInfo, use="complete")$p.value)

naidx=which(CorValsP<0.05)

RNames1=sapply(strsplit(CharSpecCD45$cell_type, "_"), function(x) x[1])
RNamesMethod=sapply(strsplit(CharSpecCD45$cell_type, "_"), function(x) x[2])


df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorVals, p=CorValsP)
ax1=acast(df2[ ,c(1:3)], RNames1~RNamesMethod)

#df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorValsP)
ax2=acast(df2[ ,c(1:2, 4)], RNames1~RNamesMethod)
ax2[which(ax2>0.1, arr.ind=T)]=0
ax2[which(is.na(ax2), arr.ind = T)]=0

#par(oma=c(3, 5, 2, 2))
#OutputplotFun(ax1, scaleR="none", main="cell type correlation", classN="no", sigMat=ax2)

## Also plot these all separately
sizeInfoCut=infoTableFinal$SizeCat[match(colnames(CharSpecCD45)[-1], rownames(infoTableFinal))]

ttestVal=sapply(1:nrow(CharSpecCD45), function(x) wilcox.test(t(CharSpecCD45[x, -1])~sizeInfoCut)$p.value)
df3=data.frame(cell=RNames1, method=RNamesMethod, cor=ttestVal)
ax3=acast(df3, RNames1~RNamesMethod)
ax3[which(ax3>0.1, arr.ind=T)]=0
ax3[which(is.na(ax3), arr.ind = T)]=0
```

The above matrices are sparse, and we can zoom in on specific methods to see whether there is an association

```{r 2f, fig.cap="correlation coefficient values"}
#pdf("~/Desktop/2F_characterisation_association_size_immune_types.pdf", width=8, height=3)

par(mfrow=c(2,2))

for (i in 1:ncol(ax1)){
  t1=ax1[, i]
  t2=which(!is.na(t1))
  image(cbind(ax1[t2, i],ax1[t2, i]), col=RdBu[11:1], xaxt="none", yaxt="none",
        main=sprintf("correlation %s (* sig p<0.1)", colnames(ax1)[i]))
  axis(1, at=seq(0, 1, length=length(t2)), names(t1)[t2], las=2, cex=0.7)
  axis(2, at=c(0,1),c("cor p", "wilcox p"), las=2, cex=0.7)
  mx=which(ax2[ t2,i]>0)
  text((mx-1)/(length(t2)-1), 0 , "*")
  mx=which(ax3[ t2,i]>0)
  text((mx-1)/(length(t2)-1), 1 , "*")
 }

#write.csv(df2, file="nature-tables/2f_correlation_coefficients_pvalues.csv")
#write.csv(ax1, file="nature-tables/2f_correlation_coefficients.csv")

DT::datatable(df2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

These accompany the following plots with individual samples:

```{r 2fplot, fig.cap="TIMER"}

#pdf("~/Desktop/2F-sample-celltypes.pdf", height=6, width=7)

x2=c(colnames(CharSpecCD45)[order(sizeInfo)+1])

ax1=grep("TIMER", CharSpecCD45$cell_type)
T1melt=melt(CharSpecCD45[ax1, ])
T1melt$variable=factor(T1melt$variable, x2)
T1melt$NewID=infoTableFinal$TumorIDnew[match(T1melt$variable, rownames(infoTableFinal))]


ggplot(T1melt, aes(x=NewID, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("TIMER:char cohort separately")+theme(axis.text.x = element_text(angle = 90))+
   scale_fill_manual(values=c("#66C2A5", "#FED976", "#FEEBE2" ,"#AE017E", "#2171B5",   "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))
```

And below is the result for CIBERSORT

```{r 2fagain}
ax1=grep("CIBERSORT$", CharSpecCD45$cell_type)
T1melt=melt(CharSpecCD45[ax1, ])

T1melt$variable=factor(T1melt$variable, x2)

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+
  ggtitle("CIBSERT:char cohort separately")+theme(axis.text.x = element_text(angle = 90))+theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

# Also do a version where the Bcells, Macrophages,NK, Mast Cells, CD4, CD8 Cells are merged together, NK

T1melt$cell_type2=substr(T1melt$cell_type, 1, 4)
T1melt$cell_type2[grep("CD8", T1melt$cell_type)]="T CD8"
T1melt$cell_type2[grep("CD4", T1melt$cell_type)]="T CD4"

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type2))+geom_bar(stat="identity")+
  ggtitle("CIBSERT:char cohort separately")+theme(axis.text.x = element_text(angle = 90))+
  scale_fill_manual(values=c("#66C2A5", "#E6F598", "#FED976", "#FC4E2A", "#bdbdbd", "#FEEBE2" ,"#AE017E", "#5E4FA2", "#2171B5", "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))

T1melt$sdat=paste(T1melt$variable, T1melt$cell_type2, sep=".")
T2=by(T1melt$value, T1melt$sdat, sum)
T2m=stack(T2)
T2m$ind1=sapply(strsplit(as.character(T2m$ind), "\\."), function(x) x[1])
T2m$ind2=sapply(strsplit(as.character(T2m$ind), "\\."), function(x) x[2])

T2mTab=acast(T2m[ ,c(1, 3:4)], ind2~ind1, value.var="values")
CorV=sapply(1:nrow(T2mTab), function(x) cor(T2mTab[x, ], sizeInfo, use="complete"))
CorVP=sapply(1:nrow(T2mTab), function(x) cor.test(T2mTab[x, ], sizeInfo, use="complete")$p.value)
wilP=sapply(1:nrow(T2mTab), function(x) wilcox.test(T2mTab[x, ]~ sizeInfoCut)$p.value)

# dev.off()

write.csv(T1melt, file="nature-tables/2f.csv")  
  
```


## Comparison with FACS data

In this section, we compare how well the estimates from RNAseq deconvolution methods associate with FACS data. Below is a heatmap showing the correlation coefficient of each cell type (by FACS) and the method,

Note that there are twice as manay samples with reliable myeloid derived cell information than for leukocytes.

```{r, imm-assoc-facs}
## annotate the FACS data here

infoTableFinal$Name2=NA
infoTableFinal$Name2[which(infoTableFinal$Fraction=="CD45")]=paste(infoTableFinal$Rat_ID[which(infoTableFinal$Fraction=="CD45")], infoTableFinal$Location[which(infoTableFinal$Fraction=="CD45")], sep="")
m2=match(colnames(Fdata), infoTableFinal$Name2)

## get rid of the NA samples
naom=infoTableFinal$SampleID[m2[which(!is.na(m2))]]
mid=colnames(Fdata)[which(!is.na(m2))]

lx1=Fdata[, c(1, match(mid, colnames(Fdata)))]
out2=output1[, c(1,match(naom, colnames(output1)))]

#head(out2)
colnames(lx1)=colnames(out2)

# Run all the association tests here
## New Table
# -cd8
# Th
# Tregs
# B cells
# Macrophage

# 
MergedTable=matrix(NA, ncol=21, nrow=1)
colnames(MergedTable)=colnames(out2)

tx1=sapply(strsplit(as.character(out2$cell_type), "_"), function(x) x[1])
MethodSumm=sapply(strsplit(as.character(out2$cell_type), "_"), function(x) x[2])
tabtx1=table(tx1)
TheseFracs=names(tabtx1)[which(tabtx1>3)]



testSetB=c("B cell", "MHCII-hi", "MHCII-lo", "Monocyte", "Neutrophil", "NK cells", "CD8", "Treg")
#  "CD8", "Th", "Treg", "B cells", "NK cells", "DC", "Neutrophil", "Monocyte", "gd T", "MHCII-hi", "MHCII-lo")
testSet=TheseFracs[-2]#c("CD8", "CD4", "Treg", "B cell", "NK", "dendritic", "Neutrophil", "Monocyte", "gamma delta", "M1", "M2")
 
CMat=matrix(NA, nrow=length(testSet), ncol=length(unique(MethodSumm)))
rownames(CMat)=testSet
colnames(CMat)=unique(MethodSumm)
 
PMat=CMat
#testSet="M2"
#testSetB="MHCII-lo"

for (j in 1:length(testSet)){
CD8Table=rbind(lx1[grep(testSetB[j], lx1$cell_type), ],
               out2[which(tx1==testSet[j]), ])
CD8Table[1,1]=paste(testSetB[j], "facs", sep="_")
ms=MethodSumm[which(tx1==testSet[j])]
par(mfrow=c(3,3))


cVals=sapply(2:nrow(CD8Table), function(x) cor(t(CD8Table[1, -1]), t(CD8Table[x, -1]), use="complete"))
cVals2=sapply(2:nrow(CD8Table), function(x) cor.test(t(CD8Table[1, -1]), t(CD8Table[x, -1]), use="complete")$p.value)

CMat[j, match(ms, colnames(CMat))]=cVals
PMat[j, match(ms, colnames(PMat))]=cVals2

MergedTable=rbind(MergedTable, CD8Table)

#for (i in 2:nrow(CD8Table)){
  #a1=cor(t(CD8Table[1, -1]), t(CD8Table[i, -1]), use="complete")
  #plot(t(CD8Table[1, -1]), t(CD8Table[i, -1]), main=CD8Table[i,1], ylab="method", xlab="FACS")
  #text(min(t(CD8Table[1, -1]), na.rm=T)*2, max(t(CD8Table[i, -1]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
  
}


##for the following, find the terms and calculate the sum

testSetB=c("Macro", "Th", "B cell")
testSet=c("Macro", "CD4", "B cell")
rmThese=c("M0", "naive", NULL)

savTemp=matrix(NA, nrow=3, ncol=ncol(CMat))
rownames(savTemp)=paste("all", testSet, sep="")
savTempP=savTemp


for (j in 1:length(testSetB)){
  
  CD8Table=lx1[grep(testSetB[j], lx1$cell_type), ]
  CD8Table=colSums(CD8Table[, -1])
  #rownames(CD8Table)="facs"
  
  outB=out2[grep(testSet[j], out2$cell_type), ]
  rm2=grep(rmThese[j], outB$cell_type)
  
  if (length(na.omit(rm2))>0){
    outB=outB[-rm2, ]
  }
  
  namOut=sapply(strsplit(as.character(outB$cell_type), "_"), function(x) x[2])
  nam2=unique(namOut[which(duplicated(namOut))])
  
  outC=sapply(nam2, function(x) colSums(outB[which(namOut==x), -1 ]))
  outB=outB[-which(namOut%in%nam2), ]
  rownames(outB)=sapply(strsplit(as.character(outB$cell_type), "_"), function(x) x[2])
  
  allD=rbind(CD8Table, outB[, -1], t(outC))
  rownames(allD)[1]="facs"
  allD$method=rownames(allD)
  
 # allD=data.matrix(allD)
  
#pdf(sprintf("rslt/Immune decomposition/correlations_combined_%s.pdf", testSetB[j]), width=10, height=10)

#ggplot(temp8, aes(x=method, y=value, col=variable))+geom_bar(stat="identity")+facet_wrap(~variable, scale="free_y")+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

par(mfrow=c(3,3))

for (i in 2:nrow(allD)){
  a1=cor(t(allD[1, -ncol(allD)]), t(allD[i, -ncol(allD)]), use="complete")
  a2=cor.test(t(allD[1, -ncol(allD)]), t(allD[i, -ncol(allD)]), use="complete")$p.value
  savTemp[j, match(rownames(allD)[i], colnames(CMat))]=a1
  savTempP[j, match(rownames(allD)[i], colnames(CMat))]=a2
# plot(t(allD[1, -ncol(allD)]), t(allD[i,-ncol(allD)]), main=allD[i,ncol(allD)], ylab="method", xlab="FACS")
#  text(min(t(allD[1, -ncol(allD)]), na.rm=T)*2, max(t(allD[i, -ncol(allD)]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
  
}

cell_type=paste(testSetB[j], allD$method, sep="_all_")

MergedTable=rbind(MergedTable, cbind(cell_type, allD[ ,-21]))

}

CorMatAll=rbind(CMat, savTemp)
CorMatP=rbind(PMat, savTempP)

par(oma=c(2, 0,0,5))
heatmap.2(CorMatAll, col=RdBu[11:1], scale="none", trace="none", main="correlation FACS and GE")

```

We can plot associations between the different cell types below, here selecting:

* Bcells
* CD8 T cells
* M2 macophage
* M1 macrophage

with each method. The correlation coefficient is indicated.

```{r, fig.height=7}
testSetB=c("CD8",  "B cells", "MHCII-hi", "MHCII-lo")
testSet=c("CD8", "B cell","M1", "M2")

par(mfrow=c(3,3))

for (j in 1:length(testSetB)){ 
CMat=matrix(NA, ncol=length(testSet), nrow=10) 
CD8Table=rbind(lx1[grep(testSetB[j], lx1$cell_type), ],
               out2[grep(testSet[j], out2$cell_type), ])

for (i in 2:nrow(CD8Table)){
  a1=cor(t(CD8Table[1, -1]), t(CD8Table[i, -1]), use="complete")
  plot(t(CD8Table[1, -1]), t(CD8Table[i, -1]), main=CD8Table[i,1], ylab="method", xlab="FACS")
  text(min(t(CD8Table[1, -1]), na.rm=T)*2, max(t(CD8Table[i, -1]), na.rm=T), paste("r=", round(a1, digits=2), sep=""))
}
mtext(testSetB[j], side=3, line=-2, outer=T)
  
}

```

## Progression cohort

We perform the same sort of analysis for the progression cohort:

```{r}
# drop samples
#dsamp=c("2R_D_CD45", "3L_D_CD45")


sizeInfo=infoTableFinal$GrowthRate[match(colnames(ProgSpecCD45)[-1], rownames(infoTableFinal))]

CorVals=rep(NA, nrow(ProgSpecCD45))
names(CorVals)=ProgSpecCD45$cell_type
CorValsP=CorVals

CorVals=sapply(1:nrow(ProgSpecCD45), function(x) cor(t(ProgSpecCD45[x, -1]), sizeInfo, use="complete"))
CorValsP=sapply(1:nrow(ProgSpecCD45), function(x) cor.test(t(ProgSpecCD45[x, -1]), sizeInfo, use="complete")$p.value)

naidx=which(CorValsP<0.05)

RNames1=sapply(strsplit(ProgSpecCD45$cell_type, "_"), function(x) x[1])
RNamesMethod=sapply(strsplit(ProgSpecCD45$cell_type, "_"), function(x) x[2])


df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorVals, p=CorValsP)
ax1=acast(df2[ ,c(1:3)], RNames1~RNamesMethod)

#df2=data.frame(cell=RNames1, method=RNamesMethod, cor=CorValsP)
ax2=acast(df2[ ,c(1:2,4)], RNames1~RNamesMethod)
ax2[which(ax2>0.1, arr.ind=T)]=0
ax2[which(is.na(ax2), arr.ind = T)]=0

pdf("~/Desktop/4F_progression_association_growthrate_all_methods.pdf", width=8, height=6)

par(oma=c(2, 2, 2, 2))
OutputplotFun(ax1, scaleR="none", main="cell type correlation", classN="no", sigMat=ax2)

dev.off()

## Also plot these all separately
sizeInfoCut=infoTableFinal$Growth[match(colnames(ProgSpecCD45)[-1], rownames(infoTableFinal))]

ttestVal=sapply(1:nrow(ProgSpecCD45), function(x) wilcox.test(t(ProgSpecCD45[x, -1])~sizeInfoCut)$p.value)
df3=data.frame(cell=RNames1, method=RNamesMethod, cor=ttestVal)
ax3=acast(df3, RNames1~RNamesMethod)
ax3[which(ax3>0.1, arr.ind=T)]=0
ax3[which(is.na(ax3), arr.ind = T)]=0

#pdf("~/Desktop/4F_progression_association_growth_types.pdf", width=8, height=3)

par(mfrow=c(2,2))

for (i in 1:ncol(ax1)){
  t1=ax1[, i]
  t2=which(!is.na(t1))
  image(cbind(ax1[t2, i],ax1[t2, i]), col=RdBu[11:1], xaxt="none", yaxt="none",
        main=sprintf("correlation %s (* sig p<0.1)", colnames(ax1)[i]))
  axis(1, at=seq(0, 1, length=length(t2)), names(t1)[t2], las=2, cex=0.7)
  axis(2, at=c(0,1),c("cor p", "wilcox p"), las=2, cex=0.7)
  mx=which(ax2[ t2,i]>0)
  text((mx-1)/(length(t2)-1), 0 , "*")
  mx=which(ax3[ t2,i]>0)
  text((mx-1)/(length(t2)-1), 1 , "*")
 }

write.csv(df2, file="nature-tables/4f.csv")

#dev.off()
```

Make the plots with individual samples. Firstly TIMER

```{r 4f, fig.cap="Progression CIBERSORT TIMER"}

#pdf("~/Desktop/4F-sample-celltypes-arranged_by_growth_rate.pdf", height=6, width=10)

x2=c(colnames(ProgSpecCD45)[order(sizeInfo)+1])

ax1=grep("TIMER", ProgSpecCD45$cell_type)
T1melt=melt(ProgSpecCD45[ax1, ])
T1melt$growth=infoTableFinal$Growth[match(T1melt$variable, infoTableFinal$SampleID)]
T1melt$treatment=infoTableFinal$Treatment[match(T1melt$variable, infoTableFinal$SampleID)]

T1melt$variable=factor(T1melt$variable, x2)

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free", drop=T)+ggtitle("TIMER:prog growth")+theme(axis.text.x = element_text(angle = 90))+
   scale_fill_manual(values=c("#66C2A5", "#FED976", "#FEEBE2" ,"#AE017E", "#2171B5",   "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))
```

then CIBERSORT

```{r}
ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free", drop=T)+ggtitle("TIMER:prog treatment")+theme(axis.text.x = element_text(angle = 90))+
   scale_fill_manual(values=c("#66C2A5", "#FED976", "#FEEBE2" ,"#AE017E", "#2171B5",   "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))


ax1=grep("CIBERSORT$", ProgSpecCD45$cell_type)
T1melt=melt(ProgSpecCD45[ax1, ])

T1melt$variable=factor(T1melt$variable, x2)
T1melt$growth=infoTableFinal$Growth[match(T1melt$variable, infoTableFinal$SampleID)]
T1melt$treatment=infoTableFinal$Treatment[match(T1melt$variable, infoTableFinal$SampleID)]

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free")+
  ggtitle("CIBSERT:char cohort separately")+theme(axis.text.x = element_text(angle = 90))+theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free")+
  ggtitle("CIBSERT:char cohort separately")+theme(axis.text.x = element_text(angle = 90))+theme_bw()+
  theme(axis.text.x = element_text(angle = 90))

# Also do a version where the Bcells, Macrophages,NK, Mast Cells, CD4, CD8 Cells are merged together, NK

T1melt$cell_type2=substr(T1melt$cell_type, 1, 4)
T1melt$cell_type2[grep("CD8", T1melt$cell_type)]="T CD8"
T1melt$cell_type2[grep("CD4", T1melt$cell_type)]="T CD4"

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type2))+geom_bar(stat="identity")+facet_grid(~growth, space="free_x", scale="free")+
  ggtitle("CIBSERT:prog growth")+theme(axis.text.x = element_text(angle = 90))+
  scale_fill_manual(values=c("#66C2A5", "#E6F598", "#FED976", "#FC4E2A", "#bdbdbd", "#FEEBE2" ,"#AE017E", "#5E4FA2", "#2171B5", "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))

ggplot(T1melt, aes(x=variable, y=value, fill=cell_type2))+geom_bar(stat="identity")+facet_grid(~treatment, space="free_x", scale="free")+
  ggtitle("CIBSERT:prog treatment")+theme(axis.text.x = element_text(angle = 90))+
  scale_fill_manual(values=c("#66C2A5", "#E6F598", "#FED976", "#FC4E2A", "#bdbdbd", "#FEEBE2" ,"#AE017E", "#5E4FA2", "#2171B5", "#BDD7E7", "#EFF3FF"))+theme_bw()+theme(axis.text.x = element_text(angle = 90))



T1melt$sdat=paste(T1melt$variable, T1melt$cell_type2, sep=".")
T2=by(T1melt$value, T1melt$sdat, sum)
T2m=stack(T2)
T2m$ind1=sapply(strsplit(as.character(T2m$ind), "\\."), function(x) x[1])
T2m$ind2=sapply(strsplit(as.character(T2m$ind), "\\."), function(x) x[2])

T2mTab=acast(T2m[ ,c(1, 3:4)], ind2~ind1, value.var="values")
CorV=sapply(1:nrow(T2mTab), function(x) cor(T2mTab[x, ], sizeInfo, use="complete"))
CorVP=sapply(1:nrow(T2mTab), function(x) cor.test(T2mTab[x, ], sizeInfo, use="complete")$p.value)
wilP=sapply(1:nrow(T2mTab), function(x) wilcox.test(T2mTab[x, ]~ sizeInfoCut)$p.value)

# image(cbind(CorV,CorV), col=RdBu[11:1], xaxt="none", yaxt="none",
#         main="correlation CIBERSORT growth rate (* sig p<0.1)")
#   axis(1, at=seq(0, 1, length=length(CorV)), rownames(T2mTab), las=2, cex=0.7)
#   axis(2, at=c(0,1),c("cor p", "wilcox p"), las=2, cex=0.7)
#   mx=which(CorVP<0.1)
#   text((mx-1)/(CorVP-1), 0 , "*")
#   mx=which(wilP<0.1)
#   text((mx-1)/(wilP-1), 1 , "*")

  #dev.off()

#write.csv(T1melt, file="nature-tables/4f_image.csv")
DT::datatable(T1melt, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

## Clinical associations

### Associate with Treatment

Look at association with treatment, growth and spatial infiltration for each method. 

Associations with treatment:

* higher CD4, CD8 in most treatments 
* growth: stable associated with higher CD8
* infiltration: more neutrophils and CD8? maybe CD4 cells


```{r, immune-assoc-outcome, cache=T}
#sizeCutOff=7

MergedTablemelt=melt(MergedTable[-1, ])
MergedTablemelt$Treatment=infoTableFinal$Treatment[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$Growth=infoTableFinal$Growth[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$InfRes=infoTableFinal$MHcut[match(MergedTablemelt$variable, infoTableFinal$SampleID)]
MergedTablemelt$cell_type2=sapply(strsplit(MergedTablemelt$cell_type, "_"), function(x) x[1])
MergedTablemelt$method=sapply(strsplit(MergedTablemelt$cell_type, "_"), function(x) x[length(x)])

unValues=unique(MergedTablemelt$cell_type2)

CompTest=list()

for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=Treatment, y=as.numeric(value), col=Treatment))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Treatment"))
print(p)
#p<-ggplot(ax, aes(x=Growth, y=as.numeric(value), col=Growth))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Growth"))
#print(p)
#p<-ggplot(ax, aes(x=InfRes, y=as.numeric(value), col=InfRes))+geom_boxplot()+facet_wrap(~method, #scale="free_y")+ggtitle(paste(unValues[i], "Infiltration"))
#print(p)

unT=sort(unique(ax$Treatment))
unB=sort(unique(ax$method))
Outcome1=matrix(NA, nrow=5, ncol=length(unB))

rownames(Outcome1)=c(paste(unT[1:3], "vs.Vehicle", sep=""), "Grow.Stable", "Inf.res")
colnames(Outcome1)=unB

for (j in 1:nrow(Outcome1)){
Outcome1[1 , ]=sapply(unB, function(x) wilcox.test(ax$value[which(ax$Treatment=="LY" & ax$method==x)], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[2 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Treatment=="PDL1" & ax$method==x], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[3 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Treatment=="PDL1+LY" & ax$method==x], 
                  ax$value[ax$Treatment=="Vehicle" & ax$method==x])$p.value)
Outcome1[4 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$Growth=="growing" & ax$method==x], 
                  ax$value[ax$Growth=="stable" & ax$method==x])$p.value)
Outcome1[5 , ]=sapply(unB, function(x) wilcox.test(ax$value[ax$InfRes=="inf" & ax$method==x], 
                  ax$value[ax$InfRes=="res" & ax$method==x])$p.value)

}
CompTest[[i]]=t(Outcome1)
o1=Outcome1
o1[which(o1<0.05, arr.ind=T)]=3
o1[which(o1<0.1, arr.ind=T)]=2
o1[which(o1<=1, arr.ind=T)]=0
#heatmap.2(o1, col=brewer.pal(9, "Blues"), scale="none", trace="none", main=paste("pvalue summary", unValues[i]), Colv = NA, Rowv = NA)
}
```

Using wilcox tests for significance, we can make the above comparisons and see if there is an association with outcome:

* There are differences in B-cell content between LY vs V comaprisons using xcell and cibersort
* Macrophages are different in PDL1+LY

### Association with Growth 

```{r}
for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=Growth, y=as.numeric(value), col=Growth))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Growth"))
print(p)
}

```


```{r, eval=F}
for (i in 1:length(unValues)){
ax=MergedTablemelt[MergedTablemelt$cell_type2==unValues[i], ]
p<-ggplot(ax, aes(x=InfRes, y=as.numeric(value), col=InfRes))+geom_boxplot()+facet_wrap(~method, scale="free_y")+ggtitle(paste(unValues[i], "Infiltration"))
print(p)
}

```

## Summary of the outcome

```{r, fig.width=8}
CompTest2=do.call(rbind, CompTest)
 
#write.csv(CompTest2, file=sprintf("outputs/p_values_differences_treatment_growth_infiltration_%s.csv", Sys.Date()))

CompTest2=data.frame(CompTest2)

DT::datatable(CompTest2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```



<!--chapter:end:12-immune-estimation.Rmd-->

# BCR clonotype analysis

## Processing summary

Fastq files have previously been run through TRUST4 using the Rn6 BCR annotations using the following code (not run here). Note that the bcr/tcr .fa files were assembled using the ensembl annotation (these annotations are not present in the UCSC genomic files). Annotation files for the rn6 BCR regions are available at [IMGT](http://www.imgt.org//download/V-QUEST/IMGT_V-QUEST_reference_directory/Rattus_norvegicus/), but TCR regions are not available

```{r, eval=F, echo=T}
# obtain the gene names for rat:
library(biomaRt)
human = useEnsembl("ensembl", mirror="useast", dataset = "hsapiens_gene_ensembl")
rat = useEnsembl("ensembl", mirror="useast", data="rnorvegicus_gene_ensembl")
TS = human_igg_trv_list
Hum2RatProt = getLDS(attributes = c("hgnc_symbol", "ensembl_transcript_id"), filters = "hgnc_symbol",  values = TS , mart = human, attributesL = c("rgd_symbol", "ensembl_transcript_id”, “ensemble_gene_id"), martL = rat, uniqueRows=T)
write.table(unique(Hum2RatProt$ensemble_gene_id), "ensbl_rat_bcr.txt", quote=F, row.names=F,colnames=F)

# obtain the tcr/bcr.fa file
#(Note that BuildDatabaseFa.pl needs to be edited on lines 95, 102, 114 and 121 to use transcript_id or gene_id instead)

perl BuildDatabaseFa.pl Rattus_norvegicus.Rnor_6.0.dna_sm.toplevel.fa Rattus_norvegicus.Rnor_6.0.99.gtf ensbl_rat_bcr.txt > bcrtcr_rat_ens.fa

# Obtain the reference annotation file
perl BuildImgtAnnot.pl Rattus_norvegicus > Rnor_IMGT+C.fa

# Run TRUST (below is single end)
./run-trust4 -u 20170125_NMU7_Tumor_RLU_CD45_CGDA5146_S1_R1_001.fastq.gz -f bcrtcr_rat_ens.fa --ref Rnor_IMGT+C.fa
```


```{r, trust4, cache=T}
#Annotation file: Load in an annotation file indicating all the samples, batch effects etc 


TRUST4path="../data/TRUST4/"
TRUST4files=dir(TRUST4path,"*.tsv")
#FileNames=sapply(strsplit(TRUST4files, "_report.tsv"), function(x) x[1])
matchidx=match(TRUST4files, infoTableFinal$TRUSTName)

#RepNames=paste(infoTableFinal$Rat_ID, tempAnnot$Location, tempAnnot$Fraction, sep="_")[matchidx]
# load in all the files and save the list to file
RatTrust=lapply(TRUST4files, function(x) read.delim(paste(TRUST4path, x, sep=""), sep="\t"))
names(RatTrust)=infoTableFinal$SampleID[matchidx]


TRUST4path="../data/TRUST4/matchedNormal/"
TRUST4files=dir(TRUST4path,"*.tsv")
#FileNames=sapply(strsplit(TRUST4files, "_report.tsv"), function(x) x[1])
FileNames=paste(substr(TRUST4files, 10, 12), "matchedNMUCD45", sep="_")
RatTrustNormal=lapply(TRUST4files, function(x) read.delim(paste(TRUST4path, x, sep=""), sep="\t"))
names(RatTrustNormal)=FileNames

RatTrust=c(RatTrust, RatTrustNormal)

save(RatTrust, file=sprintf("outputs/Rat_TRUST4_%s.RData", Sys.Date()))

```

## Summary Stats


Firstly, look at the number of BCR regions which have been identified by TRUST4. In green are the CD45 populations, which as expected appear to have a higher number of clonotypes compared to the epithelial and the double-negative populations (in read and orange). 

```{r}
NSamples=sapply(RatTrust, nrow)
NSamplesCt2=sapply(RatTrust, function(x) length(which(x$X.count>=2)))
NSamplesCDR3comp=sapply(RatTrust, function(x) length(which(x$CDR3aa!="partial")))
NSamplesCDR3compCt2=sapply(RatTrust, function(x) length(which(x$CDR3aa!="partial" & x$X.count>=2)))

TableOut=cbind(NSamples, NSamplesCt2, NSamplesCDR3comp, NSamplesCDR3compCt2)

matchidx=match(rownames(TableOut), infoTableFinal$SampleID)
ColOut=factor(paste(infoTableFinal$Fraction[matchidx], infoTableFinal$Batch[matchidx]))
#palette(c("#e5f5e0","#a1d99b", "#31a354",  "#fd8d3c","#fa9fb5", "#f03b20", "#005824"))

#pdf(sprintf("rslt/TRUST4/BCR_summary_QC_%s.pdf", Sys.Date()), height=5, width = 7)

# plot the clonotype diversity, color-code according to both batch and the sample used
par(mar = c(4, 4, 4, 2),  xpd = TRUE)
barplot(NSamplesCt2+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Overview of clonotype diversity (2+ reads)", col=ColOut, cex.names = 0.75)
legend("top", inset = c(-0.5, 0.03),  legend = levels(ColOut),  pch = c(19, 19, 19, 19, 19),  col = c(1:6), horiz = T)

# plot the number of full vs partial clonotypes
PartialvsFull=rbind(NSamplesCDR3compCt2,NSamplesCt2-NSamplesCDR3compCt2)
rownames(PartialvsFull)=c("full", "partial")


par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(PartialvsFull+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Proportion of full vs partial CDR3a", col=c(1:2), cex.names = 0.75)
legend("bottom", inset = c(-0.5, -0.5),  legend = c("full", "partial"),  pch = c(19, 19),  col = c(1:2), horiz = T)

par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(t(TableOut[ which(infoTableFinal$Fraction[matchidx]=="CD45"),]+1), las=2,log ='y', ylab = "Number of BCR clonotypes", main="Clonotype diversity CD45+ samples", col=c(1:4), cex.names = 0.75, beside = T)
legend("bottom", inset = c(-0.5, -0.5),  legend = c("# clonotypes", "clonotypes >2reads", "complete CDR3", "both"),  pch = c(19, 19, 19),  col = c(1:4), horiz = T)

par(mar = c(10, 4, 4, 2),  xpd = TRUE)
barplot(NSamplesCDR3compCt2+1, las=2,log ='y', ylab = "Number of BCR clonotypes", main="Filtered Clonotypes based on batch", col=ColOut, cex.names = 0.75, beside = T)
legend("top", inset = c(-0.5, 0.03),  legend = levels(ColOut),  pch = c(19, 19, 19, 19, 19),  col = c(1:5), horiz = T)

#dev.off()

```

We will refine the above plot to contain only the CD45 population and assess:

* number of clonotypes
* number of clonotypes with at least 2 reads
* number of clonotypes which have a complete CDR3a region

Note: although this does not look like a big drop, the data is plotted on a log-scale. For example, in the control 4 (first column) a quarter of the clonotypes have at least 2 counts and about half have a complete CDR3 sequence.

For the following analyses, the clonotypes are filtered to <span style="color:red"> only clonotypes with at least 2 supporting reads and a complete VDJ read </span>. When applying this restriction, we have the following distribution of BCR regions. Almost all the epithelial cases do not have supporting reads, and few of the DN cases have supporting reads too.

```{r}
RatTrustB=lapply(RatTrust, function(x) x[which(x$CDR3aa!="partial" & x$X.count>=2), ])
for (i in 1:length(RatTrustB)){
  RatTrustB[[i]]$frequency=RatTrustB[[i]]$X.count/sum(RatTrustB[[i]]$X.count)
}
```

## Diversity metrics

We will assess BCR diversity using the following metrics:

** Shannon index **

The shannon index is computed by:

* filtering through reads of interest
* recalculate the fraction such that the new list sums to 1
* compute entropy as the sum of log(freq_x)*freq_x amongst all populations x
* compute the maximum entropy expected for that case -log(1/N), where N is the number of populations present
* to determine confidence intervals, bootstrap the population (500 times) and compute the expected entropy

** Gini index **

The Gini index can be considered as an inverse of the Shannon index 

** Top Clonotypes **

We will see the proportion of the BCR repertoire which is computed using the top 10 frequent clones.
This will give an idea of whether there is a clonal expansion 

```{r, warning=F,message=F}
# compute values here
Div1=sapply(RatTrustB, function(x) -sum(x$frequency*log(x$frequency), na.rm=T))
EDiv=sapply(NSamplesCDR3compCt2, function(x) -log(1/x))
NormDiv=Div1/EDiv

## Shannon index
# bootstrap rslt
BSrslt=sapply(RatTrustB, function(x) tryCatch(BootstrapShannonIdx(x[ ,1], 1000), error=function(e) c(NA, NA)))
# divide the CI by the maximum possible diversity

BSCI=t(BSrslt)/EDiv

df=data.frame(sample=rownames(BSCI), Val=NormDiv, Lower=BSCI[ , 1], Upper=BSCI[ ,2 ], Type=infoTableFinal$Fraction[matchidx], Batch=infoTableFinal$Batch[matchidx])

## Gini index

Gini=sapply(RatTrustB, function(x) gini(x$frequency))

PGini=sapply(RatTrustB, function(x) tryCatch(PermuteGini(x$X.count, 1000), error=function(e) c(NA, NA)))

df$Calc="shannon"

df2=data.frame(sample=df$sample, Val=Gini, Lower=PGini[1, ], Upper=PGini[2, ], Type=df$Type, Batch=df$Batch,
               Calc="Gini")

dfAll=rbind(df, df2)

## Top Clonotypes

TopClones=sapply(RatTrustB, function(x) sum(x$frequency[1:5], na.rm = T))
TopClones[which(NSamplesCDR3compCt2==0)]=0
df2$Val=TopClones
df2$Calc="Top10"
df2$Lower=TopClones
df2$Upper=TopClones

dfAll=rbind(dfAll, df2)

dfAll$Batch=as.character(dfAll$Batch)
dfAll$Batch[grep("matchedNMU", rownames(dfAll))]="match"
dfAll$Type[grep("matchedNMU", rownames(dfAll))]="CD45"
#ggplot(df[df$Type=="CD45", ], aes(x=sample, y=Val, fill=Type))+geom_bar(stat="identity")+facet_grid(~Batch, scales="free_x", space="free")+geom_errorbar( aes(ymin=Lower, ymax=Upper), width=.2)+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("Shannon idx of BCR diversity")

```

The following plot demonstrates the relationship between the above metrics

```{r}
#pdf(sprintf("rslt/TRUST4/summary_Scores_diversity_%s.pdf", Sys.Date()), width=7, height=5)

ggplot(dfAll[dfAll$Type=="CD45", ], aes(x=sample, y=Val, fill=Type))+geom_bar(stat="identity")+facet_grid(Calc~Batch, scales="free_x", space="free")+geom_errorbar( aes(ymin=Lower, ymax=Upper), width=.2)+theme(axis.text.x = element_text(angle = 90, hjust = 1))+ggtitle("BCR diversity across samples")+ylab("index value")

#dev.off()
```

Notice that some samples have very few clones. An example is 5RB which is represented by a single clonotype, accounting for the absence of a Gini or shannon index

## Compare the characterisation cohort

In the characterisation cohort, we have 3 cases which have CD45 samples in both the tumor and a matched NMU treated mammary gland.

Is there a difference in the clonotypes between these samples?

```{r 2h, fig.cap="bcr clonotypes in tumor and normal mammary glands"}
CharTemp=dfAll[which(dfAll$Type=="CD45" & dfAll$Batch%in%c("1", "match")), ]
CharTemp$Batch[grep("Control", CharTemp$sample)]="Normal"
Nclonotypes=TableOut[which(rownames(TableOut)%in%CharTemp$sample), ]
Nclonotypes2=melt(Nclonotypes)
Nclonotypes2$Case="tumor"
Nclonotypes2$Case[grep("match", Nclonotypes2$Var1)]="mammary"
Nclonotypes2$Case[grep("Control", Nclonotypes2$Var1)]="control"

#pdf(sprintf("rslt/TRUST4/compare_mammary_vs_tumor_%s.pdf", Sys.Date()), width=8, height=6)
a1=sapply(unique(CharTemp$Calc), function(x) wilcox.test(CharTemp$Val[CharTemp$Calc==x & CharTemp$Batch==1], CharTemp$Val[CharTemp$Calc==x & CharTemp$Batch=="match"])$p.value)
p=ggplot(CharTemp, aes(x=Batch, y=Val))+geom_boxplot()+facet_grid(~Calc)+ggtitle(sprintf("wilcox pval: Gini %s, Shannon %s, Top10 = %s", round(a1[2],2), round(a1[1],2), round(a1[3],2)))+geom_jitter(col="grey")+theme_bw()
print(p)

#write.csv(CharTemp, file="nature-tables/2h.csv")

DT::datatable(CharTemp, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

Next, we check whether this could be attributed to the total number of clones. Here is a plot which assesses whether these are similar or different

```{r 2h-nClones}

a1=sapply(unique(Nclonotypes2$Var2), function(x) wilcox.test(Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="tumor"], 
                                                             Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="mammary"])$p.value)

ann_text2 <- data.frame(lab=paste("p=", round(a1,4),sep=""), Var2=unique(Nclonotypes2$Var2), Case=1, value=2)
p=ggplot(Nclonotypes2, aes(x=Case, y=value))+geom_boxplot()+facet_grid(~Var2)+ggtitle("Nclonotype with different filters")+geom_jitter(col="grey")+theme_bw()+
  geom_text(data=ann_text2, aes(label=lab))
print(p)
```

What about association with size?

```{r Ext2e, fig.cap="clonotype assoc with size"}
CharTemp2=CharTemp[which(CharTemp$Batch=="1"), ]
midx=Cdata$Tumor.diameter.sac.mm[match(substr(as.character(CharTemp2$sample), 1, nchar(as.character(CharTemp2$sample))-5), Cdata$TumorID)]
CharTemp2$size=midx


ggplot(CharTemp2, aes(x=size, y=Val))+geom_point()+facet_grid(~Calc)+theme_bw()

#write.csv(CharTemp2, file="nature-tables/Ext2e.csv")
DT::datatable(CharTemp2, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```


```{r, eval=F}
ProgTemp=dfAll[which(dfAll$Type=="CD45" & dfAll$sample%in%infoTableFinal$SampleID[which(infoTableFinal$Cohort=="Progression")]), ]
a1=match(ProgTemp$sample, infoTable)
ProgTemp$Growth=infoTableFinal$Growth[a1]
ProgTemp$NewID=infoTableFinal$TumorIDnew[a1]
ProgTemp$Treatment=infoTableFinal$Treatment[a1]

Nclonotypes=TableOut[which(rownames(TableOut)%in%ProgTemp$sample), ]
Nclonotypes2=melt(Nclonotypes)
# Nclonotypes2$Case="tumor"
# Nclonotypes2$Case[grep("match", Nclonotypes2$Var1)]="mammary"
# Nclonotypes2$Case[grep("Control", Nclonotypes2$Var1)]="control"


head(Nclonotypes2)
#pdf(sprintf("rslt/TRUST4/compare_mammary_vs_tumor_%s.pdf", Sys.Date()), width=8, height=6)
#a1=sapply(unique(ProgTemp$Calc), function(x) wilcox.test(ProgTemp$Val[ProgTemp$Calc==x & ProgTemp$Batch==1], ProgTemp$Val[ProgTemp$Calc==x & ProgTemp$Batch=="match"])$p.value)

p=ggplot(ProgTemp, aes(x=Growth, y=Val))+geom_boxplot()+facet_grid(~Calc)+ggtitle(sprintf("wilcox pval: Gini %s, Shannon %s, Top10 = %s", round(a1[2],2), round(a1[1],2), round(a1[3],2)))+geom_jitter(col="grey")+theme_bw()
print(p)

DT::datatable(ProgTemp, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

#write.csv(ProgTemp, file="nature-tables/4i_clonotypes.csv")


# a1=sapply(unique(Nclonotypes2$Var2), function(x) wilcox.test(Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="tumor"], Nclonotypes2$value[Nclonotypes2$Var2==x & Nclonotypes2$Case=="mammary"])$p.value)
# 
# ann_text2 <- data.frame(lab=paste("p=", round(a1,4),sep=""), Var2=unique(Nclonotypes2$Var2), Case=1, value=2)
# p=ggplot(Nclonotypes2, aes(x=Case, y=value))+geom_boxplot()+facet_grid(~Var2)+ggtitle("Nclonotype with different filters")+geom_jitter(col="grey")+theme_bw()+
#   geom_text(data=ann_text2, aes(label=lab))
# print(p)


```

## Associate with clinicopathological data (progression)

We will associate the following metrics:

* total unique clones
* diversity

with the following immune data:

* CD45 fraction (from FACS)
* CD8 fraction (from WSI)
* MH-mixing indices
* Tumor Size
* Growth
* Treatment

```{r}
matchidx=match(rownames(TableOut), infoTableFinal$SampleID)

TrustTab=infoTableFinal[matchidx, ]
```


```{r trust-progression, fig.cap="4i: trust result"}
TrustTab$TrustNclonotypes=TableOut[match(TrustTab$SampleID, rownames(TableOut)) ,2]
TrustTab$TrustShannon=dfAll$Val[match(TrustTab$SampleID, dfAll$sample) ]
TrustTab$TrustTop10=df2$Val[match(TrustTab$SampleID, df2$sample)]
TrustTab$TrustGini=dfAll$Val[which(dfAll$Calc=="Gini")[match(TrustTab$SampleID, dfAll$sample)] ]
TrustTab$CD45FACS=as.numeric(as.character(Cdata$CD45.Frac.FACS[match(TrustTab$TumorID, Cdata$TumorID)]))
TrustTab$UnclassFrac=as.numeric(as.character(Cdata$UnclassFraction[match(TrustTab$TumorID, Cdata$TumorID)]))
CD45F=which(TrustTab$Fraction=="CD45")
#TrustTab=TrustTab[TrustTab$Fraction=="CD45", ]

paramSearch=c("CD8Frac", "TumSize", "CD45FACS", "MHEpCAM", "MHSMA", "IFEpCAM", "IFSMA", "UnclassFrac")
FeatTrust=c("TrustNclonotypes", "TrustShannon", "TrustGini", "TrustTop10")

Nclon=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[ CD45F,c("TrustNclonotypes")], use="complete", method="spearman")$p.value)
SDiv=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[CD45F ,c("TrustShannon")], use="complete", method="spearman")$p.value)
GDiv=sapply(paramSearch, function(x) cor.test(TrustTab[ CD45F,x], TrustTab[CD45F ,c("TrustGini")], use="complete", method="spearman")$p.value)
TDiv=sapply(paramSearch, function(x) cor.test(TrustTab[CD45F ,x], TrustTab[CD45F ,c("TrustTop10")], use="complete", method="spearman")$p.value)

AllSmerge=rbind(Nclon, SDiv, GDiv, TDiv)

#pdf(sprintf("rslt/TRUST4/association_trustmetrics_clinicopathological_%s.pdf", Sys.Date()), width=10, height=8)

heatmap.2(AllSmerge, scale="none", col=RdBu[11:1], trace="none", main="p values of associations")

par(mfrow=c(2,2))
idx=which(AllSmerge<0.1, arr.ind=T)
for (i in 1:nrow(idx)){
  a1=cor.test(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], use="complete", method="spearman")
  plot(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], xlab=FeatTrust[idx[i, 1]], ylab=paramSearch[idx[i, 2]],
       main=sprintf("cor:%s p:%s", round(a1$estimate,2), round(a1$p.value,2)))
  text(TrustTab[CD45F , FeatTrust[idx[i, 1]]]  ,TrustTab[CD45F , paramSearch[idx[i, 2]]], rownames(TrustTab)[CD45F], cex=0.75)
}

#pdf("~/Desktop/4L-TRUST-rslt-associate-outcome-progression.pdf", height=8, width=8)

CD45F2=which(TrustTab$Fraction=="CD45" & TrustTab$Cohort=="Progression")

yvals=c("TrustNclonotypes", "TrustShannon", "TrustGini", "TrustTop10")
## associate with growth and treatment type
par(mfrow=c(2,2))
CD45F2a=which(TrustTab$Fraction=="CD45" & TrustTab$Cohort=="Progression" & 
                TrustTab$Treatment%in%c("Vehicle", "PDL1"))
a1=sapply(yvals, function(x) wilcox.test(TrustTab[CD45F2a ,x]~TrustTab[CD45F2a, "Treatment"])$p.value)
CD45F2a=which(TrustTab$Fraction=="CD45" & TrustTab$Cohort=="Progression" & 
                TrustTab$Treatment%in%c("Vehicle", "LY"))
b1=sapply(yvals, function(x) wilcox.test(TrustTab[CD45F2a ,x]~TrustTab[CD45F2a, "Treatment"])$p.value)
CD45F2a=which(TrustTab$Fraction=="CD45" & TrustTab$Cohort=="Progression" & 
                TrustTab$Treatment%in%c("Vehicle", "PDL1+LY"))
c1=sapply(yvals, function(x) wilcox.test(TrustTab[CD45F2a ,x]~TrustTab[CD45F2a, "Treatment"])$p.value)


TrustTabmelt=melt(TrustTab[CD45F2, ], measure.vars=c("TrustNclonotypes", 
                                                     "TrustShannon", "TrustGini"))
```



```{r 4i, fig.cap="trust treatment"}
tablex=TrustTab[CD45F2, c("Treatment", "Growth", "TrustNclonotypes", 
                          "TrustShannon", "TrustTop10", "TrustGini")]
tablexM=melt(tablex)

ggplot(tablexM, aes(x=Treatment, y=value, col=Treatment))+geom_boxplot()+geom_point()+facet_wrap(~variable, scales="free")+scale_colour_manual(values=c(ColMerge[ ,1], "black"))+theme_bw()

#write.csv(tablexM, file="nature-tables/4i_trust-treatment.csv")
DT::datatable(tablexM, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

```{r}
print('P values PDL1')
a1
print('P values LY')
b1
print('P values PDL1+LY')
c1
```


```{r 4ib, fig.cap="trust growth"}
#pdf("figure-outputs/4I_BCR_clonotypes.pdf", height=8, width=5)

ggplot(tablexM, aes(x=Growth, y=value, col=Growth))+geom_boxplot()+geom_point()+facet_wrap(~variable, scales="free")+scale_colour_manual(values=c(ColSizeb, "black"))+theme_bw()
#dev.off()
#par(mfrow=c(2,2))

a1=sapply(yvals, function(x) wilcox.test(TrustTab[CD45F2 ,x]~TrustTab[CD45F2, "Growth"])$p.value)

print('p values here')
a1

```

## Associate with signature scores

Compare to B cell counts and activation status based on RNA-seq

* B cell signature enrichments scores (from RNA data)

```{r}
bidx=grep("B cell", output1$cell_type)
idx2=match(TrustTab$SampleID, colnames(output1))

Bsig=output1[bidx, na.omit(idx2)]
rownames(Bsig)=output1$cell_type[bidx]


Bassoc=sapply(FeatTrust, function(y) sapply(1:nrow(Bsig), function(x) cor( t(Bsig[x, ]),(TrustTab[CD45F, y]), use="complete", method="spearman")))
Bassoc2=sapply(FeatTrust, function(y) sapply(1:nrow(Bsig), function(x) cor.test( t(Bsig[x, ]),(TrustTab[CD45F, y]), use="complete", method="spearman")$p.value))
rownames(Bassoc)=rownames(Bsig)

BassocM=Bassoc
BassocM[which(Bassoc2<0.1, arr.ind=T)]=0


#pdf(sprintf("rslt/TRUST4/association_Bcell_signatures_%s.pdf", Sys.Date()), width=7, height=6)
par(oma=c(3, 0,0,5))
heatmap.2(Bassoc, scale="none", trace="none", col=RdBu[11:1], main="correlation")
heatmap.2(BassocM, scale="none", trace="none", col=RdBu[11:1], main="significant associations p<0.1 only")
#dev.off()
```

* B cell frequencies based on FACS:

```{r}
lx1=match(colnames(Fdata), gsub("_", "", unlist(strsplit( rownames(TrustTab), "_CD45"))))

#pdf(sprintf("rslt/TRUST4/BCR_association_FACS_%s.pdf", Sys.Date()), width=8, height=8)
par(mfrow=c(2,2))
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustNclonotypes[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustNclonotypes[lx1], xlab="B cell FACS fraction", ylab="# clonotypes", main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2) ,sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustNclonotypes[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustShannon[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustShannon[lx1], xlab="B cell FACS fraction", ylab="Shannon Index",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustShannon[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustGini[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustGini[lx1], xlab="B cell FACS fraction", ylab="Gini Index",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustGini[lx1], TrustTab$TumorID[lx1])
a1=cor.test(as.numeric(t(Fdata[ 9, ])), TrustTab$TrustTop10[lx1], use="complete")
plot(t(Fdata[ 9, ]), TrustTab$TrustTop10[lx1], xlab="B cell FACS fraction", ylab="Top10",  main=paste("cor:", round(a1$estimate, 2), " p:", round(a1$p.value,2),sep=""))
text(t(Fdata[ 9, ]), TrustTab$TrustTop10[lx1], TrustTab$TumorID[lx1])
#dev.off()

```

<!--chapter:end:13-clonotype.Rmd-->

# Whole Genome Sequencing Mutations

Whole genome sequencing was performed on XX samples by the new york genome centre.
The pipeline involves:

<span style="color:red"> Insert information on the NYGC pipeline here </span>

## Data 

In this section, we load the maf output files and create lists which

* filter out coding mutations
* Determine mutational signatures by:
    * Creating bed files with genomic locations of the SNP +- 1 base location
    * Extracting the nucleotide sequence using bedtools
    * Convert all mutations to C > N and T > N to obtain 96 mutational signatures
    * run with single sample SigProfiler to obtain the signature scores
* Annotate data with common human variants

```{r, load-mutations, cache=T}
# Load and save for the first time here
# redo

mafdir='../data/wholegenome_mutations/maf/'
x1=dir(mafdir, 'annotated.maf')
#names2=sapply(strsplit( x1,"--"), function(x) x[1])
AllMutWGS=lapply(x1, function(x) read.delim(paste(mafdir, x, sep=""), sep="\t", skip = 1))
names(AllMutWGS)=sapply(strsplit( x1,"--"), function(x) x[1])
# # ## summary of the number of mutations?
print('no of mutations')
TotCount=lapply(AllMutWGS, nrow)

SearchVars=c("Splice_Site", "Nonstop_Mutation", "Nonsense_Mutation", "Missense_Mutation", "Frame_Shift_Ins", "Frame_Shift_Del")

AllMutWGS=lapply(AllMutWGS, function(x) {x$VAF<-x$t_alt_count/(x$t_alt_count+x$t_ref_count); x})

AllMutWGScoding=lapply(AllMutWGS, function(x) x[ x$Variant_Classification%in%SearchVars, ])
A2=sapply(AllMutWGScoding, nrow)

# Save the combined mutation lists
save(AllMutWGS, AllMutWGScoding, file=sprintf("outputs/WGS_mutations_coding_%s.RData", Sys.Date()))

## filters on VAF and depth?
AllMutWGScoding=lapply(AllMutWGScoding, function(x) {x<-x[which(x$VAF>=0.1 & x$n_ref_count>8 &
                                                                    (x$t_alt_count+x$t_ref_count)>14), ]; x})

#load('data/wholegenome_mutations/WGS_mutations_coding_2020-10-14.RData')
MeltWGSCoding=melt(AllMutWGScoding, measure.vars=c("Tumor_Sample_Barcode"))
MeltWGSCoding$Hum_Gene=SymHum2Rat$HGNC.symbol[match(MeltWGSCoding$Gene_Symbol, SymHum2Rat$RGD.symbol)]
MeltWGSCoding$Hum_Gene[which(is.na(MeltWGSCoding$Hum_Gene))]=toupper(MeltWGSCoding$Gene_Symbol[which(is.na(MeltWGSCoding$Hum_Gene))])
MutAllCosmic=lapply(AllMutWGScoding, function(x) x[which(x$Gene_Symbol%in%RatCosmic), ])
MeltCosmic=melt(MutAllCosmic, measure.vars=c("Tumor_Sample_Barcode"))
```

```{r}
# Find complete numbers here, so we don't have to go back 
TotCount=sapply(AllMutWGS, nrow)
SearchVars=c("Splice_Site", "Nonstop_Mutation", "Nonsense_Mutation", "Missense_Mutation", "Frame_Shift_Ins", "Frame_Shift_Del")

head(TotCount)
```

### Extract mutation signatures

Annotate the files so that the nucleotide codon can be extracted based on the genome file. 
For this, use all mutations (not just coding ones)
See the bash file extract-trinucleotide-forSigProfiler.sh to see the output of this.
The output table $fout3 should have 6 columns with the genomic location, the reference and alt allele and codon context.

```{r, eval=F, echo=T}
TBed=lapply(AllMutWGScoding, function(x) cbind(as.character(x$Chromosome), x$Start_Position-2, x$End_Position+1, as.character(x$Reference_Allele), as.character(x$Tumor_Seq_Allele2)))
TBed=lapply(TBed, function(x) x[which(nchar(x[ ,4])==1), ])
sapply(1:length(TBed), function(x) write.table(TBed[[x]], file=paste(names(TBed)[x], "coding_tricodon.bed", sep="_"),col.names=F, row.names = F, sep="\t", quote = F))

## bedtools command
bedtools getfasta -fi ../Genomic_Files/rn6.fa -bed $f -tab -fo $fout
f3() { awk '{print $1, $2, $3, $4 ,$5}' "$1"; }; paste <(f3 $f) <(f3 $fout) > $fout2
awk '{if (length($7)==3) print $1, $2, $3, $4, $5, toupper($7)}' $fout2 > $fout3
## see the bash file extract-trinucleotide-forSigProfiler.sh to see the output of this.
```

Following running the above bash script, we can run the following extract the tri-nucleotide sequence

```{r 1j, fig.cap="Frequency of different mutational codons"}
FFiles=dir("../data/tricodon_mut_sigs/extract_context/", "*.txt",full.names=T)
OutputList=sapply(FFiles, function(x) FindTriNucleotideContext(x))
TableOut=sapply(1:ncol(OutputList), function(x) unlist(OutputList[3, x]))
## make a plot here
# condense the type of mutations here
a1=basename(FFiles)
a2=sapply(strsplit(a1, "_"), function(x) x[1])
xall=as.character(unlist(OutputList[1, 1]))
TestAll=sapply(1:ncol(TableOut), function(x) unlist(by(TableOut[ ,x], xall, sum)))
TestAll2=t(TestAll)/colSums(TestAll)
rownames(TestAll2)=sapply(a2, function(x) Cdata$NewID[grep(x,  Cdata$WGS)])
TestAll2melt=melt(TestAll2)

#pdf("~/Desktop/Frequency_mutations_6types.pdf", height=5, width=6)
ggplot(TestAll2melt, aes(x=Var1, y=value, fill=Var2))+geom_bar(stat="identity")+theme_bw()+theme(axis.text.x=element_text(angle=90))+ylab("Frequency of Mutation")
#dev.off()


write.csv(TestAll2melt, file="nature-tables/1j.csv")

TableOut=cbind(as.character(unlist(OutputList[1, 1])), as.character(unlist(OutputList[2, 1])), TableOut)
colnames(TableOut)=c("MutationType","Nutrinucleotide", paste("BRCA", a2, sep="::"))
#write.csv(TableOut, file="../data/tricodon_mut_sigs/output4SigProfiler-jan2021.csv", sep = ",", row.names = F)
```

This is then run in python (sigprofiler) with the following code:

```{r,eval=F, echo=T}
module load gcc
module load python/3.7.4
python3
import SigProfilerExtractor
from sigproSS import spss_pcwag ## (spss uses only vcf files)
spss_pcwag.single_sample_pcwag("output4SigProfiler-jan2021.csv", output="output-jan2021")
```

The results from this analysis are shown below

```{r Ext1j, fig.cap="Alexandrov mutational signatures"}
SBSprof=read.delim("../data/tricodon_mut_sigs/output-jan2021-allsamples/sig_activities.txt", sep="\t")
SBSprofb=SBSprof[ ,-1]/rowSums(SBSprof[ ,-1])
SBSprofb=SBSprofb[ ,-which(colSums(SBSprofb)==0)]
rownames(SBSprofb)=SBSprof[ ,1]

SBSmelt=melt(cbind(SBSprofb[ , -1], id=rownames(SBSprofb)))
SBSsummary <- aggregate(. ~ variable, mean, data=SBSmelt)

ggplot(SBSmelt, aes(x=variable, y=value, col=variable))+geom_jitter()+geom_crossbar(data=SBSsummary , aes(ymin = value, ymax = value),size=0.5,col="black", width = .7)+theme_bw()+ylab("Percentage of mutations")

write.csv(SBSmelt, file="nature-tables/Ext1j.csv")
```

We can see whether any of these associate with tumor size for example:

```{r}
## Assign with growth data or tumor size?
tname=substr(SBSprof$Cancer.Types, 7, 20)
idx=sapply(tname, function(x) grep(x, Cdata$WGS))
sizeInfo=Cdata$Tumor.diameter.sac.mm[idx]

#par(mfrow=c(2,1))
cor1=cor.test(SBSprofb$SBS32+SBSprofb$SBS11, sizeInfo, use="complete")
cor2=cor.test(SBSprofb$SBS32[which(SBSprofb$SBS32>0)], sizeInfo[which(SBSprofb$SBS32>0)], use="complete")
cor3=cor.test(SBSprofb$SBS11[which(SBSprofb$SBS11>0)], sizeInfo[which(SBSprofb$SBS11>0)], use="complete")
plot(SBSprofb$SBS32+SBSprofb$SBS11, sizeInfo, xlab="SBS 32 or 11 score", ylab="tumor size",
     col=ifelse(SBSprofb$SBS11==0, "red", "blue"), main=sprintf("association between signature score and size, p=%s", round(cor1$p.value, 2)))
legend("topleft",c(paste("SB32", round(cor2$p.value,2)), paste("SB11",round(cor3$p.value,2))), col=c("red", "blue"), lwd=2, pch=19)

## Associations version 2
SBSprofb$Age=Cdata$Time.NMU2Sac.days[sapply(substr(rownames(SBSprofb), 7, 30), function(x) grep(x, Cdata$WGS))]
SBSprofb$Cohort=Cdata$Char.Cohort.Batch[sapply(substr(rownames(SBSprofb), 7, 30), function(x) grep(x, Cdata$WGS))]

par(mfrow=c(2,2))
plot(SBSprofb$Age,SBSprofb$SBS1,  ylab="Frequency Mut in SBS1", xlab="Time NMU2Sac", main="SBS1", col=factor(SBSprofb$Cohort))
plot( SBSprofb$Age, SBSprofb$SBS5, ylab="Frequency Mut in SBS5", xlab="Time NMU2Sac", main="SBS5", col=factor(SBSprofb$Cohort))
plot(SBSprofb$Age, SBSprofb$SBS32+SBSprofb$SBS11, ylab="SBS 32 or 11 score", xlab="tumor size",
     col=ifelse(SBSprofb$SBS11==0, "red", "blue"), main="SBS11/32")


```

## Annotate the data with human common variants

```{r, find-mut-variant, cache=T, eval=F}
## The following is run independently and saved to fle
## issues with the RnvorV87 pointer when cached
# remove sourcing CreateRnor87
## Append to MeltCosmic?
source("../rscript/CreateRnor87db.R")
AAout=strsplit(as.character(MeltCosmic$HGVSp_Short), "[0-9]+")
AAwt=sapply(AAout, function(x) x[1])
AAmt=sapply(AAout, function(x) x[2])
AAno=regmatches(MeltCosmic$HGVSp_Short, gregexpr("[[:digit:]]+", MeltCosmic$HGVSp_Short))

MeltCosmic$AAno=NA
MeltCosmic$AAno[which(sapply(AAno, length)==1)]=as.numeric(as.character(unlist(AAno)))
FindVarTest=FindHumanAAHomolog(MeltCosmic$Gene_Symbol, AAwt, MeltCosmic$AAno, AAmt)
MeltCosmic=cbind(MeltCosmic, FindVarTest)

dim(MeltCosmic)

save(MeltCosmic, file=sprintf("outputs/MeltCosmic_coding_genes_WGS_rat_VAFncount%s.RData", Sys.Date())) #, sep="\t", row.names=F)
write.csv(MeltCosmic, file="nature-tables/SupplementalTable4_AllRatMutations_annotated_w_human_homolog_VAFncount.csv", row.names = F, quote=F)
```

From this analysis, below are the genes with mutations in known human hotpot mutations in common genes

```{r loadOldVAFs, cache=T}

load("outputs/MeltCosmic_coding_genes_WGS_rat_VAFncount2021-01-11.RData")

Xa=which(MeltCosmic$Gene_Symbol %in% BList$RatGene)
Xb=match(paste(MeltCosmic$Gene_Symbol, MeltCosmic$AAno), paste(BList$RatGene,BList$RatAAno))
Xc=match(paste(MeltCosmic$Gene_Symbol, MeltCosmic$AAno), paste(ChangList2$RatGene, ChangList2$RatAAno))
x2=c(which(!is.na(Xb)), which(!is.na(Xc)))

BList[(na.omit(Xb)), ]
ChangList2[(na.omit(Xc)), ]

Xb=match(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno), paste(BList$Gene,BList$AAno))
Xc=match(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno), paste(ChangList2$Gene, ChangList2$AAno))
x3=c(which(!is.na(Xb)), which(!is.na(Xc)))
x4=unique(c(x2, x3))
DT::datatable(MeltCosmic[x4, c(1,5,6)], rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

BList[(na.omit(Xb)), ]
ChangList2[(na.omit(Xc)), ]


```

And here, we plot the frequency of these different mutations

```{r Ext1k, fig.cap="most frequent mutations"}
idx=which(!is.na(MeltCosmic$HumAAno))
length(idx)
Nx=paste(MeltCosmic$Gene[idx], MeltCosmic$AAno[idx])
T2=sort(table(Nx), decreasing = T)
#head(T2)

ind2=which(T2>1)
#pdf("~/Desktop/Frequency_of_mutations.pdf", height=6, width=9)
barplot(T2[ind2]/31, ylim=c(0, 1), main="most frequent coding mutations with human homolog", las=2)
#dev.off()

ttemp=names(T2[ind2])
```


```{r}
Nx=paste(MeltCosmic$Gene, MeltCosmic$AAno)
T2=sort(table(Nx), decreasing = T)
ind2=which(T2>1)
#pdf("~/Desktop/Frequency_of_mutations_2.pdf", height=6, width=9)
barplot(T2[ind2]/31, ylim=c(0, 1), main="most frequent coding mutations ", las=2)
#dev.off()

tableout=data.frame(gene=names(T2[ind2]), ncount=T2[ind2], freq=T2[ind2]/31,
                    humanHom=ifelse(names(T2[ind2])%in%ttemp, 1, 0))

#write.csv(tableout, file="nature-tables/Ext1k_maybe.csv")
DT::datatable(tableout, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))
```

We can also use the [cosmic mutational database](https://cancer.sanger.ac.uk/cmc/home) to see whether any of these mutations overlap: (version 92)

```{r cosmic-mut, cache=T}
Cmut=read.delim("../anntotations/cmc_export.v92.tsv")

```

Edit the stuff here:

```{r eval-cmut}
Ax1=match(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno), paste(Cmut$GENE_NAME, Cmut$AA_MUT_START))
Ax1
head(paste(MeltCosmic$HumGene, MeltCosmic$HumAAno))
head(paste(Cmut$GENE_NAME, Cmut$AA_MUT_START))
tempA=Cmut[ na.omit(Ax1), c("GENE_NAME","Mutation.CDS", "Mutation.AA", "CLINVAR_CLNSIG")]
DT::datatable(tempA, 
              rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

write.csv(tempA, file="nature-tables/CosmicMutCensus_mutations.csv")
```

## Plots

### Quick overview

WGS all mutations summary: Look at the overall mutation burden, and the tumor mutational burden, defined as # coding mutations per MB.

The following plot lists tumors in increasing size

Make plots of:

* overall types of mutations per sample (ranked by size)
* correlation between mutation type and size
* type of mutation?

```{r 1i, fig.cap="summary of mutation burden" }
#load("data/wholegenome_mutations/WGS_mutations_coding.RData")

TabSamples=lapply(AllMutWGScoding, function(x) table(factor(x$Variant_Classification, levels=SearchVars)))
TabSamples2=unlist(TabSamples)
namidx=sapply(strsplit(names(TabSamples2), "\\."), function(x) x[1])
namidx2=sapply(strsplit(names(TabSamples2), "\\."), function(x) x[2])
namidx3=sapply(namidx, function(x) Cdata$NewID[grep(x, Cdata$WGS)])
TotTabl=data.frame(val=TabSamples2, nam=namidx, variant=namidx2, nam2=namidx3)

## remove 0 samples
# searchNo=stack(by(TotTabl$val, TotTabl$variant, sum))
# TotTabl=TotTabl[ which(TotTabl$variant %in% searchNo$ind[which(searchNo$values!=0)]), ]

lx1=match(TotTabl$nam2, Cdata$NewID, function(x) tryCatch({x[1]}, error=function(e){NA}))
TotTabl$Size=Cdata$Tumor.diameter.sac.mm[lx1]

TotTabl=TotTabl[order(TotTabl$Size, TotTabl$val), ]

levelNam=unique(TotTabl$nam2)

TotTabl$nam2=factor(TotTabl$nam2, levels=levelNam)
##pdf(sprintf("rslt/WGS/coding_mutation_types_%s.pdf", Sys.Date()), height=6, width=9)
#pdf("~/Desktop/No_mutations_VAFncount_adjusted_TMB.pdf", height = 5, width=7)
ggplot(TotTabl, aes(x=nam2, y=val/43.423804, fill=variant))+geom_bar(stat="identity")+scale_fill_manual(values=c("black", brewer.pal(9, "Set1")))+theme_bw()+theme(axis.text.x=element_text(angle=90))+ylab("Number of coding mutations/Mb")+ggtitle("sorted by increasing tumor size at sac")
#dev.off()

#write.csv(TotTabl, file="nature-tables/1i.csv")
DT::datatable(TotTabl, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))

```

We can also see whether any of these correlate with size, but didn't find associations as shown below:

```{r}
ax1=lapply(sort(SearchVars), function(x) cor.test(TotTabl[TotTabl$variant==x , "val"], TotTabl[TotTabl$variant==x ,  "Size"], use="complete", method="spearman")) 
pvals=sapply(ax1, function(x) x$p.value)
cors=sapply(ax1, function(x) x$estimate)

ann_text2 <- data.frame(lab=paste("cor=", round(cors, 2),"p=", round(pvals,2),sep=""), variant=sort(SearchVars),  val=1, Size=5)

ggplot(TotTabl, aes(x=Size, y=val, col=variant))+geom_point()+facet_wrap(~variant, scale="free")+geom_text(data=ann_text2, aes(label=lab))

#dev.off()
#MeltWGSCoding=melt(AllMutWGScoding, measure.vars=c("Tumor_Sample_Barcode"))
```

### Coding variants & TMB

There are a few ways of figuring out the TMB. We can

* report the number of mutations (missense, insertion/deletion, frameshifts, nonsense)
* normalise the above value to the known length of coding regions in the rat genome (UCSC exon length 43,423,804)
* plot of TMB vs objective response rate: there is no true relationship between final tumor size and mutational burden. Could also be confounded by subclonality

```{r 1ib, fig.cap="summary of mutational burden?"}
searchThese=c("Missense_Mutation", "Nonsense_Mutation", "Frame_Shift_Del", "Frame_Shift_Ins", "Nonstop_Mutation")
NVar2=TotTabl[TotTabl$variant%in%searchThese, ]
Ntot=by(NVar2$val, NVar2$nam, sum)
# check this is unique based on the location
Ntot2=stack(Ntot)
colnames(Ntot2)[1]="NCodingMut"
Ntot2$TMB=Ntot2$NCodingMut/43.423804
TotMut=sapply(AllMutWGS, nrow)
Ntot2$TotalMut=TotMut[match(Ntot2$ind, names(TotMut))]
Ntot2$Tum.size=TotTabl$Size[match(Ntot2$ind, TotTabl$nam)]
Ntot2=Ntot2[order(Ntot2$Tum.size), ]
#Ntot2$normCov=Ntot2$values/43.423804

Ntot2$NsynFreq=Ntot2$NCodingMut/Ntot2$TotalMut
Ntot2$ID2=sapply(Ntot2$ind, function(x) Cdata$NewID[grep(x, Cdata$WGS)])
Ntot2=Ntot2[order(Ntot2$Tum.size), ]

IDfact=Ntot2$ID2
Ntot2$cohort=Cdata$Char.Cohort.Batch[match(Ntot2$ID2, Cdata$NewID)]


Ntot2melt=melt(Ntot2)
Ntot2melt$ID2=factor(Ntot2melt$ID2, levels=IDfact)

#pdf(sprintf("~/Desktop/frequency_mutational_types_VAF_ncount#2_%s.pdf", Sys.Date()), height=10, width=6)
ggplot(Ntot2melt, aes(x=ID2, y=value, col=variable))+geom_bar(stat="identity")+facet_grid(variable~., scale="free_y")+
  theme_bw()+theme(axis.text.x=element_text(angle=90))
#dev.off()
write.csv(Ntot2melt, file="nature-tables/1i_maybe.csv")
## As a metric for TMB, comapre the number of mutations to the covered genome
```

Calculate whether there is an association of TMB with cohort type:

```{r Ext1h, fig.cap="assoc of mutations with cohort"}
Ntot2melt$size2=Cdata$Tumor.diameter.sac.mm[match(Ntot2melt$ID2, Cdata$NewID)]

ax1=lapply(sort(SearchVars), function(x) cor.test(TotTabl[TotTabl$variant==x , "val"], TotTabl[TotTabl$variant==x ,  "Size"], use="complete", method="spearman")) 
pvals=sapply(ax1, function(x) x$p.value)
cors=sapply(ax1, function(x) x$estimate)


# p value calculation: figure out the latency and penetrance

pvalOutputs=sapply(c("NCodingMut", "TMB", "TotalMut","Tum.size",
                     "NsynFreq") , function(x) t.test(Ntot2[ Ntot2$cohort!="cohort-2",x]~ Ntot2$cohort[Ntot2$cohort!="cohort-2"])$p.value)

# cohort size calculation
corOutputs=sapply(c("NCodingMut", "TMB", "TotalMut",
                     "NsynFreq") , function(x) cor.test(Ntot2[ ,x], Ntot2$Tum.size)$p.value)


#pdf("~/Desktop/Supp_1G-H_WGS_mutations_assoc_clinico.pdf", width=8, height=5)

ann_text2 <- data.frame(lab=paste("p=", round(pvalOutputs, 2)), val=1, Size=5, cohort="latency-4",
                        variable=c("NCodingMut", "TMB", "TotalMut", "Tum.size","NsynFreq"))

ggplot(Ntot2melt, aes(x=cohort, y=value, col=cohort))+geom_boxplot()+geom_point()+facet_wrap(~variable, scale="free_y")+theme_bw()+theme(axis.text.x=element_text(angle=90))+geom_text(data=ann_text2, aes(label=lab, x=1, y=0))
```

```{r}
ann_text2 <- data.frame(lab=paste("p=", round(corOutputs, 2)), val=1, Size=5, cohort="latency-4",
                        variable=c("NCodingMut", "TMB", "TotalMut",
                     "NsynFreq"))

ggplot(Ntot2melt, aes(x=size2, y=value, col=cohort))+geom_point()+facet_wrap(~variable, scale="free_y")+theme_bw()+theme(axis.text.x=element_text(angle=90))+geom_text(data=ann_text2, aes(label=lab, x=10, y=0))
#dev.off()

write.csv(Ntot2melt, file = "nature-tables/Ext1h-i.csv")
```


```{r, eval=F}
# To obtain an idea of the coverage:
Using bedtools and samtools
here, counting only "propoet pairs" with maping quality greater than 30
see (https://www.biostars.org/p/11105/)
samtools view -u -q 30 -f 0x2 aln.bam | coverageBed -abam stdin -b exons.bed > exons.bed.proper.q30.coverage
```

## Comparison with rat mutational datasets

### Sites which are commonly mutated?

Could this be a variant (SD strain "rsSNP") or is it actually a mutation? 

Variants were annotated with snpeff. Raw data from this was obtained from https://www.biorxiv.org/content/10.1101/412924v1.full

```{r mod-vcfs, eval=F}

harlanRats=read.vcfR("~/Desktop/carlos_study_files/allChr.allSamps.90DR2.maf01.hweE7.noIBD.HarlanOnly.vcf.gz")
harlanRats@fix[ ,1]=paste("chr", harlanRats@fix[ ,1], sep="")
harlanRats@fix[ ,3]=paste("H", harlanRats@fix[ ,3], sep=".")
harlanRats@meta=harlanRats@meta[-grep("##contig",harlanRats@meta )]

# figure out the genotype distribution
GT=sapply(1:nrow(harlanRats@gt), function(x) 
  table(factor(harlanRats@gt[x, -1],levels=c("0/0","0/1","1/1"))))
GT2=paste(GT[1, ], GT[2, ], GT[3, ], sep=",")
GT3=paste(GT[1, ]/2281, GT[2, ]/2281, GT[3, ]/2281, sep=",")

GenotypeS=cbind(FORMAT="GT", Annot=c("0/0,0/1,1/1"), GT2, GT3 )
harlanRats@gt=GenotypeS
## save this to file or something
write.vcf(harlanRats, file="~/Desktop/dbSNP_info/harlan_snps_mod_1-5-2020.vcf.gz")

# loading the charles river rat snp sites
CRRats=read.vcfR("~/Desktop/dbSNP_info/charles_river_200Ksnps.gz")
CRRats@fix[ ,1]=paste("chr", CRRats@fix[ ,1], sep="")
CRRats@fix[ ,3]=paste("CR", CRRats@fix[ ,3], sep=".")
CRRats@meta=CRRats@meta[-grep("##contig",CRRats@meta )]

crGT=sapply(1:nrow(CRRats@gt), function(x) 
  table(factor(CRRats@gt[x, -1],levels=c("0/0","0/1","1/1"))))
crGT2=paste(crGT[1, ], crGT[2, ], crGT[3, ], sep=",")
crGT3=paste(crGT[1, ]/1780, crGT[2, ]/1780, crGT[3, ]/1780, sep=",")
GenotypeS=cbind(FORMAT="GT", Annot=c("0/0,0/1,1/1"), crGT2, crGT3 )
CRRats@gt=GenotypeS
write.vcf(CRRats, file="~/Desktop/dbSNP_info/charlesRiver_snps_mod_1-5-2020.vcf.gz")
```

Note that the nihRats package may not be required here. We probably just want the harlan snps

```{r, load-snps-database, cache=T, message=F, warning=F, results='hide'}
# loading known list of rat snp sites
nihRats=read.vcfR("../anntotations/dbSNP/rat_10116_00-All.wchr.SDsort.vcf.gz")
#nihRats@fix[ ,1]=paste("chr", nihRats@fix[ ,1], sep="")
r=regexpr("[a-z]+_[a-z]+",nihRats@fix[ ,8]) #ANN=[A-Z]\\|
ModType=rep(NA, length(nihRats@fix[ ,8]))
ModType[r!=-1]=regmatches(nihRats@fix[ ,8], r)
#ModType=substr(ModType, 7, 25)
# Harlan samples
harlanRats=read.vcfR("../anntotations/dbSNP/harlan_snps_mod_1-5-2020.SDsort.vcf.gz")

GT3=crGT3=1-as.numeric(sapply(strsplit(harlanRats@gt[ ,4], ","), function(x) x[1]))

r=regexpr("ANN=[A-Z]\\|[a-z]+_[a-z]+", harlanRats@fix[ ,8])
HarType=rep(NA, length(harlanRats@fix[ ,8]))
HarType[r!=-1]=regmatches(harlanRats@fix[ ,8], r)
HarType=substr(HarType, 7, 25)
# charles river samples
CRRats=read.vcfR("../anntotations/dbSNP/charlesRiver_snps_mod_1-5-2020.SDsort.vcf.gz")
crGT3=1-as.numeric(sapply(strsplit(CRRats@gt[ ,4], ","), function(x) x[1]))

r=regexpr("ANN=[A-Z]\\|[a-z]+_[a-z]+", CRRats@fix[ ,8])
CRType=rep(NA, length(CRRats@fix[ ,8]))
CRType[r!=-1]=regmatches(CRRats@fix[ ,8], r)

CRType=substr(CRType, 7, 25)
```



```{r}
# This is just a plot that compares the different databases.
## Look at the overlap between all the databases:
NIHr=paste(nihRats@fix[ ,1], nihRats@fix[ ,2])
harr=paste(harlanRats@fix[ ,1], harlanRats@fix[ ,2])
crr=paste(CRRats@fix[ ,1], CRRats@fix[ ,2])

# overview of the overlaps
venn(list(NIH=NIHr, harlan=harr, CR=crr))

## Annotate the above variants for protein coding regions first, then narrow down to known 
AllLevels=unique(c(HarType, CRType, ModType))
allTypes=rbind(table(factor(ModType, levels=AllLevels)), table(factor(HarType, levels=AllLevels)),
               table(factor(CRType, levels = AllLevels)))
rownames(allTypes)=c("NIH", "harlan", "CR")
allTypesNorm=allTypes/rowSums(allTypes)

t2=melt(allTypesNorm)
ggplot(t2[which(t2$value<0.04),  ], aes(x=Var1, y=value, fill=Var2))+geom_bar(stat = "identity")+ylab("frequency snp type")+xlab("dataset")
```


```{r}
SearchVars=c("missense_variant","stop_lost", "stop_gained", "initiator_codon", "start_lost", "frameshift_variant")
NIHr2=NIHr[which(ModType%in%SearchVars)]
harr2=harr[which(HarType%in%SearchVars)]
crr2=crr[which(CRType%in%SearchVars)]

venn(list(NIH=NIHr2, harlan=harr2, CR=crr2))
mtext("any coding variant", side=3)

## Genes affected
r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", harlanRats@fix[which(HarType%in%SearchVars),8])
codhrgrp=rep(NA, length(which(HarType%in%SearchVars)))
codhrgrp[r!=-1]=regmatches(harlanRats@fix[which(HarType%in%SearchVars),8], r)
codhrgrp=substr(codhrgrp, 1, nchar(codhrgrp)-8)

r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", CRRats@fix[which(CRType%in%SearchVars),8])
codcrgrp=rep(NA, length(which(CRType%in%SearchVars)))
codcrgrp[r!=-1]=regmatches(CRRats@fix[which(CRType%in%SearchVars),8], r)
codcrgrp=substr(codhrgrp, 1, nchar(codcrgrp)-8)

r=regexpr("[A-Za-z0-9\\.]+\\|ENSRNOG", nihRats@fix[which(ModType%in%SearchVars),8])
codnihgrp=rep(NA, length(which(ModType%in%SearchVars)))
codnihgrp[r!=-1]=regmatches(nihRats@fix[which(ModType%in%SearchVars),8], r)
codnihgrp=substr(codnihgrp, 1, nchar(codnihgrp)-8)

venn(list(NIH=codnihgrp, harlan=codhrgrp, CR=codcrgrp))
mtext("any cosmic coding variant", side=3)

## Look for Cosmic specific genes
codcrgrp2=codcrgrp[codcrgrp%in%RatCosmic]
codhrgrp2=codhrgrp[codhrgrp%in%RatCosmic]
codnihgrp2=codnihgrp[codnihgrp%in%RatCosmic] #c(RatBreastCosmic, codhrgrp2, "Tert", "Atm")]
```

Look at the distribution of mutations:

Whole genome

* 1188 genes in more than 2 animals (1435 in at least 2)
* 59 variants were identified as population variant in Harlan 
* 47 in charles river (6 are novel in this cohort only)

Cosmic genes:

* 42 sites which have mutations in more than 2 animals
* 50 sites in more than 1 animal
* 5 sites which have been identified in GWAS studies of harlan rats. On average, the variant is found at a frequency of ~15%. The CR set, these variants appear in 50\% of the population 
* 4 of the 5 rats from above were identified in 
* 0 sites in the nih dbSNP database for rats


```{r, eval=F}
# Check TGFBr polymorphisms:

r=grep("Tgfb", harlanRats@fix[,8])
harlanRatsTgfb=harlanRats[r]
write.vcf(harlanRatsTgfb, file="~/Desktop/harlanRats_Tgfb.vcf.gz")

r=grep("Tgfb", CRRats@fix[,8])
CRRatsTgfb=CRRats[r]
write.vcf(CRRatsTgfb, file="~/Desktop/CRRats_Tgfb.vcf.gz")

r=grep("Tgfb", nihRats@fix[,8])
nihRatsTgfb=nihRats[r]
write.vcf(nihRatsTgfb, file="~/Desktop/nih_Tgfb.vcf.gz")

```

Here, compare the frequencies of the most common mutations in our population with those reported in the harlan and charles river data-bases:

* filter out mutatations occuring in 2+ samples

```{r, pop-gen-plot}
Nsamp=1
## Firstly whole genome
lx1=table(paste(MeltWGSCoding$Chromosome, MeltWGSCoding$Start_Position))
lx1=sort(lx1, decreasing=T)
hist(lx1)
length(which(lx1>Nsamp))
WGSList=names(lx1)[which(lx1>Nsamp)]
WGSList=strsplit(WGSList, " ")
WGSList=data.frame(chr=sapply(WGSList, function(x) x[1]), pos=sapply(WGSList, function(x) x[2]), freq=lx1[which(lx1>Nsamp)])
WGSList$gene=as.character(MeltWGSCoding$Gene_Symbol[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$AA=as.character(MeltWGSCoding$HGVSp_Short[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$VariantClass=as.character(MeltWGSCoding$Variant_Classification[match(WGSList[ ,2], MeltWGSCoding$Start_Position)])
WGSList$Cosmic=ifelse(WGSList$gene%in%RatCosmic, 1, 0)

## Secondly, cosmic specific genes

## WGSList
midx=match(WGSList$freq.Var1, paste(harlanRats@fix[ ,1], harlanRats@fix[ ,2], sep=" "))
WGSList$HarlanFreq=GT3[midx]
midx=match(WGSList$freq.Var1, paste(nihRats@fix[ ,1], nihRats@fix[ ,2], sep=" "))
WGSList$rsID=nihRats@fix[midx, 3]
## CR
midx=match(WGSList$freq.Var1, paste(CRRats@fix[ ,1], CRRats@fix[ ,2], sep=" "))
WGSList$CRFreq=crGT3[midx]

WGSplot=melt(WGSList[ ,c("freq.Freq", "gene", "VariantClass", "HarlanFreq", "CRFreq", "Cosmic")], measure.vars = c("HarlanFreq", "CRFreq"))
WGSplot=WGSplot[-which(is.na(WGSplot$value)), ]

ggplot(WGSplot, aes(x=freq.Freq/16, y=value, col=VariantClass, label=WGSplot$gene))+facet_grid(~variable)+geom_point()+
  geom_text(size=(WGSplot$Cosmic+3), col="black", nudge_y=0.01)+xlab("Cohort frequency")+ylab("Database frequency")+theme_bw()+theme(legend.position="bottom")+ggtitle("all genes compared to Harlan Frequencies")

DT::datatable(WGSplot[WGSplot$Cosmic==1, ],class='cell-border stripe', extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

```


## Overview of the mutations 

### All mutations

SNPs are removed from this analysis: based on frequencies in the harlan cohort

Color codes:

* black:
* pink: 
* green:
* blue:

```{r}
palette(brewer.pal(9, "Set1"))

Nmut=86 ## was previously 92: this appears at least 17 times

rmHarlanSNP=WGSList[which(!is.na(WGSList$HarlanFreq)), ]
x1a=which(MeltWGSCoding$Gene_Symbol%in%rmHarlanSNP$gene &  MeltWGSCoding$Start_Position%in%rmHarlanSNP$pos)
MeltWGSCodingB=MeltWGSCoding[-x1a, ]

rGeneOut=acast(MeltWGSCodingB[ ,c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))

mxl=unique(as.vector(rGeneOut))
rGeneOut2=rGeneOut
rGeneOut2[grep("Nonsense",rGeneOut2)]=3
rGeneOut2[grep("Frame_Shift",rGeneOut2)]=2
rGeneOut2[grep("Missense_", rGeneOut2)]=1
rGeneOut2[grep("Splice_", rGeneOut2)]=4
rGeneOut2[which(rGeneOut2=="")]=0

rGeneOut2=apply(rGeneOut2, 2, as.numeric)
rownames(rGeneOut2)=rownames(rGeneOut) 

#get rid of genes which are associated with Olfactory receptors, AABR etc mutations
rmThese=c("^AABR", "^Olr", "^LOC", "^AC[0-9]+", "^RGD", "^Rpl", "^1700", "^RT1", "^ENSRNOG", "^Vom2")
rmList=unlist(sapply(rmThese, function(x) grep(x, colnames(rGeneOut2))))
rGeneOut2=rGeneOut2[ ,-rmList]

GeneList=colSums(sign(rGeneOut2), na.rm=T)
samp2=rowSums(sign(rGeneOut2), na.rm=T)
rGeneOut2=rGeneOut2[ order(samp2, decreasing=T),]

topN=names(sort(GeneList, decreasing=T)[1:Nmut])

# do a plot of the top 30 most common mutations
tempx=rGeneOut2[ ,topN]
a2=heatmap(tempx, col=c("white", 1:9), scale="none", main="all mutations in cosmic")
RowSC=ifelse(colnames(tempx)%in% c(RatCosmic, as.character(AllCancerPathwayGenes)), "black", "white")

heatmap.2(tempx, Rowv = NA, Colv = NA,scale="none", trace="none", col=c("white", 1:4), ColSideColors=RowSC)
# check if any of these are hotspot mutations
Hotspots=MeltCosmic[which(!is.na(MeltCosmic$HumSequence)==T), ]
head(Hotspots)

hotspotLocExtract=function(amat){
HList=sapply(1:nrow(Hotspots), function(i) ifelse(amat[match(Hotspots$L1[i], rownames(amat)),match(Hotspots$Gene_Symbol[i], colnames(amat))]>0, 
                                                 paste(match(Hotspots$L1[i], rownames(amat)),match(Hotspots$Gene_Symbol[i], colnames(amat))), "0 0"))
List2=strsplit(as.character(HList), " ")
Xcord=na.omit(as.numeric(sapply(List2, function(x) x[1])))
Ycord=na.omit(as.numeric(sapply(List2, function(x) x[2])))
return(list(X=Xcord, Y=Ycord))
}

## top 90 mutations
a2=heatmap.2(sign(tempx), trace="none", col=c("white", "grey"))
tempxb=tempx[a2$rowInd, a2$colInd]
hotspot1b=hotspotLocExtract(tempxb)
rownames(tempxb)=Cdata$NewID[sapply(rownames(tempxb), function(x) grep(x, Cdata$WGS))]

GeneList=unique(Hotspots$Gene_Symbol)
Hotspots$Gene_Symbol

tempy=rGeneOut2[ ,match(GeneList, colnames(rGeneOut2))]
#a2=heatmap.2(sign(tempy), trace="none", col=c("white", "grey"))
#tempyb=tempy[a2$rowInd, a2$colInd]
#hotspot2=hotspotLocExtract(tempyb)
#rownames(tempyb)=Cdata$NewID[sapply(rownames(tempyb), function(x) grep(x, Cdata$WGS))]

##cosmic genes
x1=which(colnames(rGeneOut2)%in%RatCosmic)
tempz=rGeneOut2[ ,x1]
a2=heatmap.2(sign(tempz), trace="none", col=c("white", 1:4))
tempzb=tempz[a2$rowInd, a2$colInd]
hotspotzb=hotspotLocExtract(tempzb)


x2=which(colSums(sign(tempzb))==1)
tempz2=tempzb[ , -x2]

hotspotzb2=hotspotLocExtract(tempz2)

rownames(tempzb)=Cdata$NewID[sapply(rownames(tempzb), function(x) grep(x, Cdata$WGS))]
rownames(tempz2)=Cdata$NewID[sapply(rownames(tempz2), function(x) grep(x, Cdata$WGS))]


topCOSMIC=colnames(tempz2)

save(topN, topCOSMIC, file="outputs/genes-selected-common-WGX-mutations.RData")

#x3=table(colSums(rGeneOut2))
write.csv(rGeneOut[ , x1], file="nature-tables/1k-mutations.csv")
```

Note that in this table, the distribution of samples with mutations is as follows:

`r table(colSums(rGeneOut2))`

The number of genes which have shared mutations in 10 or more samples is:

`r sum(x3[10:length(x3)])`, which is why we have use these values here.

The number of genes which are cosmic associated are:

`r length(x1)` and the number which appear in more than 1 sample is `r length(x1)-length(x2)`.

These genes are tabulated below: (nice figures generated here). 


```{r 1k, fig.cap="summary of mutations acccording to frequency cosmic"}
### keep these values
top90genes=colnames(rGeneOut2)

#pdf(sprintf("~/Desktop/summary_mutations_top90_human_homology_%s.pdf", Sys.Date()), width=14, height=7)

hotspot1b

 par(mar = c(4, 8, 4, 2),  xpd = TRUE)
 image(t(tempxb), col=c("white", 1:3), xaxt='n', yaxt='n')
 axis(1, at=seq(0, 1, length=ncol(tempxb)), colnames(tempxb), las=2, cex.axis=0.7)
 axis(2, at=seq(0, 1, length=nrow(tempxb)), rownames(tempxb), las=2, cex.axis=0.7)
# text(na.omit(hotspot1b$Y-1)/(ncol(tempxb)-1), na.omit(hotspot1b$X-1)/(nrow(tempxb)-1) , "*")
# legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
# mtext("top 90 mutations", side=3, line=-1, outer=T)
```

Below is the above list refined according to cosmic specifc genes, and listing 

```{r}
# par(mar = c(4, 8, 4, 2),  xpd = TRUE)
# image(t(tempyb), col=c("white", 1:4), xaxt='n', yaxt='n')
# axis(1, at=seq(0, 1, length=ncol(tempyb)), colnames(tempyb), las=2, cex.axis=0.5)
# axis(2, at=seq(0, 1, length=nrow(tempyb)), rownames(tempyb), las=2, cex.axis=0.5)
# text(na.omit(hotspot2$Y-1)/(ncol(tempyb)-1), na.omit(hotspot2$X-1)/(nrow(tempyb)-1) , "*")
# legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
# mtext(" 'Hotspot' mutations only", side=3, line=-1, outer=T)

## Plot by picking out cancer related genes
#pdf("figure-outputs/1k_redo.pdf", height=7.5, width=17.3)
palette(brewer.pal(8, "Set1"))
par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempzb), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempzb)), colnames(tempzb), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tempzb)), rownames(tempzb), las=2,  cex.axis=0.7)
#text(na.omit(hotspotzb$Y-1)/(ncol(tempzb)-1), na.omit(hotspotzb$X-1)/(nrow(tempzb)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("Cancer related genes", side=3, line=-1, outer=T)
#dev.off()

par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempz2), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempz2)), colnames(tempz2), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tempz2)), rownames(tempz2), las=2, cex.axis=0.7)
#text(na.omit(hotspotzb2$Y-1)/(ncol(tempz2)-1), na.omit(hotspotzb2$X-1)/(nrow(tempz2)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)

#dev.off()
```

## Metacore analysis of commonly mutated pathways

Save these lists for metacore

```{r, eval=F}
allMut=unique(MeltWGSCodingB$Gene_Symbol)
write.csv(allMut, file=sprintf("outputs/all_mut_rat_WGS_coding_metacore_%s.csv", Sys.Date()), row.names = F, quote=F)

allMut=unique(MeltCosmic$Gene_Symbol)
write.csv(allMut, file=sprintf("outputs/all_mut_rat_WES_cosmic_metacore_%s.csv", Sys.Date()), row.names = F, quote=F)

```

Load the metacore results:

```{r 1l, fig.cap="summary of metacore common mutated pathways"}
Process_Networks=readxl::read_excel("../data/wholegenome_mutations/all rat WES coding process networks-jan2021.xls", 1, skip=2)
#Pathway_Maps=readxl::read_excel("../data/wholegenome_mutations/all rat WES pathway maps coding-cosmic.xls", 1, skip = 2)

Terms_PN=strsplit(Process_Networks$Networks, "_")
TermsPN1=sapply(Terms_PN, function(x) x[1])
TermsPN2=sapply(Terms_PN, function(x) x[2])


load("../anntotations/Metacore_extracted_Process_networks_nov2020.RData")
n2=which(Process_Networks$FDR<0.05)
m1=match(Process_Networks$Networks[n2], names(PathwayMapSet))
#figure out which is significant


N2=lapply(m1, function(x) which(MeltWGSCodingB$Hum_Gene %in% PathwayMapSet[[x]]))
GList2=lapply(N2, function(x) MeltWGSCodingB[x, c("Hum_Gene", "L1")])
SumTable2=sapply(GList2, function(x) summary(factor(x[ ,"L1"], levels=unique(MeltWGSCodingB$L1))))
colnames(SumTable2)=Process_Networks$Networks[n2]
#listGenes=strsplit(Process_Networks$Network.Objects.from.Active.Data[1:15], ",")

## do this for ERS1 networks
er1=GList2[[8]] #6,8, 35
axtemp=table(er1[ ,1], er1[,2])
colnames(axtemp)=Cdata$NewID[sapply(colnames(axtemp), function(x) grep(x, Cdata$WGS) ) ]
a2=heatmap.2(sign(axtemp), col=brewer.pal(3, "Blues"), trace="none")

image(t(a2$carpet), xaxt="n", yaxt="n", col=c("white", "skyblue"))
axis(1, at=seq(0, 1, length=nrow(axtemp)), colnames(a2$carpet), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=ncol(axtemp)), rownames(a2$carpet), las=2, cex.axis=0.7)

# load("../anntotations/Metacore_extracted_pathway_maps_nov2020.RData")
# n2=which(Pathway_Maps$FDR...7<0.001)
# m1=match(Pathway_Maps$Maps[n2], names(PathwayMapSet))


# N2=lapply(m1, function(x) which(MeltWGSCodingB$Hum_Gene %in% PathwayMapSet[[x]]))
# GList2=lapply(N2, function(x) MeltWGSCodingB[x, c("Hum_Gene", "L1")])
# SumTable3=sapply(GList2, function(x) summary(factor(x[ ,"L1"], levels=unique(MeltWGSCodingB$L1))))
# colnames(SumTable3)=Pathway_Maps$Maps[n2]
# #listGenes=strsplit(Process_Networks$Network.Objects.from.Active.Data[1:15], ",")
# head(SumTable3)

#pdf("rslt/WGS/Metacore_analysis_coding_mutations.pdf", height=13, width=13)

par(mfrow=c(1,2), mar=c(2,2, 2,2))
n2=order(Process_Networks$FDR)
barplot(-log10(as.numeric(Process_Networks$FDR[n2[1:15]])), names.arg = Process_Networks$Networks[n2[1:15]], las=2, main="Process networks all coding", horiz = T, cex.names = 0.5)
n2=order(Process_Networks$FDR)
# barplot(-log10(as.numeric(Process_Networks$FDR...11[n2[1:15]])), names.arg = Process_Networks$Networks[n2[1:15]], las=2, main="Process networks cosmic only", horiz = T, cex.names = 0.5)
# barplot(-log10(as.numeric(Pathway_Maps$FDR[1:15])), names.arg = Pathway_Maps$Maps[1:15], las=2, main="Pathway Maps", horiz = T, cex.names = 0.5)
```

```{r 1lb, fig.cap="summary of metacore common mutated pathways"}
par(oma=c(2, 0,0,3))
rNames=strsplit(colnames(SumTable2), "_")
rNames2=sapply(rNames, function(x) x[1])
cCols=brewer.pal(12,"Set3")[factor(rNames2)]
lx=order(cCols)
colnames(SumTable2)=sapply(rNames, function(x) x[2])
rownames(SumTable2)=Cdata$NewID[sapply(rownames(SumTable2), function(x) grep(x, Cdata$WGS))]
heatmap.2(sign(SumTable2[, lx]), scale="none", trace="none", col=c("white", "skyblue"), main="Process Networks: scaled No mutations affecting each pathway",
          ColSideColors = cCols[lx], Colv = NA)


write.csv(cbind(SumTable2[, lx],rNames2[lx]), file="nature-tables/1l_samples_with_muttions.csv")
#rNames2[lx]
# par(oma=c(2, 0,0,3))
# # rNames=strsplit(colnames(SumTable3), "_")
# # rNames2=sapply(rNames, function(x) x[1])
# # cCols=brewer.pal(12,"Set3")[factor(rNames2)]
# # lx=order(cCols)r
# heatmap.2(SumTable3, scale="col", trace="none", col=brewer.pal(9, "Blues"), main="Pathway Maps")
# write.csv(SumTable3, file="outputs/no mutations pathway maps all coding.csv")
# write.csv(SumTable2, file="outputs/no mutations process networks all coding.csv")
#dev.off()
```


<!--chapter:end:14-mutations.Rmd-->

# Mutations in RNA

In this section, we will check RNA data for the common mutations identified in the previous section. Some of these mutations could be uncharacterised polymoprphisms, and if this is the case, we will see in both CD45 and Epithelial fractions

## Haplotype caller

Mutational calling from RNA data was performed using haplotype caller. The key steps are:

1. run haplotype caller
2. run snpeff to annotate
3. from snpsift to convert to a text file that can be read

Note that a dbSNP file is needed to filter for polymorphisms. We have used the [harlan variants](https://www.biorxiv.org/content/10.1101/412924v1.full) to perform filtering due to similarity in population frequencies in the previous section

An example of the code is shown here:

```{r, eval=F}
 # pipeline

# 1. run haplotyper
# A. Assemble BAM files
Inputs: 
  $1 fastq file (if paired end, $2 will be the other)
  $2 aligned bam
# fastq to unaligned BAM
java -jar $PICARD/picard-2.8.0.jar FastqToSam F1=$1 O=$uBAM\
## for paired end:
# java -jar $PICARD/picard-2.8.0.jar FastqToSam F1=$1 F2=$2 O=$uBAM \

# change read groups in aligned BAM file to ensure uniqueness
java -jar $PICARD/picard-2.8.0.jar AddOrReplaceReadGroups \
     I= $2 \
     O= "${2/.bam/ARG.bam}" \
     ID=$baseName2 \
     LB=library \
     PL=illumina \
     PU=hiseq2000 \
     SM=$baseName2 \
     CN=MFBC \
     DT=2018-08-20T00:00:00-0400
# merge files
gatk MergeBamAlignment \
--REFERENCE_SEQUENCE ../Alignment/rn6.fa \
--UNMAPPED_BAM $uBAM \
--ALIGNED_BAM "${2/.bam/ARG.bam}" \
--OUTPUT $mBAM \
--INCLUDE_SECONDARY_ALIGNMENTS false \
--PAIRED_RUN true \
--VALIDATION_STRINGENCY SILENT

#B. Mark duplicates
gatk MarkDuplicates \
        --INPUT $mBAM \
        --OUTPUT $dBAM \
        --CREATE_INDEX true \
        --VALIDATION_STRINGENCY SILENT \
        --METRICS_FILE ${outName}.metrics
#C. Split sigar reads
gatk SplitNCigarReads \
     -R ../Alignment/rn6.fa \
     -I $dBAM \
     -O $cBAM \

#D. Base recalibration
gatk BaseRecalibrator \
             -R ../Alignment/rn6.fa \
             -I $cBAM \
             -O ${outName}_recalibration \
             -known-sites harlan_snps_mod_1-5-2020.SDsort.vcf.gz 

gatk ApplyBQSR \
             --add-output-sam-program-record \
             -R ../Alignment/rn6.fa \
             -I $cBAM \
             --use-original-qualities \
             -O $bBAM \
             --bqsr-recal-file ${outName}_recalibration

#E. Haplotype calling
gatk HaplotypeCaller \
 -R ../Alignment/rn6.fa \
 -I $bBAM \
 -L ../Alignment/rn6_refGene_intervals.bed \
 -O ${outName}HCR.vcf.gz  \
 --dont-use-soft-clipped-bases true \
 --standard-min-confidence-threshold-for-calling 20 \
 --dbsnp all_rat_snps_0504.SD.vcf.gz

# F. Filtering
gatk VariantFiltration \
 --R ../Alignment/rn6.fa \
 --V ${outName}HCR.vcf.gz \
 --window 35 \
 --cluster 3 \
 --filter-name "FS" \
 --filter "FS > 30.0" \
 --filter-name "QD" \
 --filter "QD < 2.0" \
 -O ${outName}_filt_HCR

# 2. run SnpEff to annotate
java -jar $SNPEFF/snpEff.jar -v Rnor_6.0.86 /n/scratch2/at268/carlos_data/20191030_Ep_NMU1_CGDA7428_S1_R1_001_filt > /n/scratch2/at268/carlos_data/20191030_Ep_NMU1_CGDA7428_S1_R1_001_filt_ann

# 3. run SnpSift to save as a .txt file that can be easily read
cat $f | $SNPEFF/scripts/vcfEffOnePerLine.pl | java -jar $SNPEFF/SnpSift.jar extractFields -e "" - CHROM POS ID REF ALT QUAL FILTER AF AC DP MQ  "ANN[*].ANNOTATION" "ANN[*].GENE" "ANN[*].GENEID" "ANN[*].BIOTYPE" "ANN[*].HGVS_C" "ANN[*].HGVS_P" "ANN[*].CDNA_POS" "ANN[*].CDNA_LEN" "ANN[*].CDS_POS" "ANN[*].CDS_LEN" "ANN[*].AA_POS" "ANN[*].AA_LEN" "NMD[*].NUMTR" "NMD[*].PERC" "GEN[*]" > $ofile
```


From processing the mutational information:

Header information - Genotypes:
GT: genotype
AD: Allelic depths for the ref and alt alleles in the order listed
DP: Approximate read depth (reads with MQ=255 or with bad mates are filtered)
GQ: Genotype Quality
PL: Normalized, Phred-scaled likelihoods for genotypes

Header info: Info
AC: Allele count in genotypes, for each ALT allele, in the same order as listed
AF: Allele Frequency, for each ALT allele, in the same order as listed
AN: Total number of alleles in called genotypes
DB: dbSNP Membership
DP: Approximate read depth; some reads may have been filtered
ExcessHet: Phred-scaled p-value for exact test of excess heterozygosity
FS: Phred-scaled p-value using Fisher's exact test to detect strand bias
MLEAC: Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC)
MLEAF: Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF)
MQ: RMS Mapping Quality
QD:Variant Confidence/Quality by Depth
SOR: Symmetric Odds Ratio of 2x2 contingency table to detect strand bias

SnpEff Annotations:
Allele : C
Annotation: missense_variant
Annotation_Impact MODERATE
Gene_Name Raet1l
Gene_ID ENSRNOG00000040300 
Feature_Type transcript 
Feature_ID ENSRNOT00000062027.4
Transcript_BioType protein_coding 
HGVS.c c.1017C>G 
HGVS.p p.Cys339Trp 
cDNA.pos / cDNA.length 1017/1185 
CDS.pos / CDS.length 1017/1185 
AA.pos / AA.length 339/394 

missense_variant|MODERATE|Raet1l|ENSRNOG00000040300|transcript|ENSRNOT00000062027.4|protein_coding|6/7|c.1017C>G|p.Cys339Trp|1017/1185|1017/1185|339/394||

AC=2;AF=1.00;AN=2;DP=49;ExcessHet=3.0103;FS=0.000;MLEAC=2;MLEAF=1.00;MQ=60.00;QD=34.99;SOR=0.874;ANN=GC|frameshift_variant&splice_region_variant|HIGH|Reps1|ENSRNOG00000059224|transcript|ENSRNOT00000089607.1|protein_coding|8/29|c.119dupC|p.Gln41fs|142/2608|120/1842|40/613||INFO_REALIGN_3_PRIME;LOF=(Reps1|ENSRNOG00000059224|2|0.50)

AC=2;AF=1.00;AN=2;BaseQRankSum=1.593;ClippingRankSum=0.000;DP=9;ExcessHet=3.0103;FS=0.000;MLEAC=2;MLEAF=1.00;MQ=60.00;MQRankSum=0.000;QD=33.20;ReadPosRankSum=0.765;SOR=1.609;ANN=AT|frameshift_variant&stop_gained|HIGH|Pacs1|ENSRNOG00000020350|transcript|ENSRNOT00000027632.5|protein_coding|3/24|c.464dupA|p.Tyr155fs|464/2886|464/2886|155/961||;LOF=(Pacs1|ENSRNOG00000020350|1|1.00);NMD=(Pacs1|ENSRNOG00000020350|1|1.00)

## Load files

```{r, cache=T}
hfiles=dir("../data/haplotypeCaller/output_HaplotypeCaller_May/characterisation/",
           pattern=".txt", full.names = T)

allHfiles=list()
allCodingHaplo=list()
allCosmicHaplo=list()

for (i in 1:length(hfiles)){
A1=read.delim(hfiles[i], sep="\t", stringsAsFactors = F)
A1[which(A1==(-1), arr.ind=T)]=""

cNames=sapply(strsplit(colnames(A1)[12:27], "\\.\\.\\.\\."), function(x) x[2])
cNames[13:16]=paste(c("LOF", "LOF", "NMD", "NMD"), cNames[13:16], sep=".")
colnames(A1)[12:28]=c(cNames, "GEN")

GEN2=sapply(strsplit(A1$GEN, ":"), function(x) x[2])
gRef=sapply(strsplit(GEN2, ","), function(x) x[1])
gAlt=sapply(strsplit(GEN2, ","), function(x) x[length(x)])

A1$n_ref=as.numeric(gRef)
A1$n_alt=as.numeric(gAlt)
A1$VAF=A1$n_alt/(A1$n_alt+A1$n_ref)

allHfiles[[i]]=A1[which(A1$n_ref+A1$n_alt>10), ]
allCodingHaplo[[i]]=A1[which(A1$HGVS_P!="" & A1$n_ref+A1$n_alt>10), ]
allCosmicHaplo[[i]]=A1[which(A1$GENE%in%RatCosmic & A1$n_ref+A1$n_alt>10), ]
}

## names of the files

fNam=unlist(strsplit(hfiles, "_filt_HCR_ann_siftB.txt")) #remove HCR where not needed
fNam=unlist(strsplit(fNam, ".vcf.g"))
fNam2=paste(fNam, ".fastq.gz", sep="")
fNam2=sapply(strsplit(fNam2, "/"), function(x) x[length(x)])
idx1=infoTableFinal$SampleID[match(fNam2, infoTableFinal$FqFile)]
idx1[which(is.na(idx1))]=fNam2[which(is.na(idx1))]
idx1[grep("CD45plus", idx1)]=substr(idx1[grep("CD45plus", idx1)],10, 21) 
# sNames=paste(tempAnnot$Rat_ID[idx1],tempAnnot$Location[idx1],  tempAnnot$Fraction[idx1], sep="_")

names(allHfiles)=idx1
names(allCodingHaplo)=idx1
names(allCosmicHaplo)=idx1
# remove the samples which do not pass QC
idx2rm=setdiff(grep("fastq.gz", idx1), grep("CD45plus", idx1))

## write all these lists to file
allHfiles=allHfiles[-idx2rm]
allCodingHaplo=allCodingHaplo[-idx2rm]
allCosmicHaplo=allCosmicHaplo[-idx2rm]

save(allHfiles,allCodingHaplo, allCodingHaplo,  file=sprintf("outputs/HaplotypeVariants_characterisation_all_%s.Rdata", Sys.Date()))
```

## Identifying polymorphisms: compare frequencies in CD45 and Ep data

Search for whether mutations in the cosmic set is present in the RNA data. We will firstly look at the 90 most common genes, and then repeat the same for the top cosmic genes.

```{r}
# replace topN with topCOSMIC
# templace tempxb with tempz2

MeltWGSCoding$mutPos=paste(MeltWGSCoding$Gene_Symbol, MeltWGSCoding$Start_Position)
MeltWGSCodingB$mutPos=paste(MeltWGSCodingB$Gene_Symbol, MeltWGSCodingB$Start_Position)
MallCodingHaplo=melt(allCodingHaplo,  measure.var="POS")
MallCodingHaplo$mutPos=paste(MallCodingHaplo$GENE, MallCodingHaplo$value)
```


```{r}
xb=sort(table(MeltWGSCodingB$mutPos[MeltWGSCodingB$Gene_Symbol%in%topCOSMIC]), decreasing = T)

allCoding_top90=lapply(allCodingHaplo, function(x) x[which(paste(x$GENE, x$POS)%in%names(xb)), ])

mallCoding90=melt(allCoding_top90, measure.var="POS")
mallCoding90$mutUnique=paste(mallCoding90$GENE, mallCoding90$value)

x1=table(mallCoding90$mutUnique)

tabN=acast(mallCoding90[ , c("L1", "GENE")],L1~GENE)
#heatmap.2(tabN, Colv = NA, trace="none", scale="none", col=c("white", brewer.pal(5, "Blues")))
cNamesMatch=match(colnames(tabN), colnames(tempz2))

tabN2=matrix(0, nrow=nrow(tabN), ncol=ncol(tempz2))
tabN2[ ,cNamesMatch]=tabN
colnames(tabN2)=colnames(tempz2)
rownames(tabN2)=rownames(tabN)
id2=grep("Ep", rownames(tabN))
id3=grep("CD45$", rownames(tabN))
id4=grep("CD45plus", rownames(tabN))
tabN2[id2, ]=sign(tabN2[id2, ])
tabN2[id3, ]=sign(tabN2[id3, ])*2
tabN2[id4, ]=sign(tabN2[id4, ])*3
tabN2=tabN2[c(id2, id3, id4), ]


#heatmap.2(tabN2, Colv = NA, Rowv = NA, trace="none", scale="none", col=c("white", brewer.pal(5, "Blues")))

image(t((tabN2)), col=c("white", 1:3), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempz2)), colnames(tempz2), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tabN2)), rownames(tabN2), las=2, cex.axis=0.7)

lx2=sapply(allCoding_top90, nrow)

barplot(lx2, ylab="no# mutations in top 90 genes", las=2)

```

## Find coding mutations which are specific to ep cells

Here, look for mutations from RNA which are present in the epithelial cells specific

```{r}
VarTypes=c("frameshift", "missense", "start_lost", "stop_gained", "nonsense", "stop_retained")
n2=unique(unlist(sapply(VarTypes, function(x) grep(x, MallCodingHaplo$ANNOTATION))))
MallCodingHaploFunc=MallCodingHaplo[ n2, ]
## Look at epithealial samples

xa=grep("Ep", MallCodingHaploFunc$L1)
MallEpi=MallCodingHaploFunc[xa, ]
EpVarList=table(MallCodingHaploFunc$GENE[xa])
EpVarNames=names(EpVarList)
EpVarN2=names(EpVarList[which(EpVarList>1)])
EpVarListB=table(MallCodingHaploFunc$mutPos[xa])
EpLoc=names(EpVarListB)[which(EpVarListB>1)]

## Look at CD45 samples
xa=grep("CD45$", MallCodingHaploFunc$L1)
CDVarList=table(MallCodingHaploFunc$GENE[xa])
CDVarNames=names(CDVarList)
CDVarN2=names(CDVarList[which(CDVarList>=1)])
CDVarListB=table(MallCodingHaploFunc$mutPos[xa])
CDLoc=names(CDVarListB)[which(CDVarListB>=1)]


## Look at CD45 normal
xa=grep("CD45plus", MallCodingHaploFunc$L1)
nCD45VarList=table(MallCodingHaploFunc$GENE[xa])
nCD45VarNames=names(nCD45VarList)
nCD45VarN2=names(nCD45VarList[which(nCD45VarList>=1)])
nCD45VarListB=table(MallCodingHaploFunc$mutPos[xa])
nCDLoc=names(nCD45VarListB)[which(nCD45VarListB>=1)]

## List of ep-spec variants
eplist1=setdiff(setdiff(EpVarN2, CDVarN2), nCD45VarN2)
## Obtain the list of Ep-specific variants and cross-reference with genomic data
WGSListgenes=table(MeltWGSCodingB$Gene_Symbol)
WGSListgenes=names(WGSListgenes)[which(WGSListgenes>1)]

RList=MallEpi[which(MallEpi$GENE%in%eplist1), ]
Rlist2=table(RList$mutPos)
Rlist2=names(Rlist2)[which(Rlist2>1)]

WGSList=paste(MeltWGSCodingB$Gene_Symbol, MeltWGSCodingB$Start_Position)
t2=table(WGSList)
WGSList=names(t2)[which(t2>1)]
mutlist=intersect(Rlist2, WGSList)

#pdf("~/Desktop/RNA-specific-mutations-gene-level.pdf", height=6, width=6)

venn(list(Ep=EpVarNames, CD45=CDVarNames, nCD45=nCD45VarNames))
mtext("no genes w mutations overlapping in different fractions")

venn(list(Ep=EpVarN2, CD45=CDVarN2, nCD45=nCD45VarN2))
mtext("no genes with overlapping variants in 2+ samples")

venn(list(Ep_RNA=eplist1, Ep_WGS=WGSListgenes))
mtext("No genes with overlaps in 2+ samples")
#dev.off()
```

Location specific mutations:

```{r}
#pdf("~/Desktop/RNA-specific-mutations-location-level.pdf", height=7, width=10)

venn(list(Ep=EpLoc, CD45=CDLoc, nCD45=nCDLoc))
mtext("no locations with overlapping variants in 2+ samples")

venn(list(Ep_RNA=Rlist2, Ep_WGS=WGSList))
mtext("No ep. specifc locations with overlaps in 2+ samples")

# plots of mutational frequencies of the locations in A1
Ttemp=acast(MallCodingHaploFunc[which(MallCodingHaploFunc$mutPos%in%mutlist), c("L1", "mutPos")], mutPos~L1)
Ttemp=cbind(Ttemp, 0)
colnames(Ttemp)[ncol(Ttemp)]="NMU13_LAU_Ep"

ax2=setdiff(unique(MallEpi$L1), colnames(Ttemp))

Wtemp=acast(MeltWGSCoding[which(MeltWGSCodingB$mutPos%in%mutlist), c("L1", "mutPos", "Start_Position")],mutPos~L1)
Wtemp[which(is.na(Wtemp), arr.ind = T)]=0

par(oma=c(5, 5, 1, 1))
image(sign((Ttemp)), col=c("white","darkblue"), xaxt="none", yaxt="none")
axis(1, at=seq(0, 1, length=nrow(Ttemp)),rownames(Ttemp), las=2)
axis(2, at=seq(0, 1, length=ncol(Ttemp)),colnames(Ttemp), las=2)
mtext("Mutations in RNA & in WGS data")

par(oma=c(5, 5, 1, 1))
image(sign(Wtemp), col=c("white","darkblue"), xaxt="none", yaxt="none")
axis(1, at=seq(0, 1, length=nrow(Wtemp)),rownames(Wtemp), las=2)
axis(2, at=seq(0, 1, length=ncol(Wtemp)),colnames(Wtemp), las=2)

# mtext("Mutations in WGS data")
# par(oma=c(2,2,2,5))
# heatmap.2(t(ExprVSD), trace="none", scale="none", Rowv = NA, Colv = NA, col=RdBu[11:1],
#           main="gene expression, vst transformed")
# heatmap.2(t(ExprVSD), trace="none", scale="col", Rowv = NA, Colv = NA, col=RdBu[11:1],
#           main="gene expression, col scaled")
# 
# # calculate the correlation between mutation and expression
# 
# mvals=rep(NA, nrow(ExprVSD))
# names(mvals)=rownames(ExprVSD)
# mvalsP=mvals
# 
# x1=match(colnames(ExprVSD), colnames(Ttemp))
# for (i in 1:length(mvals)){
#   ax1=glm(sign(Ttemp[i, x1])~ExprVSD[i, ], family =binomial(link="logit"))
#   mvals[i]=coefficients(ax1)[2]
#   mvalsP[i]=summary(ax1)$coefficients[2,4]
# }
# 
# barplot(mvalsP,las=2, ylab = "P value of association bw mutation and expression")

#dev.off()
```

There are `r length(ax1)` mutations which are found in both the RNA and WGS data (2+ samples, not found in RNAseq)

## Filtering WGS data based on CD45 data

* Use the entire list for WGS
* Find mutations in CD45 (either) and remove

```{r}
#head(MeltWGSCoding)
#head(MallCodingHaploFunc)

lx1=grep("CD45", MallCodingHaploFunc$L1)

mutDiff=setdiff(MeltWGSCodingB$mutPos, MallCodingHaploFunc$mutPos[lx1])

NUnique=table(MeltWGSCodingB$mutPos[MeltWGSCodingB$mutPos%in%mutDiff])
NUniqueB=table(MeltWGSCodingB$Gene_Symbol[MeltWGSCodingB$mutPos%in%mutDiff])


rGeneOut=acast(MeltWGSCodingB[ MeltWGSCodingB$mutPos%in%names(NUnique),c("Gene_Symbol", "L1", "Variant_Classification")], L1~Gene_Symbol, 
               value.var="Variant_Classification", fun.aggregate=function(x) paste(x, collapse = ", "))

mxl=unique(as.vector(rGeneOut))
rGeneOut2b=rGeneOut
rGeneOut2b[grep("Nonsense",rGeneOut2b)]=3
rGeneOut2b[grep("Frame_Shift",rGeneOut2b)]=2
rGeneOut2b[grep("Missense_", rGeneOut2b)]=1
rGeneOut2b[grep("Splice_", rGeneOut2b)]=4
rGeneOut2b[which(rGeneOut2b=="")]=0

rGeneOut2b=apply(rGeneOut2b, 2, as.numeric)
rownames(rGeneOut2b)=rownames(rGeneOut)

rmThese=c("^AABR", "^Olr", "^LOC", "^AC[0-9]+", "^RGD", "^Rpl", "^1700", "^RT1", "^ENSRNOG", "^Vom2")
rmList=unlist(sapply(rmThese, function(x) grep(x, colnames(rGeneOut2b))))
rGeneOut2b=rGeneOut2b[ ,-rmList]


NtopA=names(NUnique)[which(NUnique>6)]
NtopAb=unique(sapply(strsplit(NtopA, " "), function(x) x[1]))
tempAnew=rGeneOut2b[, na.omit(match(NtopAb, colnames(rGeneOut2b)))]

tempA=heatmap.2(sign(tempAnew))
tempA=tempAnew[tempA$rowInd, tempA$colInd]

#HSAnew=hotspotLocExtract(tempA)


## NtopB=which(NUnique>10)
NtopB=names(NUniqueB)[which(NUniqueB>1)]
NtopB2=NtopB[NtopB%in%RatCosmic]

tempBnew=rGeneOut2b[, na.omit(match(NtopB2, colnames(rGeneOut2b)))]

tempB=heatmap.2(sign(tempBnew))
tempB=tempBnew[tempB$rowInd, tempB$colInd]

#HSBnew=hotspotLocExtract(tempB)

#pdf("~/Desktop/WGS-coding-mutations-not-in-CD45-RNA.pdf", height=7, width=13)
## Commonly mutated Genes:
par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempA), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempA)), colnames(tempA), las=2, cex.axis=0.5)
axis(2, at=seq(0, 1, length=nrow(tempA)), rownames(tempA), las=2, cex.axis=0.5)
#text(na.omit(HSAnew$Y-1)/(ncol(tempA)-1), na.omit(HSAnew$X-1)/(nrow(tempA)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("top 118 mutations", side=3, line=-1, outer=T)
#dev.off()

#pdf("~/Desktop/WGS-COSMIC-mutations-not-in-CD45-RNA.pdf", height=7, width=13)
## Commonly mutated Genes:
par(mar = c(4, 8, 4, 2),  xpd = TRUE)
image(t(tempB), col=c("white", 1:4), xaxt='n', yaxt='n')
axis(1, at=seq(0, 1, length=ncol(tempB)), colnames(tempB), las=2, cex.axis=0.7)
axis(2, at=seq(0, 1, length=nrow(tempB)), rownames(tempB), las=2, cex.axis=0.7)
#text(na.omit(HSBnew$Y-1)/(ncol(tempB)-1), na.omit(HSBnew$X-1)/(nrow(tempB)-1) , "*")
legend("top", inset = c(-0.5, -0.15),    legend = c("missense","frameshift", "Nonsense", "splice", "hotspot human"),  pch = c(19, 19, 19,19, 8),  col = c(1:4, "black"), horiz = T)
mtext("Common COSMIC mutations", side=3, line=-1, outer=T)
#dev.off()
```

<!--chapter:end:14b-mutations-RNA.Rmd-->

# Mutations in progression cohort

```{r, cache=T}
hfiles=dir("../data/haplotypeCaller/output_HaplotypeCaller_May/progression/",
           pattern=".txt", full.names = T)

allHfilesP=list()
allCodingHaploP=list()
allCosmicHaploP=list()

for (i in 1:length(hfiles)){
A1=read.delim(hfiles[i], sep="\t", stringsAsFactors = F)
A1[which(A1==(-1), arr.ind=T)]=""

cNames=sapply(strsplit(colnames(A1)[12:27], "\\.\\.\\.\\."), function(x) x[2])
cNames[13:16]=paste(c("LOF", "LOF", "NMD", "NMD"), cNames[13:16], sep=".")
colnames(A1)[12:28]=c(cNames, "GEN")

GEN2=sapply(strsplit(A1$GEN, ":"), function(x) x[2])
gRef=sapply(strsplit(GEN2, ","), function(x) x[1])
gAlt=sapply(strsplit(GEN2, ","), function(x) x[length(x)])

A1$n_ref=as.numeric(gRef)
A1$n_alt=as.numeric(gAlt)
A1$VAF=A1$n_alt/(A1$n_alt+A1$n_ref)

allHfilesP[[i]]=A1[which(A1$n_ref+A1$n_alt>10), ]
allCodingHaploP[[i]]=A1[which(A1$HGVS_P!="" & A1$n_ref+A1$n_alt>10), ]
allCosmicHaploP[[i]]=A1[which(A1$GENE%in%RatCosmic & A1$n_ref+A1$n_alt>10), ]
}

## names of the files

fNam=unlist(strsplit(hfiles, "_filt_HCR_ann_siftB.txt")) #remove HCR where not needed
fNam=unlist(strsplit(fNam, ".vcf.g"))
fNam2=paste(fNam, ".fastq.gz", sep="")
fNam2=sapply(strsplit(fNam2, "/"), function(x) x[length(x)])
idx1=infoTableFinal$SampleID[match(fNam2, infoTableFinal$FqFile)]
idx1[which(is.na(idx1))]=fNam2[which(is.na(idx1))]
idx1[grep("CD45plus", idx1)]=substr(idx1[grep("CD45plus", idx1)],10, 21) 
# sNames=paste(tempAnnot$Rat_ID[idx1],tempAnnot$Location[idx1],  tempAnnot$Fraction[idx1], sep="_")

names(allHfilesP)=idx1
names(allCodingHaploP)=idx1
names(allCosmicHaploP)=idx1
# remove the samples which do not pass QC
idx2rm=setdiff(grep("fastq.gz", idx1), grep("CD45plus", idx1))

## write all these lists to file
allHfilesP=allHfilesP[-idx2rm]
allCodingHaploP=allCodingHaploP[-idx2rm]
allCosmicHaploP=allCosmicHaploP[-idx2rm]

save(allHfilesP,allCodingHaploP, allCodingHaploP,  file=sprintf("outputs/HaplotypeVariants_progression_all_%s.Rdata", Sys.Date()))
```

## Summary of common mutations:

```{r}
MallCodingHaploP=melt(allCodingHaploP,  measure.var="POS")
MallCodingHaploP$mutPos=paste(MallCodingHaploP$GENE, MallCodingHaploP$value)

VarTypes=c("frameshift", "missense", "start_lost", "stop_gained", "nonsense", "stop_retained")
n2=unique(unlist(sapply(VarTypes, function(x) grep(x, MallCodingHaploP$ANNOTATION))))
MallCodingHaploFuncP=MallCodingHaploP[ n2, ]
## Look at epithealial samples

```

look at topCOSMIC:

```{r}

xa=grep("Ep", MallCodingHaploFuncP$L1)
MallEpi=MallCodingHaploFuncP[xa, ]
EpVarList=table(MallCodingHaploFuncP$GENE[xa])
EpVarNames=names(EpVarList)
EpVarN2=names(EpVarList[which(EpVarList>1)])
EpVarListB=table(MallCodingHaploFuncP$mutPos[xa])
EpLoc=names(EpVarListB)[which(EpVarListB>1)]

## Look at CD45 samples
xa=grep("CD45$", MallCodingHaploFuncP$L1)
CDVarList=table(MallCodingHaploFuncP$GENE[xa])
CDVarNames=names(CDVarList)
CDVarN2=names(CDVarList[which(CDVarList>=1)])
CDVarListB=table(MallCodingHaploFuncP$mutPos[xa])
CDLoc=names(CDVarListB)[which(CDVarListB>=1)]

## Look at DN samples
xa=grep("DN", MallCodingHaploFuncP$L1)
DNVarList=table(MallCodingHaploFuncP$GENE[xa])
DNVarNames=names(DNVarList)
DNVarN2=names(DNVarList[which(DNVarList>1)])
DNVarListB=table(MallCodingHaploFuncP$mutPos[xa])
DNLoc=names(DNVarListB)[which(DNVarListB>1)]

#pdf("~/Desktop/Supp5-progression-RNA-specific-mutations-gene-level.pdf", height=6, width=6)

venn(list(Ep=EpVarNames, CD45=CDVarNames, DN=DNVarNames))
mtext("no genes w mutations overlapping in different fractions")

venn(list(Ep=EpVarN2, CD45=CDVarN2, DN=DNVarN2))
mtext("no genes with overlapping variants in 2+ samples")

venn(list(Ep=EpLoc, CD45=CDLoc, DN=DNLoc))
mtext("no locations with overlapping variants in 2+ samples")

#dev.off()
```

## Look at the common mutations (cosmic ones)

```{r}
MallCodingHaploFuncPC=MallCodingHaploFuncP[which(MallCodingHaploFuncP$GENE%in%topCOSMIC), ]

xab=unique(MallCodingHaploFuncPC$ANNOTATION)

MallCodingHaploFuncPC$ANNOTATION[grep("frameshift_variant",MallCodingHaploFuncPC$ANNOTATION )]="frameshift_variant"

MallCodingHaploFuncPC$ANNOTATION[grep("missense_variant",MallCodingHaploFuncPC$ANNOTATION )]="missense_variant"

MallCodingHaploFuncPC$ANNOTATION=as.numeric(factor(MallCodingHaploFuncPC$ANNOTATION))

AcastTab=acast(MallCodingHaploFuncPC[ ,c("L1", "GENE", "ANNOTATION")], 
               L1~GENE, fun.aggregate = max)
AcastTab[which(AcastTab=="-Inf", arr.ind = T)]=0

indx=rownames(AcastTab)[grep("Ep", rownames(AcastTab))]
indx=substr(indx, 1, nchar(indx)-3)

n2=unlist(sapply(indx, function(x) grep(x, rownames(AcastTab))))

AcastTab[grep("CD45", rownames(AcastTab)), ]=sign(AcastTab[grep("CD45", rownames(AcastTab)), ])
AcastTab[grep("DN", rownames(AcastTab)), ]=sign(AcastTab[grep("DN", rownames(AcastTab)), ])*2
AcastTab[grep("Ep", rownames(AcastTab)), ]=sign(AcastTab[grep("Ep", rownames(AcastTab)), ])*3

#pdf("~/Desktop/FigureS3_biphasic_mutations_again.pdf", height=12, width=15)

image(AcastTab[n2, ], xaxt="none", yaxt="none", col=c("white", "red", "blue", "forestgreen"))
axis(1, at=seq(0, 1, length=nrow(AcastTab[n2, ])), rownames(AcastTab[n2, ]), las=2)
axis(2, at=seq(0, 1, length=ncol(AcastTab)), colnames(AcastTab), las=2)

#dev.off()
```

## Also look at the top RNA-mutations with are Ep/DN specific



```{r}
gListN=setdiff(unique(c(EpLoc, DNLoc)), CDLoc)
gListNsplit=sapply(strsplit(gListN," "), function(x) x[1])

# gene list new
gnew=which(gListNsplit%in%RatCosmic)
gListNsub=gListN[gnew]
IndN=MallCodingHaploFuncP[which(MallCodingHaploFuncP$mutPos%in%gListNsub), ]


```

<!--chapter:end:14c-mutations-RNA.Rmd-->

# Trichrome staining

Quantification of trichrome staining was performed in Qupath using the following steps:

* image is loaded as a "DAB" image
* using "gold standard" trichrome-stained images with good stroma and epithelial content, estimate the stain vectors
* Perform color deconvolution
* A pixel classifier was used to estimate trichrome content
* A pixel classifier was used to estimate tumor content

A snippet of the qupath script is shown below:

```{r, eval=F, echo=T}
# insert some text here

setImageType('BRIGHTFIELD_H_DAB');
setColorDeconvolutionStains('{"Name" : "trichrome", "Stain 1" : "Hematoxylin", "Values 1" : "0.71695 0.66336 0.21432 ", "Stain 2" : "DAB", "Values 2" : "0.46299 0.76212 0.45257 ", "Background" : " 255 255 255 "}');
selectAnnotations();
addPixelClassifierMeasurements("stroma_classifier_again", "stroma_classifier_again")
selectAnnotations();
addPixelClassifierMeasurements("test_tumor", "test_tumor")

def entry = getProjectEntry()
def name = entry.getImageName() + '.txt'
def path = buildFilePath(PROJECT_BASE_DIR, 'annotation results')
mkdirs(path)
path = buildFilePath(path, name)
saveAnnotationMeasurements(path)

```

## Associations with cellular fraction (wsi)

```{r, height=6, eval=T}
# load the data
TrichromeData=read.xlsx("../data/trichrome-staining-result.xls", 1)
midx=match(TrichromeData$SampleID, gsub("_", "", Cdata$TumorID))

Cdata$Trichrome=NA
Cdata$Trichrome[na.omit(midx)]=TrichromeData$Percentage.Stroma[which(!is.na(midx))]

t2=WSIvalFracs[, match(rownames(df.Spatial), colnames(WSIvalFracs))]

df.Spatial=cbind(df.Spatial, t(t2))


df.Spatial$Trichrome=NA
midx=match(TrichromeData$SampleID, rownames(df.Spatial))
df.Spatial$Trichrome[na.omit(midx)]=TrichromeData$Percentage.Stroma[-which(is.na(midx))]
# plot associations

n2=c("CD8", "EpCAM", "SMA", "Unclass", "EpCAM: SMA")

#pdf("~/Desktop/richrome-association-WSI-data-Calc2.pdf", width=6, height=5)

par(mfrow=c(2,3))
for (i in n2){
   a1=cor.test(df.Spatial$Trichrome, df.Spatial[ ,match(i, colnames(df.Spatial))], use="complete")
   n1=paste(i, "cor:", round(a1$estimate,1), "p:", round(a1$p.value,2))
   plot(df.Spatial$Trichrome, df.Spatial[ ,match(i, colnames(df.Spatial))], main=n1, xlab="Trichrome", ylab=i)
}

#dev.off()
```

## Associations with CD8 content


```{r 3gpre, fig.height=6, eval=T}

par(mfrow=c(1,2))

a1=wilcox.test(df.Spatial$Trichrome~df.Spatial$IF.EpCAMcut)$p.val
boxplot(df.Spatial$Trichrome~df.Spatial$IF.EpCAMcut, main=sprintf("Ep int. fraction %s", round(a1,2)))
a1=wilcox.test(df.Spatial$Trichrome~df.Spatial$CD8Fraccut)$p.val
boxplot(df.Spatial$Trichrome~df.Spatial$CD8Fraccut, main=sprintf("CD8 fraction vs Trichrome %s", round(a1,2)))
```

## Associations with growth and treatment

```{r 3g, fig.cap="Trichrome staining with treatment"}
df.Spatial$Growth=Cdata$Tumor.Growth[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$Treatment=Cdata$Treatment[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]
df.Spatial$NewID=Cdata$Treatment[match(rownames(df.Spatial), gsub("_", "", Cdata$NewID))]
df.Spatial$trichrome_pc=Cdata$Trichrome_encapsulation.[match(rownames(df.Spatial), gsub("_", "", Cdata$TumorID))]

pv1=sapply(c("PDL1", "LY", "PDL1+LY"), function(x) wilcox.test(df.Spatial$Trichrome[which(df.Spatial$Treatment%in%c("Vehicle", x))]~
           df.Spatial$Treatment[which(df.Spatial$Treatment%in%c("Vehicle", x))])$p.value)
names(pv1)=c("PDL1", "LY", "PDL1+LY")

ggplot(df.Spatial[ ,c("Treatment", "Trichrome")], aes(x=Treatment, y=Trichrome, col=Treatment))+geom_boxplot()+geom_jitter()+
scale_color_manual(values=ColMerge[ ,1])+theme_bw()+ggtitle(paste(paste(names(pv1), round(pv1, 2)), collapse=";"))

ggplot(df.Spatial[ ,c("Treatment", "trichrome_pc")], aes(x=Treatment, y=trichrome_pc, col=Treatment))+geom_boxplot()+geom_jitter()+
scale_color_manual(values=ColMerge[ ,1])+theme_bw()+ggtitle(paste(paste(names(pv1), round(pv1, 2)), collapse=";"))

```

```{r 3gb, fig.cap="Trichrome with growth"}

a1=df.Spatial[ ,match(c("Trichrome", "Growth", "trichrome_pc"), colnames(df.Spatial))]
a1a=wilcox.test(df.Spatial$Trichrome[which(df.Spatial$Growth=="growing")],
           df.Spatial$Trichrome[which(df.Spatial$Growth=="stable")])
a1a

ggplot(a1, aes(x=Growth, y=Trichrome, col=Growth))+geom_boxplot()+geom_jitter()+
scale_color_manual(values=c(ColSize, "black"))+theme_bw()+ggtitle("growth") # round(a1a, 2)))

ggplot(a1, aes(x=Growth, y=trichrome_pc, col=Growth))+geom_boxplot()+geom_jitter()+
scale_color_manual(values=c(ColSize, "black"))+theme_bw()+ggtitle("growth") # round(a1a, 2)))

#print(p)

#write.csv(df.Spatial[ ,c("Trichrome", "Growth", "Treatment")], file="nature-tables/3g_trichrome.csv")
DT::datatable(df.Spatial[ ,c("Trichrome", "Growth", "Treatment", "trichrome_pc")], rownames=F, class='cell-border stripe', extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel'), scrollX=T))

```

## Association with hyperinflammatory status

We can also do a boxplot for trichrome status and whether it associates with hyperinflammation in our rat samples

```{r Ext5i, fig.cap="association with hyperinflammation"}
vstEpInf$Inflammation3
vstEpInf$Inflammation2
vstEpInf$Inflammation
save(vstEpInf, file="figure-outputs/temp_test.RData")

ax1=colnames(vstEpInf)

t2=match(gsub("_", "", substr( ax1, 1, nchar(ax1)-2)), rownames(df.Spatial))

newTab=data.frame(trichrome=df.Spatial[na.omit(t2), "Trichrome"], 
             inf=vstEpInf$Inflammation2[-which(is.na(t2))],
             names=ax1[-which(is.na(t2))],
             names2=rownames(df.Spatial)[na.omit(t2)])
wilcox.test(newTab$trichrome[newTab$inf=="grow"], newTab$trichrome[newTab$inf!="grow"])
#pdf("figure-outputs/EXT5I_trichrome.pdf", height=5, width=4)
ggplot(newTab, aes(y=trichrome,x=inf))+geom_boxplot()+geom_point()+theme_bw()
```

Also check the encapsulated status?

```{r}
newTab$trichrome_pc=Cdata$Trichrome_encapsulation.[match(newTab$names2, gsub("_", "", Cdata$TumorID))]
newTab$trichrome_pc[which(newTab$trichrome_pc=="lots")]=1
newTab$trichrome_pc=as.numeric(newTab$trichrome_pc)
#pdf("figure-outputs/EXT5I_trichrome_pt2.pdf", height=5, width=4)
ggplot(newTab, aes(y=trichrome_pc,x=inf))+geom_boxplot()+geom_jitter(col="grey")+theme_bw()

wilcox.test(newTab$trichrome_pc[newTab$inf=="grow"], newTab$trichrome_pc[newTab$inf!="grow"])
DT::datatable(newTab, rownames=F, class='cell-border stripe',
          extensions="Buttons", options=list(dom="Bfrtip", buttons=c('csv', 'excel')))


```

<!--chapter:end:15-trichrome-staining.Rmd-->

# CNV calling

CNV calling was performed with BICseq



## Sample data

Load BICseq2 data for all tested samples:

```{r}
allfiles=dir("../data/CNV_calls/","2_scale$", full.names = T)

CNVL2=lapply(allfiles, function(x) read.delim(x, stringsAsFactors = F))
meltCN=melt(CNVL2, measure.vars=c("log2.copyRatio"))
AllDCN=data.frame(sampleID=meltCN$L1, chrom=substr(meltCN$chrom, 4, 5), start.pos=meltCN$start,
                  end.pos=meltCN$end, n.probes=meltCN$binNum, mean=meltCN$value, 
                  call=ifelse(meltCN$value>0.3, "+", ifelse(meltCN$value<(-0.3), "-", "0")))

AllDCN2=data.frame(sample=meltCN$L1, chromosome=meltCN$chrom, start=meltCN$start,
                  end=meltCN$end, n.probes=meltCN$binNum, segmean=2*2^(meltCN$value), 
                  call=ifelse(meltCN$value>0.3, "+", ifelse(meltCN$value<(-0.3), "-", "0")))
AllDCN2$chromosome=factor(AllDCN2$chromosome, levels=unique(AllDCN2$chromosome))

CNVGRanges=GRanges(seqnames = AllDCN$chrom, ranges=IRanges(start=AllDCN$start.pos, end=AllDCN$end.pos), copy_ratio=AllDCN$mean, call=AllDCN$call)
```

## Data Summary

### Frequency of gains and losses across the genome

```{r bicseq, fig.cap="summary of regions of frequent gains and losses"}
# plot the frequencies
Samp1=cnFreq_mod(AllDCN2,CN_low_cutoff=1.4, CN_high_cutoff=2.8, genome=cytoInfo)
Samp1$plot

write.csv(Samp1$data, file="nature-tables/Ext1l_CNV_frequencies.csv")
```

### Loci which have a hit in at least 30\% of samples

```{r}
# Filter out gain and loss regions
LocationsA=Samp1$data[which(Samp1$data$gainProportion>0.3), ]
LocationsA=LocationsA[order( LocationsA$chromosome, LocationsA$start),  ]
LocAmerge=Merge_contig(LocationsA)

LocationsB=Samp1$data[which(Samp1$data$lossProportion>0.3), ]
LocationsB=LocationsB[order( LocationsB$chromosome, LocationsB$start),  ]
LocBmerge=Merge_contig(LocationsB)

# turn into a GRanges object

LocAGRanges=GRanges(seqnames = LocAmerge$chromosome, ranges=IRanges(start=LocAmerge$start, end=LocAmerge$end), strand="*",
                    sampleFrequency=LocAmerge$sampleFrequency, gainFrequency=LocAmerge$gainFrequency, lossFrequency=LocAmerge$lossFrequency, gainProportion=LocAmerge$gainProportion, lossProportion=LocAmerge$lossProportion)

LocBGRanges=GRanges(seqnames = LocBmerge$chromosome, ranges=IRanges(start=LocBmerge$start, end=LocBmerge$end), strand="*",
                    sampleFrequency=LocBmerge$sampleFrequency, gainFrequency=LocBmerge$gainFrequency, lossFrequency=LocBmerge$lossFrequency, gainProportion=LocBmerge$gainProportion, lossProportion=LocBmerge$lossProportion)

# find the overlaps
GainOLap=findOverlaps(LocAGRanges, txRn6)
UniqueGainOlapRegions=unique(queryHits(GainOLap))
GainGenes=sapply(unique(queryHits(GainOLap)), function(x) txRn6$gene_id[subjectHits(GainOLap[which(queryHits(GainOLap)==x)])])

LossOLap=findOverlaps(LocBGRanges, txRn6)
UniqueLossOlapRegions=unique(queryHits(LossOLap))
LossGenes=sapply(unique(queryHits(LossOLap)), function(x) txRn6$gene_id[subjectHits(LossOLap[which(queryHits(LossOLap)==x)])])
```

Venn diagrams of the number of genes which intersect with the cosmic dataset

```{r}
OverviewG=unique(unlist(GainGenes))
OverviewL=unique(unlist(LossGenes))

par(mfrow=c(1,2))
venn(list(CNVgains=OverviewG, cosmic=RatCosmic))
venn(list(CNVloss=OverviewL, cosmic=RatCosmic))
```

The intersecting gene is `r intersect(OverviewL, RatCosmic)`

Venn diagram of immune related genes:

```{r}
par(mfrow=c(1,2))
venn(list(CNVgains=OverviewG, Immune=RatAllImm))
venn(list(CNVloss=OverviewL, Immune=RatAllImm))
```

The gained genes are `r intersect(OverviewG, RatAllImm)`
The lost genes are `r intersect(OverviewL, RatAllImm)`

### Annotated plot of genome and locations of genes

```{r}
S2=Samp1$data
S2=S2[order(S2$chromosome, S2$start), ]


GG2=sapply(GainGenes, length)
GG3=unlist(GainGenes)
GG3[which(duplicated(GG3))]=""
GG4=split(GG3, rep(c(1:length(GG2)), times=GG2))
Ggenes=sapply(GG4, function(x) paste(x, sep="", collapse=" "))
Ggenes=gsub("  ", "", Ggenes)
Ggenes[which(Ggenes==" ")]=""
Datx=rep("", nrow(Samp1$data))
Datx[match(LocAmerge$start[UniqueGainOlapRegions], S2$start)]=Ggenes

GG2=sapply(LossGenes, length)
GG3=unlist(LossGenes)
GG3[which(duplicated(GG3))]=""
GG4=split(GG3, rep(c(1:length(GG2)), times=GG2))
Lgenes=sapply(GG4, function(x) paste(x, sep="", collapse=" "))
Lgenes[which(Lgenes==" ")]=""
Daty=rep("", nrow(Samp1$data))
Daty[match(LocBmerge$start[UniqueLossOlapRegions], S2$start)]=Lgenes

## 
#S2=Samp1$data
#S2=S2[order(S2$chromosome, S2$start), ]
S2$xLoc=S2$start+chrInfo$sumdist[match(S2$chromosome, chrInfo$Chromosome)]
S2$width=S2$end-S2$start
S2$label=Datx

S3=S2
S3$gainProportion=S3$lossProportion[1:nrow(S2)]*(-1)
S3$label=Daty

S4=rbind(cbind(S3, col="blue"), cbind(S2, col="red"))
S4=S4[-which(S3$gainProportion==0), ]

ggplot(S4, aes(x=xLoc, y=gainProportion, width=width*1.2, label=label, col=col))+geom_bar(stat = "identity")+geom_label_repel()+theme_bw()+xlim(0, chrInfo$sumdist2[22])+geom_vline(xintercept=chrInfo$sumdist2,col="grey")+scale_colour_manual(values=c("blue", "red"))+annotate("text", x=chrInfo$sumdist, y=rep(-1, 22), label=chrInfo$Chromosome, col="black")

```

## Summary of the sequencing depth

Below, do a quick summary of the WGS data: what is the coverage, and plot the percentage mapping of the coverage:

```{r}
SeqData=read.delim("../data/wholegenome_mutations/summary_Sequencing_output.txt", sep="\t")

hist(SeqData$MEAN_COVERAGE, breaks=10)
```

Also, extract the information about coverage:

```{r}
SeqDatam=melt(SeqData[ ,c(grep("PCT_[0-9]*X", colnames(SeqData)), ncol(SeqData))])
SeqDatam$coverage2=sapply(strsplit(as.character(SeqDatam$variable), "_"), function(x) x[2])
SeqDatam$coverage3=as.numeric(substr(SeqDatam$coverage2, 1, nchar(SeqDatam$coverage2)-1))


ggplot(SeqDatam, aes(x=coverage3, y=value, col=Sample))+geom_line()+theme_bw()+ggtitle("WGS coverage")+ylab("Percentage Reads")+xlab("Coverage X")+xlim(c(0, 75))
```

<!--chapter:end:16-BICseqout.Rmd-->

# Writing files to file

Update the metadata file:
write to file:

* updated ext data table
* spatial information summary
* star aligned table
* colData information
* collapsed information on wsi/facs

```{r}
write.xlsx(Cdata, file=sprintf("../metadata/Ext_Data_Table_updated_%s.xlsx", Sys.Date()))

#colnames(Cdata)

x1=match(rownames(df.Spatial), gsub("_","", Cdata$TumorID))
df.Spatial$NewID=Cdata$NewID[x1]
dfB=Cdata[x1, c("NewID", "TumorID","TumorAreaWSI", "Tumor.diameter.sac.mm", "CD45.Frac.FACS",	
"DN.Frac.FACS",	"EpCAM.Frac.FACS")]

write.csv(df.Spatial, file="nature-tables/summary_spatial_information.csv")

colnames(allstarFinal)=infoTableFinal$TumorIDnew[match(colnames(allstarFinal), rownames(infoTableFinal))]
infoTableFinal2=infoTableFinal[ ,c("TumorIDnew","Growth", "CD8Frac", "TumSize", "Time.NMU2Sac", 
                                   "Age.Injection","Treatment","Cohort", "SizeCat")]
write.csv(infoTableFinal2, file="nature-tables/infoTableFinal2_output.csv")
write.csv(allstarFinal, file="nature-tables/allstarFinal_output.csv")


colTestCD8=c("CD8.EpBoundingBox", "CD8.TumSize", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", "T.cell.CD8._TIMER", "T.cell.CD8._CIBERSORT","T.cell.CD8._CIBERSORT.ABS", "T.cell.CD8._EPIC")

# colTestCD8=c("CD8.EpDomTiles","CD8.EpBoundingBox", "CD8.TumSize", "CD45.FACS", "CD8.FACS", "OverallCD8_Fig4c.Manual", "TIL_Fig4d.Manual", )
indx1=c("CD8.WSI", "CD8Frac.WSI", "CD8_EPorSMARatio.WSI","CD8_AnyEPRatio.WSI", "CD8_EPRatio.WSI","CD8normTumSize", "CD8.EpBoundingBox")

df.Spatial2=merge(df.Spatial, dfB, by.x="NewID", by.y="NewID", all=T)
#head(df.Spatial2)

colnames(ProgSpecCD45)=gsub("_CD45", "", colnames(ProgSpecCD45))
#colnames(ProgSpecCD45)=gsub("_", "", colnames(ProgSpecCD45))
rownames(ProgSpecCD45)=ProgSpecCD45[ ,1]
ProgSpecCD45B=t(ProgSpecCD45[grep("CD8",rownames(ProgSpecCD45)), -1 ])
ProgSpecCD45B=data.frame(ProgSpecCD45B, sample=rownames(ProgSpecCD45B))

df.Spatial3=merge(df.Spatial2, ProgSpecCD45B, by.x="TumorID", by.y="sample", all=T)
df.Spatial3$TumorID2=gsub("_", "", df.Spatial3$TumorID)

SummaryData$TumorID2=rownames(SummaryData)

df.Spatial4=merge(df.Spatial3, SummaryData[ ,c(6:8,17:19, ncol(SummaryData))], by.x="TumorID2", by.y="TumorID2", all=T)

write.csv(df.Spatial4, file="../metadata/summary_new_210330.csv")

## merge he data from df.Spatial with the data from 

#df1=data.frame(CD8.WSI=df.Spatial$)

 #  df2=data.frame(CD8.WSI=t(WSIvals[ 1, ]), 
 #                 CD8Frac.WSI=t(WSIvalFracs[ ,2]), 
 #                 CD8_EPorSMARatio.WSI=(WSIvals[1,  ]/colSums(WSIvals[2:4, ])),
 #                 CD8_AnyEPRatio.WSI=(WSIvals[1,  ]/colSums(WSIvals[2:3, ])),
 #                 CD8_EPRatio.WSI=(WSIvals[1,  ]/(WSIvals[2, ])),
 #                 CD8normTumSize=(WSIvals[1,  ]/df.Spatial))
 # #                )

```


Below is the session info

```{r}
sessionInfo()
```

<!--chapter:end:99-CheckSessionInfo.Rmd-->

# (APPENDIX) Appendix {-} 


Here we have a links to the list of the figures in this study

# List of Figures

## Main Figures{-}

## Figure 1: NMU-induced mammary tumors {-}

* Fig 1F: [Characterisation HR plot](#fig:1f)
* Fig 1G: [Ep DEG big-small](#fig:1g)
* Fig 1H: [Ep hairball with size](#fig:1h)
* Fig 1I: [summary of mutation burden](#fig:1i)
* Fig 1J: [Frequency of different mutational codons](#fig:1j)
* Fig 1K: [summary of mutations acccording to frequency cosmic](#fig:1k)
* Fig 1L: [summary of metacore common mutated pathways](#fig:1lb)


## Figure 2: Immune system of NMU-rat {-}

* Fig 2D: [Differential CD45 genes](#fig:2d)
* Fig 2E: [CD45 growing vs stable hairball](#fig:cd45-hairball)
* Fig 2F: [CIBERSORT shit](#fig:2fplot)
* Fig 2H: [bcr clonotypes in tumor and normal mammary glands](#fig:2h)

## Figure 3: Immunotherapy applied to NMU rats {-}

* Fig 3B: [Growth rates of tumors](#fig:3b)
* Fig 3C: [Growth rates of tumors w.r.t. treatment](#fig:3c)
* Fig 3D: [Histogram of growth rates of tumors](#fig:3d)
* Fig 3E: [Contingency table growth rate and treatment](#fig:3e)
* Fig 3G: [Trichrome staining growth rate and treatment](#fig:3g)
* Fig 3J: [Differentially expressed genes in CD45 fraction](#fig:3jb)

## Figure 4: Characterizing CD45 cells in tumors {-}

* Fig 4B: [association of frequency with treatment and growth](#fig:4b) 
* Fig 4C: [KNN distances](#fig:Fig4c)
* Fig 4D: [interacting fraction](#fig:if-growth) 
* Fig 4E: [MH index with CD8 growth](#fig:4e)
* Fig 4F: [Progression CIBERSORT TIMER](#fig:4f)
* Fig 4G: [volcano plot of DEG stable vs growing CD45](#fig:4g)
* Fig 4H: [CD45 cells enriched pathways](#fig:4h)
* Fig 4I: [BCR clonotypes with respect to treatment/growth](#fig:4i)

## Figure 5 : Epithelial cells in growing vs stable rats {-}

* Fig 5A: [GSEA summary stable growing](#fig:5a)
* Fig 5B: [ssGSEA scores for specific pathways](#fig:5b)
* Fig 5D: [CD74 assoc with patient data](#fig:5d)
* Fig 5E: [forest plot CD74](#fig:5e)
* Fig 5F: [lum only non-inflamm growth vs stable DEG](#fig:EpddsLum)
* Fig 5G: [lum only non-inflamm growth vs stable hairball](#fig:gsea-noninf-lum-branch)
* Fig 5H [luminal signature associated with clinical variables](#fig:5h)
* Fig 5I [OS and DFS for growing signature](#fig:5i)
* Fig 5J [TCGA DEG for LumA samples](#fig:tcga-volcano)
* Fig 5K [TCGA HAIRBALL for LumA samples](#fig:TCGA-gsea)

# Extended Figures{-}

## Extended data 1{-}

* Ext Fig 1B : [Number of tumors per rat in each cohort](#fig:Ext1b)
* Ext Fig 1C: [growth of NMU treated tumors over time](#fig:Ext1c)
* Ext Fig 1F: [PCA of growing vs stable epithelial cells](#fig:Ext1f)
* Ext Fig 1G: [correlation plot epithelial samples](#fig:Ext1g)
* Ext Fig 1H-I: [assoc of mutations with cohort](#fig:Ext1h)
* Ext Fig 1J: [Alexandrov mutational signatures](#fig:Ext1j)
* Ext Fig 1K: [most frequent mutations](#fig:Ext1k)
* Ext Fig 1L: [CNV calls](#fig:bicseq)


## Extended data 2 {-}

* Ext2D [PCA of CD45 cells](#fig:Ext2d)
* Ext2E [clonotype assoc with size](#fig:Ext2e)
* Ext2F [expression of checkpoint proteins in epithelial cells](#fig:Ext2f)

## Extended data 3{-}

* Ext Fig 3C : [FACS associated with outcome](#fig:Ext3c)
* Ext Fig 3D : [PCA plot all cell types](#fig:Ext3d)
* Ext Fig 3E : [Cell type specific genes](#fig:Ext3e)
* Ext Fig 3H: [DN assoc treatment GSEA](#fig:Ext3h)
* Ext Fig 3I : [HR clustering output progression](#fig:Ext3i)



## Extended data 4{-}

* Ext Fig 4B [association with facs](#fig:Ext4b) 
* Ext Fig 4C-D [WSI-normalised-all-samples](#fig:Ext4c)
* Ext Fig 4E [Knn with treatment](#fig:Fig4c) 
* Ext Fig 4F [Interacting fraction with treatment](#fig:if-growth) 
* Ext Fig 4H [MH with treatment](#fig:Ext4h) 


## Extended data 5{-}

* Ext Fig 5A: [Expression of inflammatory genes across samples](#fig:Ext5b)
* Ext Fig 5B [growth profiles of inflammatory tumors](#fig:5xta)
* Ext Fig 5C: [Differential gene exp inflammatory vs non-inflammatory](#fig:Ext5c)
* Ext Fig 5D: [association signature with WSI](#fig:Ext5d)
* Ext Fig 5E: [Collagen content in growing vs stable](#fig:Ext5i)
* Ext Fig 5F: [Forest plot TCGA luminal ADAMTS10](#fig:Ext5f)
* Ext Fig 5G [ADAMST10 expression associated with clinical variables](#fig:Ext5g)
* Ext Fig 5I-J: [Associating growing signature with clinical variables](#fig:Ext5i-growing)
* Ext Fig 5K: [TCGA DEG for LumA samples](#fig:tcga-volcano)

<!--chapter:end:Appendix.Rmd-->

